import ast
import utils
import inputs
import config
import name_in_scope
import outputs::no_typeof_undef

// Variable usages (`let` and `const` predecls or undefined symbols) that don't
// have an accompanying variable in scope are reported
// TODO: Use a levenshtein aggregate to try and correct and/or look in children
//       scopes for a declaration
output relation NoUndef(name: Name, scope: ScopeId, span: Span)
NoUndef(name, scope, span) :-
    EnableNoUndef(file, _),

    NameRef(expr @ ExprId { _, file }, name),
    Expression(expr, ExprNameRef, scope, span),
    // Expressions like `typeof not_undefined` are allowed under NoUndef
    // and are instead output through TypeofUndef
    not WithinTypeofExpr(_, expr),
    not ChainedWith(_, expr),
    not NameInScope(name, scope, _).

// Assignments
NoUndef(name, scope, span) :-
    EnableNoUndef(file, _),

    Assign(expr @ ExprId { _, file }, Some { Left { pat }}, _, _),
    Expression(expr, _, scope, _),
    // FIXME: Waiting on https://github.com/vmware/differential-datalog/issues/784
    var bound_var = FlatMap(pat.bound_vars()),
    Spanned { var name, var span } = bound_var,
    not NameInScope(name, scope, _).


// The successors of an expression, property accesses or method calls
relation ChainedWith(object: ExprId, property: ExprId)
ChainedWith(object, property) :-
    EnableNoUndef(file, _),
    BracketAccess(ExprId { _, file }, Some { object }, Some { property }).

ChainedWith(object, property) :-
    EnableNoUndef(file, _),
    DotAccess(property @ ExprId { _, file }, Some { object }, _).

ChainedWith(object, property) :-
    ChainedWith(object, interum),
    ChainedWith(interum, property).
