import vec
import ast
import utils
import group
import inputs
import scopes
import var_decls

/// The origin of a name
// TODO: More variants
typedef NameOrigin =
    /// The name came from an implicit global variable
    AutoGlobal
    /// The name was imported
    | Imported
    /// The name was defined in the given scope
    | UserDefined { scope: ScopeId }

// TODO: Reduce the size of this since there are so many copies of it
typedef NameInScope = NameInScope {
    /// The file the name belongs to
    file: FileId,
    /// The name of the symbol
    name: Name,
    /// The scope the symbol is in-scope within
    scope: ScopeId,
    /// The id of the item that declared the symbol
    declared: AnyId,
}

/// The `NameInScope` relation gives every name/symbol/ident that's defined for any given scope.
/// Names are walked down children scopes, meaning all children have access to the variables of
/// their parent scope(s). Each rule of `NameInScope` utilizes `NameVisibleInScope` to only propigate
/// *used* variables down scopes to avoid an exponental explosion of names that drastically increases
/// compute time and memory usage. This allows lazily computing names within scope, since variables
/// will only be propigated down segments of scope trees where they're actually used, which is
/// especally important when you consider JS's ungodly amount of global variables (both implicit
/// and user-defined). All in all it reduces the memory/cpu usage of this relation to be linear
/// with the amount of code being processed instead of some terrifying exponent.
///
/// ```
/// // 'a defines the `foo` symbol
/// 'a: { foo }
///  │
///  │ // 'b defines the `bar` symbol and inherits
///  │ // the `foo` symbol
///  └-'b: { foo, bar }
/// ```
///
relation NameInScope[NameInScope]

// An index that returns all variables avaliable in a given scope
index Index_VariablesForScope(file: FileId, scope: ScopeId)
    on NameInScope[NameInScope { .file = file, .scope = scope }]

// An index that returns all variables by the given name in the given scope
index Index_VariableInScope(file: FileId, scope: ScopeId, variable: Name)
    on NameInScope[NameInScope { .file = file, .name = variable, .scope = scope }]

// Introduce all declared variables where they're used
NameInScope(file, name, scope, declared) :-
    VariableDeclarations(file, name, scope, _, declared, _, _, _),
    NameVisibleInScope(name, scope, file).

// Walk variables down scopes
NameInScope(file, name, to, declared) :-
    NameVisibleInScope(name, to, file),
    not VariableDeclarations(file, name, to, _, _, _, _, _),
    InputScope(from, to, file),
    NameInScope(file, name, from, declared).

/// A record of where variable usages actually happen
relation NameVisibleInScope(name: Name, scope: ScopeId, file: FileId)

/// Add all name references
NameVisibleInScope(name, scope, file) :-
    NameRef(id, file, name),
    Expression(id, file, _, scope, _).

/// Add assignment patterns
NameVisibleInScope(name, scope, file) :-
    Assign(id, file, Some { Left { pattern }}, _, _),
    Expression(id, file, _, scope, _),
    var name = FlatMap(pattern.bound_vars().map(|name| name.data)).

/// Add exports
NameVisibleInScope(name, scope, file) :-
    FileExport(file, NamedExport { export_name, export_alias }, scope),
    Some { Spanned { var name, _ }} = export_alias.or_else(export_name).

/// Recurse to parent scopes
NameVisibleInScope(name, parent, file) :-
    NameVisibleInScope(name, child, file),
    InputScope(parent, child, file).
