import vec
import ast
import utils
import group
import inputs
import scopes
import config
import intern
import var_decls

/// A relation transformer to preform symbol resolution on JS files
extern transformer ResolveSymbols(
    /// A stream of the files which need symbol resolution to run on them
    FilesToResolve: relation[NeedsSymbolResolution],

    /// A stream of all variable declarations
    VariableDeclarations: relation[VariableDeclarations],

    /// A stream containing all parent->child scope associations
    InputScopes: relation[InputScope],

    /// A stream containing all expressions
    Expressions: relation[Expression],

    /// A stream containing all name references
    NameRefs: relation[NameRef],

    /// A stream containing all assignments
    Assignments: relation[Assign],

    /// A stream containing all file exports
    FileExports: relation[FileExport],
) -> (
    /// A stream of the resolved names
    NameInScope: relation[NameInScope],

    /// A relation containing all scopes that variables
    /// have been declared in
    ScopeOfDeclName: relation[ScopeOfDeclName],
)


relation NeedsSymbolResolution(file: FileId)
NeedsSymbolResolution(file) :- EnableNoTypeofUndef(file, _).
NeedsSymbolResolution(file) :- EnableNoUndef(file, _).
NeedsSymbolResolution(file) :- EnableNoUseBeforeDef(file, _).
NeedsSymbolResolution(file) :- EnableNoUnusedVars(file, _).


// TODO: Reduce the size of this since there are so many copies of it
typedef NameInScope = NameInScope {
    /// The name of the symbol
    name: Name,
    /// The scope the symbol is in-scope within
    scope: ScopeId,
    /// The id of the item that declared the symbol
    declared: AnyId,
}

relation NameInScope[NameInScope]

typedef ScopeOfDeclName = ScopeOfDeclName {
    name: Name,
    scope: ScopeId,
    declared: AnyId,
}

relation ScopeOfDeclName[ScopeOfDeclName]

apply ResolveSymbols(
    NeedsSymbolResolution,
    VariableDeclarations,
    InputScope,
    Expression,
    NameRef,
    Assign,
    FileExport,
) -> (
    NameInScope,
    ScopeOfDeclName,
)


/// The `NameInScope` relation gives every name/symbol/ident that's defined for any given scope.
/// Names are walked down children scopes, meaning all children have access to the variables of
/// their parent scope(s). Each rule of `NameInScope` utilizes `NameOccursInScope` to only propigate
/// *used* variables down scopes to avoid an exponental explosion of names that drastically increases
/// compute time and memory usage. This allows lazily computing names within scope, since variables
/// will only be propigated down segments of scope trees where they're actually used, which is
/// especally important when you consider JS's ungodly amount of global variables (both implicit
/// and user-defined). All in all it reduces the memory/cpu usage of this relation to be linear
/// with the amount of code being processed instead of some terrifying exponent.
///
/// ```
/// // 'a defines the `foo` symbol
/// 'a: { foo }
///  │
///  │ // 'b defines the `bar` symbol and inherits
///  │ // the `foo` symbol
///  └-'b: { foo, bar }
/// ```
///
// relation NameInScope[NameInScope]

// An index that returns all variables avaliable in a given scope
index Index_VariablesForScope(scope: ScopeId)
    on NameInScope[NameInScope { .scope = scope }]

// An index that returns all variables by the given name in the given scope
index Index_VariableInScope(scope: ScopeId, variable: Name)
    on NameInScope[NameInScope { .name = variable, .scope = scope }]

// Introduce all declared variables where they're used
// NameInScope(name, variable_scope, declared) :-
//     NeedsSymbolResolution(file),
//     VariableDeclarations(name, scope, declared, _),
//     declared.file() == Some { file },
//     var variable_scope = scope.hoisted_scope(),
//     NameOccursInScope(variable_scope, name).
// 
// // Walk variables down scopes
// NameInScope(name, child, declared) :-
//     NameOccursInScope(child, name),
//     not ScopeOfDeclName(name, child, _),
//     InputScope(parent, child),
//     NameInScope(name, parent, declared).


// /// The scopes that variable declarations occur in
// relation ScopeOfDeclName(name: Name, scope: ScopeId, declared: AnyId)
// ScopeOfDeclName(name, scope, declared) :-
//     NeedsSymbolResolution(file),
//     VariableDeclarations(name, Unhoistable { scope @ ScopeId { _, file }}, declared, _).
// ScopeOfDeclName(name, scope, declared) :-
//     NeedsSymbolResolution(file),
//     VariableDeclarations(name, Hoistable { scope @ ScopeId { _, file }, _ }, declared, _).
// 
// 
// /// A record of where variable usages actually happen
// relation NameOccursInScope(scope: ScopeId, name: Name)
// 
// /// Add all name references
// NameOccursInScope(scope, name) :-
//     NeedsSymbolResolution(file),
//     NameRef(id @ ExprId { _, file }, name),
//     Expression(id, _, scope, _),.
// 
// /// Add assignment patterns
// NameOccursInScope(scope, name) :-
//     NeedsSymbolResolution(file),
//     Assign(id @ ExprId { _, file }, Some { Left { pattern }}, _, _),
//     Expression(id, _, scope, _),
//     var name = FlatMap(pattern.bound_vars().map(|name| name.data)).
// 
// /// Add exports
// NameOccursInScope(scope, name) :-
//     NeedsSymbolResolution(file),
//     FileExport(NamedExport { export_name, export_alias }, scope @ ScopeId { _, file }),
//     Some { Spanned { var name, _ }} = export_alias.or_else(export_name).
// 
// /// Recurse to parent scopes
// NameOccursInScope(parent, name) :-
//     NameOccursInScope(child, name),
//     InputScope(parent, child).
// 
