#![allow(
    unused_imports,
    non_snake_case,
    non_camel_case_types,
    non_upper_case_globals,
    unused_parens,
    non_shorthand_field_patterns,
    dead_code,
    overflowing_literals,
    unreachable_patterns,
    unused_variables,
    clippy::unknown_clippy_lints,
    clippy::missing_safety_doc,
    clippy::toplevel_ref_arg,
    clippy::double_parens,
    clippy::clone_on_copy,
    clippy::just_underscores_and_digits,
    clippy::match_single_binding,
    clippy::op_ref,
    clippy::nonminimal_bool,
    clippy::redundant_clone
)]

use num::bigint::BigInt;
use std::convert::TryFrom;
use std::hash::Hash;
use std::ops::Deref;
use std::ptr;
use std::result;
use std::{any::TypeId, sync};

use ordered_float::*;

use differential_dataflow::collection;
use timely::communication;
use timely::dataflow::scopes;
use timely::worker;

use differential_datalog::ddval::*;
use differential_datalog::int::*;
use differential_datalog::program::*;
use differential_datalog::record;
use differential_datalog::record::FromRecord;
use differential_datalog::record::IntoRecord;
use differential_datalog::record::RelIdentifier;
use differential_datalog::record::UpdCmd;
use differential_datalog::uint::*;
use differential_datalog::DDlogConvert;
use num_traits::cast::FromPrimitive;
use num_traits::identities::One;
use once_cell::sync::Lazy;

use fnv::FnvHashMap;

pub mod api;
pub mod ovsdb_api;
pub mod update_handler;

use crate::api::updcmd2upd;
use ::types::closure;
use ::types::string_append;
use ::types::string_append_str;

use serde::ser::SerializeTuple;
use serde::Deserialize;
use serde::Deserializer;
use serde::Serialize;
use serde::Serializer;

/// A default implementation of `DDlogConvert` that just forwards calls
/// to generated functions of equal name.
#[derive(Debug)]
pub struct DDlogConverter {}

impl DDlogConvert for DDlogConverter {
    fn relid2name(relId: RelId) -> Option<&'static str> {
        relid2name(relId)
    }

    fn indexid2name(idxId: IdxId) -> Option<&'static str> {
        indexid2name(idxId)
    }

    fn updcmd2upd(upd_cmd: &UpdCmd) -> ::std::result::Result<Update<DDValue>, String> {
        updcmd2upd(upd_cmd)
    }
}

/* Wrapper around `Update<DDValue>` type that implements `Serialize` and `Deserialize`
 * traits.  It is currently only used by the distributed_ddlog crate in order to
 * serialize updates before sending them over the network and deserializing them on the
 * way back.  In other scenarios, the user either creates a `Update<DDValue>` type
 * themselves (when using the strongly typed DDlog API) or deserializes `Update<DDValue>`
 * from `Record` using `DDlogConvert::updcmd2upd()`.
 *
 * Why use a wrapper instead of implementing the traits for `Update<DDValue>` directly?
 * `Update<>` and `DDValue` types are both declared in the `differential_datalog` crate,
 * whereas the `Deserialize` implementation is program-specific and must be in one of the
 * generated crates, so we need a wrapper to avoid creating an orphan `impl`.
 *
 * Serialized representation: we currently only serialize `Insert` and `DeleteValue`
 * commands, represented in serialized form as (polarity, relid, value) tuple.  This way
 * the deserializer first reads relid and uses it to decide which value to deserialize
 * next.
 *
 * `impl Serialize` - serializes the value by forwarding `serialize` call to the `DDValue`
 * object (in fact, it is generic and could be in the `differential_datalog` crate, but we
 * keep it here to make it easier to keep it in sync with `Deserialize`).
 *
 * `impl Deserialize` - gets generated in `Compile.hs` using the macro below.  The macro
 * takes a list of `(relid, type)` and generates a match statement that uses type-specific
 * `Deserialize` for each `relid`.
 */
#[derive(Debug)]
pub struct UpdateSerializer(Update<DDValue>);

impl From<Update<DDValue>> for UpdateSerializer {
    fn from(u: Update<DDValue>) -> Self {
        UpdateSerializer(u)
    }
}
impl From<UpdateSerializer> for Update<DDValue> {
    fn from(u: UpdateSerializer) -> Self {
        u.0
    }
}

impl Serialize for UpdateSerializer {
    fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        let mut tup = serializer.serialize_tuple(3)?;
        match &self.0 {
            Update::Insert { relid, v } => {
                tup.serialize_element(&true)?;
                tup.serialize_element(relid)?;
                tup.serialize_element(v)?;
            }
            Update::DeleteValue { relid, v } => {
                tup.serialize_element(&false)?;
                tup.serialize_element(relid)?;
                tup.serialize_element(v)?;
            }
            _ => panic!("Cannot serialize InsertOrUpdate/Modify/DeleteKey update"),
        };
        tup.end()
    }
}

#[macro_export]
macro_rules! decl_update_deserializer {
    ( $n:ty, $(($rel:expr, $typ:ty)),* ) => {
        impl<'de> ::serde::Deserialize<'de> for $n {
            fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> ::std::result::Result<Self, D::Error> {

                struct UpdateVisitor;

                impl<'de> ::serde::de::Visitor<'de> for UpdateVisitor {
                    type Value = $n;

                    fn expecting(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                        formatter.write_str("(polarity, relid, value) tuple")
                    }

                    fn visit_seq<A>(self, mut seq: A) -> ::std::result::Result<Self::Value, A::Error>
                    where A: ::serde::de::SeqAccess<'de> {
                        let polarity = seq.next_element::<bool>()?.ok_or_else(|| <A::Error as ::serde::de::Error>::custom("Missing polarity"))?;
                        let relid = seq.next_element::<RelId>()?.ok_or_else(|| <A::Error as ::serde::de::Error>::custom("Missing relation id"))?;
                        match relid {
                            $(
                                $rel => {
                                    let v = seq.next_element::<$typ>()?.ok_or_else(|| <A::Error as ::serde::de::Error>::custom("Missing value"))?.into_ddvalue();
                                    if polarity {
                                        Ok(UpdateSerializer(Update::Insert{relid, v}))
                                    } else {
                                        Ok(UpdateSerializer(Update::DeleteValue{relid, v}))
                                    }
                                },
                            )*
                            _ => {
                                ::std::result::Result::Err(<A::Error as ::serde::de::Error>::custom(format!("Unknown input relation id {}", relid)))
                            }
                        }
                    }
                }

                deserializer.deserialize_tuple(3, UpdateVisitor)
            }
        }
    };
}

/* FlatBuffers bindings generated by `ddlog` */
#[cfg(feature = "flatbuf")]
pub mod flatbuf;

impl TryFrom<&RelIdentifier> for Relations {
    type Error = ();

    fn try_from(rel_id: &RelIdentifier) -> ::std::result::Result<Self, ()> {
        match rel_id {
            RelIdentifier::RelName(rname) => Relations::try_from(rname.as_ref()),
            RelIdentifier::RelId(id) => Relations::try_from(*id),
        }
    }
}


decl_update_deserializer!(UpdateSerializer,(10, ::types::inputs::Array), (11, ::types::inputs::Arrow), (12, ::types::inputs::ArrowParam), (13, ::types::inputs::Assign), (14, ::types::inputs::Await), (15, ::types::inputs::BinOp), (16, ::types::inputs::BracketAccess), (17, ::types::inputs::Break), (18, ::types::inputs::Call), (19, ::types::inputs::Class), (20, ::types::inputs::ClassExpr), (21, ::types::inputs::ConstDecl), (22, ::types::inputs::Continue), (23, ::types::inputs::DoWhile), (24, ::types::inputs::DotAccess), (25, ::types::inputs::EveryScope), (26, ::types::inputs::ExprBigInt), (27, ::types::inputs::ExprBool), (28, ::types::inputs::ExprNumber), (29, ::types::inputs::ExprString), (30, ::types::inputs::Expression), (31, ::types::inputs::File), (32, ::types::inputs::FileExport), (33, ::types::inputs::For), (34, ::types::inputs::ForIn), (35, ::types::inputs::ForOf), (36, ::types::inputs::Function), (37, ::types::inputs::FunctionArg), (38, ::types::inputs::If), (39, ::types::inputs::ImplicitGlobal), (40, ::types::inputs::ImportDecl), (41, ::types::inputs::InlineFunc), (42, ::types::inputs::InlineFuncParam), (43, ::types::inputs::InputScope), (44, ::types::inputs::Label), (45, ::types::inputs::LetDecl), (46, ::types::inputs::NameRef), (47, ::types::inputs::New), (48, ::types::inputs::Property), (49, ::types::inputs::Return), (50, ::types::inputs::Statement), (51, ::types::inputs::Switch), (52, ::types::inputs::SwitchCase), (53, ::types::inputs::Template), (54, ::types::inputs::Ternary), (55, ::types::inputs::Throw), (56, ::types::inputs::Try), (57, ::types::inputs::UnaryOp), (58, ::types::inputs::UserGlobal), (59, ::types::inputs::VarDecl), (60, ::types::inputs::While), (61, ::types::inputs::With), (62, ::types::inputs::Yield), (67, ::types::outputs::no_shadow::NoShadow), (69, ::types::outputs::no_undef::NoUndef), (71, ::types::outputs::no_unused_labels::NoUnusedLabels), (72, ::types::outputs::no_unused_labels::UsedLabels), (73, ::types::outputs::typeof_undef::TypeofUndef), (75, ::types::outputs::unused_vars::UnusedVariables), (76, ::types::outputs::use_before_def::UseBeforeDef));
impl TryFrom<&str> for Relations {
    type Error = ();
    fn try_from(rname: &str) -> ::std::result::Result<Self, ()> {
         match rname {
        "__Prefix_0" => Ok(Relations::__Prefix_0),
        "__Prefix_1" => Ok(Relations::__Prefix_1),
        "__Prefix_2" => Ok(Relations::__Prefix_2),
        "__Prefix_3" => Ok(Relations::__Prefix_3),
        "__Prefix_4" => Ok(Relations::__Prefix_4),
        "__Prefix_5" => Ok(Relations::__Prefix_5),
        "__Prefix_6" => Ok(Relations::__Prefix_6),
        "__Prefix_7" => Ok(Relations::__Prefix_7),
        "__Prefix_8" => Ok(Relations::__Prefix_8),
        "__Prefix_9" => Ok(Relations::__Prefix_9),
        "inputs::Array" => Ok(Relations::inputs_Array),
        "inputs::Arrow" => Ok(Relations::inputs_Arrow),
        "inputs::ArrowParam" => Ok(Relations::inputs_ArrowParam),
        "inputs::Assign" => Ok(Relations::inputs_Assign),
        "inputs::Await" => Ok(Relations::inputs_Await),
        "inputs::BinOp" => Ok(Relations::inputs_BinOp),
        "inputs::BracketAccess" => Ok(Relations::inputs_BracketAccess),
        "inputs::Break" => Ok(Relations::inputs_Break),
        "inputs::Call" => Ok(Relations::inputs_Call),
        "inputs::Class" => Ok(Relations::inputs_Class),
        "inputs::ClassExpr" => Ok(Relations::inputs_ClassExpr),
        "inputs::ConstDecl" => Ok(Relations::inputs_ConstDecl),
        "inputs::Continue" => Ok(Relations::inputs_Continue),
        "inputs::DoWhile" => Ok(Relations::inputs_DoWhile),
        "inputs::DotAccess" => Ok(Relations::inputs_DotAccess),
        "inputs::EveryScope" => Ok(Relations::inputs_EveryScope),
        "inputs::ExprBigInt" => Ok(Relations::inputs_ExprBigInt),
        "inputs::ExprBool" => Ok(Relations::inputs_ExprBool),
        "inputs::ExprNumber" => Ok(Relations::inputs_ExprNumber),
        "inputs::ExprString" => Ok(Relations::inputs_ExprString),
        "inputs::Expression" => Ok(Relations::inputs_Expression),
        "inputs::File" => Ok(Relations::inputs_File),
        "inputs::FileExport" => Ok(Relations::inputs_FileExport),
        "inputs::For" => Ok(Relations::inputs_For),
        "inputs::ForIn" => Ok(Relations::inputs_ForIn),
        "inputs::ForOf" => Ok(Relations::inputs_ForOf),
        "inputs::Function" => Ok(Relations::inputs_Function),
        "inputs::FunctionArg" => Ok(Relations::inputs_FunctionArg),
        "inputs::If" => Ok(Relations::inputs_If),
        "inputs::ImplicitGlobal" => Ok(Relations::inputs_ImplicitGlobal),
        "inputs::ImportDecl" => Ok(Relations::inputs_ImportDecl),
        "inputs::InlineFunc" => Ok(Relations::inputs_InlineFunc),
        "inputs::InlineFuncParam" => Ok(Relations::inputs_InlineFuncParam),
        "inputs::InputScope" => Ok(Relations::inputs_InputScope),
        "inputs::Label" => Ok(Relations::inputs_Label),
        "inputs::LetDecl" => Ok(Relations::inputs_LetDecl),
        "inputs::NameRef" => Ok(Relations::inputs_NameRef),
        "inputs::New" => Ok(Relations::inputs_New),
        "inputs::Property" => Ok(Relations::inputs_Property),
        "inputs::Return" => Ok(Relations::inputs_Return),
        "inputs::Statement" => Ok(Relations::inputs_Statement),
        "inputs::Switch" => Ok(Relations::inputs_Switch),
        "inputs::SwitchCase" => Ok(Relations::inputs_SwitchCase),
        "inputs::Template" => Ok(Relations::inputs_Template),
        "inputs::Ternary" => Ok(Relations::inputs_Ternary),
        "inputs::Throw" => Ok(Relations::inputs_Throw),
        "inputs::Try" => Ok(Relations::inputs_Try),
        "inputs::UnaryOp" => Ok(Relations::inputs_UnaryOp),
        "inputs::UserGlobal" => Ok(Relations::inputs_UserGlobal),
        "inputs::VarDecl" => Ok(Relations::inputs_VarDecl),
        "inputs::While" => Ok(Relations::inputs_While),
        "inputs::With" => Ok(Relations::inputs_With),
        "inputs::Yield" => Ok(Relations::inputs_Yield),
        "is_exported::IsExported" => Ok(Relations::is_exported_IsExported),
        "name_in_scope::NameInScope" => Ok(Relations::name_in_scope_NameInScope),
        "name_in_scope::NameOccursInScope" => Ok(Relations::name_in_scope_NameOccursInScope),
        "outputs::no_shadow::DeclarationVisibleWithin" => Ok(Relations::outputs_no_shadow_DeclarationVisibleWithin),
        "outputs::no_shadow::NoShadow" => Ok(Relations::outputs_no_shadow_NoShadow),
        "outputs::no_undef::ChainedWith" => Ok(Relations::outputs_no_undef_ChainedWith),
        "outputs::no_undef::NoUndef" => Ok(Relations::outputs_no_undef_NoUndef),
        "outputs::no_unused_labels::LabelUsage" => Ok(Relations::outputs_no_unused_labels_LabelUsage),
        "outputs::no_unused_labels::NoUnusedLabels" => Ok(Relations::outputs_no_unused_labels_NoUnusedLabels),
        "outputs::no_unused_labels::UsedLabels" => Ok(Relations::outputs_no_unused_labels_UsedLabels),
        "outputs::typeof_undef::TypeofUndef" => Ok(Relations::outputs_typeof_undef_TypeofUndef),
        "outputs::typeof_undef::WithinTypeofExpr" => Ok(Relations::outputs_typeof_undef_WithinTypeofExpr),
        "outputs::unused_vars::UnusedVariables" => Ok(Relations::outputs_unused_vars_UnusedVariables),
        "outputs::use_before_def::UseBeforeDef" => Ok(Relations::outputs_use_before_def_UseBeforeDef),
        "scopes::FunctionLevelScope" => Ok(Relations::scopes_FunctionLevelScope),
        "scopes::IsHoistable" => Ok(Relations::scopes_IsHoistable),
        "scopes::NeedsScopeChildren" => Ok(Relations::scopes_NeedsScopeChildren),
        "scopes::NeedsScopeParents" => Ok(Relations::scopes_NeedsScopeParents),
        "scopes::ScopeFamily" => Ok(Relations::scopes_ScopeFamily),
        "scopes::ScopeOfId" => Ok(Relations::scopes_ScopeOfId),
        "var_decls::VariableDeclarations" => Ok(Relations::var_decls_VariableDeclarations),
        "variable_decl::VariableDecl" => Ok(Relations::variable_decl_VariableDecl),
             _  => Err(())
         }
    }
}
impl Relations {
    pub fn is_output(&self) -> bool {
        match self {
        Relations::outputs_no_shadow_NoShadow => true,
        Relations::outputs_no_undef_NoUndef => true,
        Relations::outputs_no_unused_labels_NoUnusedLabels => true,
        Relations::outputs_no_unused_labels_UsedLabels => true,
        Relations::outputs_typeof_undef_TypeofUndef => true,
        Relations::outputs_unused_vars_UnusedVariables => true,
        Relations::outputs_use_before_def_UseBeforeDef => true,
            _  => false
        }
    }
}
impl Relations {
    pub fn is_input(&self) -> bool {
        match self {
        Relations::inputs_Array => true,
        Relations::inputs_Arrow => true,
        Relations::inputs_ArrowParam => true,
        Relations::inputs_Assign => true,
        Relations::inputs_Await => true,
        Relations::inputs_BinOp => true,
        Relations::inputs_BracketAccess => true,
        Relations::inputs_Break => true,
        Relations::inputs_Call => true,
        Relations::inputs_Class => true,
        Relations::inputs_ClassExpr => true,
        Relations::inputs_ConstDecl => true,
        Relations::inputs_Continue => true,
        Relations::inputs_DoWhile => true,
        Relations::inputs_DotAccess => true,
        Relations::inputs_EveryScope => true,
        Relations::inputs_ExprBigInt => true,
        Relations::inputs_ExprBool => true,
        Relations::inputs_ExprNumber => true,
        Relations::inputs_ExprString => true,
        Relations::inputs_Expression => true,
        Relations::inputs_File => true,
        Relations::inputs_FileExport => true,
        Relations::inputs_For => true,
        Relations::inputs_ForIn => true,
        Relations::inputs_ForOf => true,
        Relations::inputs_Function => true,
        Relations::inputs_FunctionArg => true,
        Relations::inputs_If => true,
        Relations::inputs_ImplicitGlobal => true,
        Relations::inputs_ImportDecl => true,
        Relations::inputs_InlineFunc => true,
        Relations::inputs_InlineFuncParam => true,
        Relations::inputs_InputScope => true,
        Relations::inputs_Label => true,
        Relations::inputs_LetDecl => true,
        Relations::inputs_NameRef => true,
        Relations::inputs_New => true,
        Relations::inputs_Property => true,
        Relations::inputs_Return => true,
        Relations::inputs_Statement => true,
        Relations::inputs_Switch => true,
        Relations::inputs_SwitchCase => true,
        Relations::inputs_Template => true,
        Relations::inputs_Ternary => true,
        Relations::inputs_Throw => true,
        Relations::inputs_Try => true,
        Relations::inputs_UnaryOp => true,
        Relations::inputs_UserGlobal => true,
        Relations::inputs_VarDecl => true,
        Relations::inputs_While => true,
        Relations::inputs_With => true,
        Relations::inputs_Yield => true,
            _  => false
        }
    }
}
impl Relations {
    pub fn type_id(&self) -> ::std::any::TypeId {
        match self {
            Relations::__Prefix_0 => ::std::any::TypeId::of::<::types::ddlog_std::tuple7<::types::ast::FileId, ::types::config::Config, ::types::ast::ExprId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span, ::types::internment::Intern<String>>>(),
            Relations::__Prefix_1 => ::std::any::TypeId::of::<::types::ddlog_std::tuple6<::types::ast::FileId, ::types::config::Config, ::types::ast::ExprId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span>>(),
            Relations::__Prefix_2 => ::std::any::TypeId::of::<::types::ddlog_std::tuple5<::types::ast::FileId, ::types::config::Config, ::types::ast::StmtId, ::types::ast::Spanned<::types::ast::Name>, ::types::ast::ScopeId>>(),
            Relations::__Prefix_3 => ::std::any::TypeId::of::<::types::ddlog_std::tuple4<::types::ast::FileId, ::types::config::Config, ::types::ast::ExprId, ::types::ast::ExprId>>(),
            Relations::__Prefix_4 => ::std::any::TypeId::of::<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>(),
            Relations::__Prefix_5 => ::std::any::TypeId::of::<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>(),
            Relations::__Prefix_6 => ::std::any::TypeId::of::<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>(),
            Relations::__Prefix_7 => ::std::any::TypeId::of::<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>(),
            Relations::__Prefix_8 => ::std::any::TypeId::of::<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>(),
            Relations::__Prefix_9 => ::std::any::TypeId::of::<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>(),
            Relations::inputs_Array => ::std::any::TypeId::of::<::types::inputs::Array>(),
            Relations::inputs_Arrow => ::std::any::TypeId::of::<::types::inputs::Arrow>(),
            Relations::inputs_ArrowParam => ::std::any::TypeId::of::<::types::inputs::ArrowParam>(),
            Relations::inputs_Assign => ::std::any::TypeId::of::<::types::inputs::Assign>(),
            Relations::inputs_Await => ::std::any::TypeId::of::<::types::inputs::Await>(),
            Relations::inputs_BinOp => ::std::any::TypeId::of::<::types::inputs::BinOp>(),
            Relations::inputs_BracketAccess => ::std::any::TypeId::of::<::types::inputs::BracketAccess>(),
            Relations::inputs_Break => ::std::any::TypeId::of::<::types::inputs::Break>(),
            Relations::inputs_Call => ::std::any::TypeId::of::<::types::inputs::Call>(),
            Relations::inputs_Class => ::std::any::TypeId::of::<::types::inputs::Class>(),
            Relations::inputs_ClassExpr => ::std::any::TypeId::of::<::types::inputs::ClassExpr>(),
            Relations::inputs_ConstDecl => ::std::any::TypeId::of::<::types::inputs::ConstDecl>(),
            Relations::inputs_Continue => ::std::any::TypeId::of::<::types::inputs::Continue>(),
            Relations::inputs_DoWhile => ::std::any::TypeId::of::<::types::inputs::DoWhile>(),
            Relations::inputs_DotAccess => ::std::any::TypeId::of::<::types::inputs::DotAccess>(),
            Relations::inputs_EveryScope => ::std::any::TypeId::of::<::types::inputs::EveryScope>(),
            Relations::inputs_ExprBigInt => ::std::any::TypeId::of::<::types::inputs::ExprBigInt>(),
            Relations::inputs_ExprBool => ::std::any::TypeId::of::<::types::inputs::ExprBool>(),
            Relations::inputs_ExprNumber => ::std::any::TypeId::of::<::types::inputs::ExprNumber>(),
            Relations::inputs_ExprString => ::std::any::TypeId::of::<::types::inputs::ExprString>(),
            Relations::inputs_Expression => ::std::any::TypeId::of::<::types::inputs::Expression>(),
            Relations::inputs_File => ::std::any::TypeId::of::<::types::inputs::File>(),
            Relations::inputs_FileExport => ::std::any::TypeId::of::<::types::inputs::FileExport>(),
            Relations::inputs_For => ::std::any::TypeId::of::<::types::inputs::For>(),
            Relations::inputs_ForIn => ::std::any::TypeId::of::<::types::inputs::ForIn>(),
            Relations::inputs_ForOf => ::std::any::TypeId::of::<::types::inputs::ForOf>(),
            Relations::inputs_Function => ::std::any::TypeId::of::<::types::inputs::Function>(),
            Relations::inputs_FunctionArg => ::std::any::TypeId::of::<::types::inputs::FunctionArg>(),
            Relations::inputs_If => ::std::any::TypeId::of::<::types::inputs::If>(),
            Relations::inputs_ImplicitGlobal => ::std::any::TypeId::of::<::types::inputs::ImplicitGlobal>(),
            Relations::inputs_ImportDecl => ::std::any::TypeId::of::<::types::inputs::ImportDecl>(),
            Relations::inputs_InlineFunc => ::std::any::TypeId::of::<::types::inputs::InlineFunc>(),
            Relations::inputs_InlineFuncParam => ::std::any::TypeId::of::<::types::inputs::InlineFuncParam>(),
            Relations::inputs_InputScope => ::std::any::TypeId::of::<::types::inputs::InputScope>(),
            Relations::inputs_Label => ::std::any::TypeId::of::<::types::inputs::Label>(),
            Relations::inputs_LetDecl => ::std::any::TypeId::of::<::types::inputs::LetDecl>(),
            Relations::inputs_NameRef => ::std::any::TypeId::of::<::types::inputs::NameRef>(),
            Relations::inputs_New => ::std::any::TypeId::of::<::types::inputs::New>(),
            Relations::inputs_Property => ::std::any::TypeId::of::<::types::inputs::Property>(),
            Relations::inputs_Return => ::std::any::TypeId::of::<::types::inputs::Return>(),
            Relations::inputs_Statement => ::std::any::TypeId::of::<::types::inputs::Statement>(),
            Relations::inputs_Switch => ::std::any::TypeId::of::<::types::inputs::Switch>(),
            Relations::inputs_SwitchCase => ::std::any::TypeId::of::<::types::inputs::SwitchCase>(),
            Relations::inputs_Template => ::std::any::TypeId::of::<::types::inputs::Template>(),
            Relations::inputs_Ternary => ::std::any::TypeId::of::<::types::inputs::Ternary>(),
            Relations::inputs_Throw => ::std::any::TypeId::of::<::types::inputs::Throw>(),
            Relations::inputs_Try => ::std::any::TypeId::of::<::types::inputs::Try>(),
            Relations::inputs_UnaryOp => ::std::any::TypeId::of::<::types::inputs::UnaryOp>(),
            Relations::inputs_UserGlobal => ::std::any::TypeId::of::<::types::inputs::UserGlobal>(),
            Relations::inputs_VarDecl => ::std::any::TypeId::of::<::types::inputs::VarDecl>(),
            Relations::inputs_While => ::std::any::TypeId::of::<::types::inputs::While>(),
            Relations::inputs_With => ::std::any::TypeId::of::<::types::inputs::With>(),
            Relations::inputs_Yield => ::std::any::TypeId::of::<::types::inputs::Yield>(),
            Relations::is_exported_IsExported => ::std::any::TypeId::of::<::types::is_exported::IsExported>(),
            Relations::name_in_scope_NameInScope => ::std::any::TypeId::of::<::types::name_in_scope::NameInScope>(),
            Relations::name_in_scope_NameOccursInScope => ::std::any::TypeId::of::<::types::name_in_scope::NameOccursInScope>(),
            Relations::outputs_no_shadow_DeclarationVisibleWithin => ::std::any::TypeId::of::<::types::outputs::no_shadow::DeclarationVisibleWithin>(),
            Relations::outputs_no_shadow_NoShadow => ::std::any::TypeId::of::<::types::outputs::no_shadow::NoShadow>(),
            Relations::outputs_no_undef_ChainedWith => ::std::any::TypeId::of::<::types::outputs::no_undef::ChainedWith>(),
            Relations::outputs_no_undef_NoUndef => ::std::any::TypeId::of::<::types::outputs::no_undef::NoUndef>(),
            Relations::outputs_no_unused_labels_LabelUsage => ::std::any::TypeId::of::<::types::outputs::no_unused_labels::LabelUsage>(),
            Relations::outputs_no_unused_labels_NoUnusedLabels => ::std::any::TypeId::of::<::types::outputs::no_unused_labels::NoUnusedLabels>(),
            Relations::outputs_no_unused_labels_UsedLabels => ::std::any::TypeId::of::<::types::outputs::no_unused_labels::UsedLabels>(),
            Relations::outputs_typeof_undef_TypeofUndef => ::std::any::TypeId::of::<::types::outputs::typeof_undef::TypeofUndef>(),
            Relations::outputs_typeof_undef_WithinTypeofExpr => ::std::any::TypeId::of::<::types::outputs::typeof_undef::WithinTypeofExpr>(),
            Relations::outputs_unused_vars_UnusedVariables => ::std::any::TypeId::of::<::types::outputs::unused_vars::UnusedVariables>(),
            Relations::outputs_use_before_def_UseBeforeDef => ::std::any::TypeId::of::<::types::outputs::use_before_def::UseBeforeDef>(),
            Relations::scopes_FunctionLevelScope => ::std::any::TypeId::of::<::types::scopes::FunctionLevelScope>(),
            Relations::scopes_IsHoistable => ::std::any::TypeId::of::<::types::scopes::IsHoistable>(),
            Relations::scopes_NeedsScopeChildren => ::std::any::TypeId::of::<::types::scopes::NeedsScopeChildren>(),
            Relations::scopes_NeedsScopeParents => ::std::any::TypeId::of::<::types::scopes::NeedsScopeParents>(),
            Relations::scopes_ScopeFamily => ::std::any::TypeId::of::<::types::scopes::ScopeFamily>(),
            Relations::scopes_ScopeOfId => ::std::any::TypeId::of::<::types::scopes::ScopeOfId>(),
            Relations::var_decls_VariableDeclarations => ::std::any::TypeId::of::<::types::var_decls::VariableDeclarations>(),
            Relations::variable_decl_VariableDecl => ::std::any::TypeId::of::<::types::variable_decl::VariableDecl>(),
        }
    }
}
impl TryFrom<RelId> for Relations {
    type Error = ();
    fn try_from(rid: RelId) -> ::std::result::Result<Self, ()> {
         match rid {
        0 => Ok(Relations::__Prefix_0),
        1 => Ok(Relations::__Prefix_1),
        2 => Ok(Relations::__Prefix_2),
        3 => Ok(Relations::__Prefix_3),
        4 => Ok(Relations::__Prefix_4),
        5 => Ok(Relations::__Prefix_5),
        6 => Ok(Relations::__Prefix_6),
        7 => Ok(Relations::__Prefix_7),
        8 => Ok(Relations::__Prefix_8),
        9 => Ok(Relations::__Prefix_9),
        10 => Ok(Relations::inputs_Array),
        11 => Ok(Relations::inputs_Arrow),
        12 => Ok(Relations::inputs_ArrowParam),
        13 => Ok(Relations::inputs_Assign),
        14 => Ok(Relations::inputs_Await),
        15 => Ok(Relations::inputs_BinOp),
        16 => Ok(Relations::inputs_BracketAccess),
        17 => Ok(Relations::inputs_Break),
        18 => Ok(Relations::inputs_Call),
        19 => Ok(Relations::inputs_Class),
        20 => Ok(Relations::inputs_ClassExpr),
        21 => Ok(Relations::inputs_ConstDecl),
        22 => Ok(Relations::inputs_Continue),
        23 => Ok(Relations::inputs_DoWhile),
        24 => Ok(Relations::inputs_DotAccess),
        25 => Ok(Relations::inputs_EveryScope),
        26 => Ok(Relations::inputs_ExprBigInt),
        27 => Ok(Relations::inputs_ExprBool),
        28 => Ok(Relations::inputs_ExprNumber),
        29 => Ok(Relations::inputs_ExprString),
        30 => Ok(Relations::inputs_Expression),
        31 => Ok(Relations::inputs_File),
        32 => Ok(Relations::inputs_FileExport),
        33 => Ok(Relations::inputs_For),
        34 => Ok(Relations::inputs_ForIn),
        35 => Ok(Relations::inputs_ForOf),
        36 => Ok(Relations::inputs_Function),
        37 => Ok(Relations::inputs_FunctionArg),
        38 => Ok(Relations::inputs_If),
        39 => Ok(Relations::inputs_ImplicitGlobal),
        40 => Ok(Relations::inputs_ImportDecl),
        41 => Ok(Relations::inputs_InlineFunc),
        42 => Ok(Relations::inputs_InlineFuncParam),
        43 => Ok(Relations::inputs_InputScope),
        44 => Ok(Relations::inputs_Label),
        45 => Ok(Relations::inputs_LetDecl),
        46 => Ok(Relations::inputs_NameRef),
        47 => Ok(Relations::inputs_New),
        48 => Ok(Relations::inputs_Property),
        49 => Ok(Relations::inputs_Return),
        50 => Ok(Relations::inputs_Statement),
        51 => Ok(Relations::inputs_Switch),
        52 => Ok(Relations::inputs_SwitchCase),
        53 => Ok(Relations::inputs_Template),
        54 => Ok(Relations::inputs_Ternary),
        55 => Ok(Relations::inputs_Throw),
        56 => Ok(Relations::inputs_Try),
        57 => Ok(Relations::inputs_UnaryOp),
        58 => Ok(Relations::inputs_UserGlobal),
        59 => Ok(Relations::inputs_VarDecl),
        60 => Ok(Relations::inputs_While),
        61 => Ok(Relations::inputs_With),
        62 => Ok(Relations::inputs_Yield),
        63 => Ok(Relations::is_exported_IsExported),
        64 => Ok(Relations::name_in_scope_NameInScope),
        65 => Ok(Relations::name_in_scope_NameOccursInScope),
        66 => Ok(Relations::outputs_no_shadow_DeclarationVisibleWithin),
        67 => Ok(Relations::outputs_no_shadow_NoShadow),
        68 => Ok(Relations::outputs_no_undef_ChainedWith),
        69 => Ok(Relations::outputs_no_undef_NoUndef),
        70 => Ok(Relations::outputs_no_unused_labels_LabelUsage),
        71 => Ok(Relations::outputs_no_unused_labels_NoUnusedLabels),
        72 => Ok(Relations::outputs_no_unused_labels_UsedLabels),
        73 => Ok(Relations::outputs_typeof_undef_TypeofUndef),
        74 => Ok(Relations::outputs_typeof_undef_WithinTypeofExpr),
        75 => Ok(Relations::outputs_unused_vars_UnusedVariables),
        76 => Ok(Relations::outputs_use_before_def_UseBeforeDef),
        77 => Ok(Relations::scopes_FunctionLevelScope),
        78 => Ok(Relations::scopes_IsHoistable),
        79 => Ok(Relations::scopes_NeedsScopeChildren),
        80 => Ok(Relations::scopes_NeedsScopeParents),
        81 => Ok(Relations::scopes_ScopeFamily),
        82 => Ok(Relations::scopes_ScopeOfId),
        83 => Ok(Relations::var_decls_VariableDeclarations),
        84 => Ok(Relations::variable_decl_VariableDecl),
             _  => Err(())
         }
    }
}
pub fn relid2name(rid: RelId) -> Option<&'static str> {
   match rid {
        0 => Some(&"__Prefix_0"),
        1 => Some(&"__Prefix_1"),
        2 => Some(&"__Prefix_2"),
        3 => Some(&"__Prefix_3"),
        4 => Some(&"__Prefix_4"),
        5 => Some(&"__Prefix_5"),
        6 => Some(&"__Prefix_6"),
        7 => Some(&"__Prefix_7"),
        8 => Some(&"__Prefix_8"),
        9 => Some(&"__Prefix_9"),
        10 => Some(&"inputs::Array"),
        11 => Some(&"inputs::Arrow"),
        12 => Some(&"inputs::ArrowParam"),
        13 => Some(&"inputs::Assign"),
        14 => Some(&"inputs::Await"),
        15 => Some(&"inputs::BinOp"),
        16 => Some(&"inputs::BracketAccess"),
        17 => Some(&"inputs::Break"),
        18 => Some(&"inputs::Call"),
        19 => Some(&"inputs::Class"),
        20 => Some(&"inputs::ClassExpr"),
        21 => Some(&"inputs::ConstDecl"),
        22 => Some(&"inputs::Continue"),
        23 => Some(&"inputs::DoWhile"),
        24 => Some(&"inputs::DotAccess"),
        25 => Some(&"inputs::EveryScope"),
        26 => Some(&"inputs::ExprBigInt"),
        27 => Some(&"inputs::ExprBool"),
        28 => Some(&"inputs::ExprNumber"),
        29 => Some(&"inputs::ExprString"),
        30 => Some(&"inputs::Expression"),
        31 => Some(&"inputs::File"),
        32 => Some(&"inputs::FileExport"),
        33 => Some(&"inputs::For"),
        34 => Some(&"inputs::ForIn"),
        35 => Some(&"inputs::ForOf"),
        36 => Some(&"inputs::Function"),
        37 => Some(&"inputs::FunctionArg"),
        38 => Some(&"inputs::If"),
        39 => Some(&"inputs::ImplicitGlobal"),
        40 => Some(&"inputs::ImportDecl"),
        41 => Some(&"inputs::InlineFunc"),
        42 => Some(&"inputs::InlineFuncParam"),
        43 => Some(&"inputs::InputScope"),
        44 => Some(&"inputs::Label"),
        45 => Some(&"inputs::LetDecl"),
        46 => Some(&"inputs::NameRef"),
        47 => Some(&"inputs::New"),
        48 => Some(&"inputs::Property"),
        49 => Some(&"inputs::Return"),
        50 => Some(&"inputs::Statement"),
        51 => Some(&"inputs::Switch"),
        52 => Some(&"inputs::SwitchCase"),
        53 => Some(&"inputs::Template"),
        54 => Some(&"inputs::Ternary"),
        55 => Some(&"inputs::Throw"),
        56 => Some(&"inputs::Try"),
        57 => Some(&"inputs::UnaryOp"),
        58 => Some(&"inputs::UserGlobal"),
        59 => Some(&"inputs::VarDecl"),
        60 => Some(&"inputs::While"),
        61 => Some(&"inputs::With"),
        62 => Some(&"inputs::Yield"),
        63 => Some(&"is_exported::IsExported"),
        64 => Some(&"name_in_scope::NameInScope"),
        65 => Some(&"name_in_scope::NameOccursInScope"),
        66 => Some(&"outputs::no_shadow::DeclarationVisibleWithin"),
        67 => Some(&"outputs::no_shadow::NoShadow"),
        68 => Some(&"outputs::no_undef::ChainedWith"),
        69 => Some(&"outputs::no_undef::NoUndef"),
        70 => Some(&"outputs::no_unused_labels::LabelUsage"),
        71 => Some(&"outputs::no_unused_labels::NoUnusedLabels"),
        72 => Some(&"outputs::no_unused_labels::UsedLabels"),
        73 => Some(&"outputs::typeof_undef::TypeofUndef"),
        74 => Some(&"outputs::typeof_undef::WithinTypeofExpr"),
        75 => Some(&"outputs::unused_vars::UnusedVariables"),
        76 => Some(&"outputs::use_before_def::UseBeforeDef"),
        77 => Some(&"scopes::FunctionLevelScope"),
        78 => Some(&"scopes::IsHoistable"),
        79 => Some(&"scopes::NeedsScopeChildren"),
        80 => Some(&"scopes::NeedsScopeParents"),
        81 => Some(&"scopes::ScopeFamily"),
        82 => Some(&"scopes::ScopeOfId"),
        83 => Some(&"var_decls::VariableDeclarations"),
        84 => Some(&"variable_decl::VariableDecl"),
       _  => None
   }
}
#[cfg(feature = "c_api")]
pub fn relid2cname(rid: RelId) -> Option<&'static ::std::ffi::CStr> {
    RELIDMAPC.get(&rid).copied()
}   /// A map of `RelId`s to their name as an `&'static str`
pub static RELIDMAP: ::once_cell::sync::Lazy<::fnv::FnvHashMap<Relations, &'static str>> =
    ::once_cell::sync::Lazy::new(|| {
        let mut map = ::fnv::FnvHashMap::with_capacity_and_hasher(85, ::fnv::FnvBuildHasher::default());
        map.insert(Relations::__Prefix_0, "__Prefix_0");
        map.insert(Relations::__Prefix_1, "__Prefix_1");
        map.insert(Relations::__Prefix_2, "__Prefix_2");
        map.insert(Relations::__Prefix_3, "__Prefix_3");
        map.insert(Relations::__Prefix_4, "__Prefix_4");
        map.insert(Relations::__Prefix_5, "__Prefix_5");
        map.insert(Relations::__Prefix_6, "__Prefix_6");
        map.insert(Relations::__Prefix_7, "__Prefix_7");
        map.insert(Relations::__Prefix_8, "__Prefix_8");
        map.insert(Relations::__Prefix_9, "__Prefix_9");
        map.insert(Relations::inputs_Array, "inputs::Array");
        map.insert(Relations::inputs_Arrow, "inputs::Arrow");
        map.insert(Relations::inputs_ArrowParam, "inputs::ArrowParam");
        map.insert(Relations::inputs_Assign, "inputs::Assign");
        map.insert(Relations::inputs_Await, "inputs::Await");
        map.insert(Relations::inputs_BinOp, "inputs::BinOp");
        map.insert(Relations::inputs_BracketAccess, "inputs::BracketAccess");
        map.insert(Relations::inputs_Break, "inputs::Break");
        map.insert(Relations::inputs_Call, "inputs::Call");
        map.insert(Relations::inputs_Class, "inputs::Class");
        map.insert(Relations::inputs_ClassExpr, "inputs::ClassExpr");
        map.insert(Relations::inputs_ConstDecl, "inputs::ConstDecl");
        map.insert(Relations::inputs_Continue, "inputs::Continue");
        map.insert(Relations::inputs_DoWhile, "inputs::DoWhile");
        map.insert(Relations::inputs_DotAccess, "inputs::DotAccess");
        map.insert(Relations::inputs_EveryScope, "inputs::EveryScope");
        map.insert(Relations::inputs_ExprBigInt, "inputs::ExprBigInt");
        map.insert(Relations::inputs_ExprBool, "inputs::ExprBool");
        map.insert(Relations::inputs_ExprNumber, "inputs::ExprNumber");
        map.insert(Relations::inputs_ExprString, "inputs::ExprString");
        map.insert(Relations::inputs_Expression, "inputs::Expression");
        map.insert(Relations::inputs_File, "inputs::File");
        map.insert(Relations::inputs_FileExport, "inputs::FileExport");
        map.insert(Relations::inputs_For, "inputs::For");
        map.insert(Relations::inputs_ForIn, "inputs::ForIn");
        map.insert(Relations::inputs_ForOf, "inputs::ForOf");
        map.insert(Relations::inputs_Function, "inputs::Function");
        map.insert(Relations::inputs_FunctionArg, "inputs::FunctionArg");
        map.insert(Relations::inputs_If, "inputs::If");
        map.insert(Relations::inputs_ImplicitGlobal, "inputs::ImplicitGlobal");
        map.insert(Relations::inputs_ImportDecl, "inputs::ImportDecl");
        map.insert(Relations::inputs_InlineFunc, "inputs::InlineFunc");
        map.insert(Relations::inputs_InlineFuncParam, "inputs::InlineFuncParam");
        map.insert(Relations::inputs_InputScope, "inputs::InputScope");
        map.insert(Relations::inputs_Label, "inputs::Label");
        map.insert(Relations::inputs_LetDecl, "inputs::LetDecl");
        map.insert(Relations::inputs_NameRef, "inputs::NameRef");
        map.insert(Relations::inputs_New, "inputs::New");
        map.insert(Relations::inputs_Property, "inputs::Property");
        map.insert(Relations::inputs_Return, "inputs::Return");
        map.insert(Relations::inputs_Statement, "inputs::Statement");
        map.insert(Relations::inputs_Switch, "inputs::Switch");
        map.insert(Relations::inputs_SwitchCase, "inputs::SwitchCase");
        map.insert(Relations::inputs_Template, "inputs::Template");
        map.insert(Relations::inputs_Ternary, "inputs::Ternary");
        map.insert(Relations::inputs_Throw, "inputs::Throw");
        map.insert(Relations::inputs_Try, "inputs::Try");
        map.insert(Relations::inputs_UnaryOp, "inputs::UnaryOp");
        map.insert(Relations::inputs_UserGlobal, "inputs::UserGlobal");
        map.insert(Relations::inputs_VarDecl, "inputs::VarDecl");
        map.insert(Relations::inputs_While, "inputs::While");
        map.insert(Relations::inputs_With, "inputs::With");
        map.insert(Relations::inputs_Yield, "inputs::Yield");
        map.insert(Relations::is_exported_IsExported, "is_exported::IsExported");
        map.insert(Relations::name_in_scope_NameInScope, "name_in_scope::NameInScope");
        map.insert(Relations::name_in_scope_NameOccursInScope, "name_in_scope::NameOccursInScope");
        map.insert(Relations::outputs_no_shadow_DeclarationVisibleWithin, "outputs::no_shadow::DeclarationVisibleWithin");
        map.insert(Relations::outputs_no_shadow_NoShadow, "outputs::no_shadow::NoShadow");
        map.insert(Relations::outputs_no_undef_ChainedWith, "outputs::no_undef::ChainedWith");
        map.insert(Relations::outputs_no_undef_NoUndef, "outputs::no_undef::NoUndef");
        map.insert(Relations::outputs_no_unused_labels_LabelUsage, "outputs::no_unused_labels::LabelUsage");
        map.insert(Relations::outputs_no_unused_labels_NoUnusedLabels, "outputs::no_unused_labels::NoUnusedLabels");
        map.insert(Relations::outputs_no_unused_labels_UsedLabels, "outputs::no_unused_labels::UsedLabels");
        map.insert(Relations::outputs_typeof_undef_TypeofUndef, "outputs::typeof_undef::TypeofUndef");
        map.insert(Relations::outputs_typeof_undef_WithinTypeofExpr, "outputs::typeof_undef::WithinTypeofExpr");
        map.insert(Relations::outputs_unused_vars_UnusedVariables, "outputs::unused_vars::UnusedVariables");
        map.insert(Relations::outputs_use_before_def_UseBeforeDef, "outputs::use_before_def::UseBeforeDef");
        map.insert(Relations::scopes_FunctionLevelScope, "scopes::FunctionLevelScope");
        map.insert(Relations::scopes_IsHoistable, "scopes::IsHoistable");
        map.insert(Relations::scopes_NeedsScopeChildren, "scopes::NeedsScopeChildren");
        map.insert(Relations::scopes_NeedsScopeParents, "scopes::NeedsScopeParents");
        map.insert(Relations::scopes_ScopeFamily, "scopes::ScopeFamily");
        map.insert(Relations::scopes_ScopeOfId, "scopes::ScopeOfId");
        map.insert(Relations::var_decls_VariableDeclarations, "var_decls::VariableDeclarations");
        map.insert(Relations::variable_decl_VariableDecl, "variable_decl::VariableDecl");
        map
    });
    /// A map of `RelId`s to their name as an `&'static CStr`
#[cfg(feature = "c_api")]
pub static RELIDMAPC: ::once_cell::sync::Lazy<::fnv::FnvHashMap<RelId, &'static ::std::ffi::CStr>> =
    ::once_cell::sync::Lazy::new(|| {
        let mut map = ::fnv::FnvHashMap::with_capacity_and_hasher(85, ::fnv::FnvBuildHasher::default());
        map.insert(0, ::std::ffi::CStr::from_bytes_with_nul(b"__Prefix_0\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(1, ::std::ffi::CStr::from_bytes_with_nul(b"__Prefix_1\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(2, ::std::ffi::CStr::from_bytes_with_nul(b"__Prefix_2\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(3, ::std::ffi::CStr::from_bytes_with_nul(b"__Prefix_3\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(4, ::std::ffi::CStr::from_bytes_with_nul(b"__Prefix_4\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(5, ::std::ffi::CStr::from_bytes_with_nul(b"__Prefix_5\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(6, ::std::ffi::CStr::from_bytes_with_nul(b"__Prefix_6\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(7, ::std::ffi::CStr::from_bytes_with_nul(b"__Prefix_7\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(8, ::std::ffi::CStr::from_bytes_with_nul(b"__Prefix_8\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(9, ::std::ffi::CStr::from_bytes_with_nul(b"__Prefix_9\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(10, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::Array\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(11, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::Arrow\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(12, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::ArrowParam\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(13, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::Assign\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(14, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::Await\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(15, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::BinOp\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(16, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::BracketAccess\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(17, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::Break\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(18, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::Call\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(19, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::Class\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(20, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::ClassExpr\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(21, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::ConstDecl\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(22, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::Continue\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(23, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::DoWhile\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(24, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::DotAccess\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(25, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::EveryScope\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(26, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::ExprBigInt\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(27, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::ExprBool\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(28, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::ExprNumber\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(29, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::ExprString\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(30, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::Expression\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(31, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::File\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(32, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::FileExport\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(33, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::For\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(34, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::ForIn\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(35, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::ForOf\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(36, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::Function\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(37, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::FunctionArg\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(38, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::If\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(39, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::ImplicitGlobal\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(40, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::ImportDecl\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(41, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::InlineFunc\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(42, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::InlineFuncParam\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(43, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::InputScope\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(44, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::Label\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(45, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::LetDecl\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(46, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::NameRef\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(47, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::New\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(48, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::Property\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(49, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::Return\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(50, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::Statement\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(51, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::Switch\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(52, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::SwitchCase\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(53, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::Template\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(54, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::Ternary\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(55, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::Throw\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(56, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::Try\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(57, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::UnaryOp\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(58, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::UserGlobal\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(59, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::VarDecl\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(60, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::While\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(61, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::With\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(62, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::Yield\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(63, ::std::ffi::CStr::from_bytes_with_nul(b"is_exported::IsExported\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(64, ::std::ffi::CStr::from_bytes_with_nul(b"name_in_scope::NameInScope\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(65, ::std::ffi::CStr::from_bytes_with_nul(b"name_in_scope::NameOccursInScope\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(66, ::std::ffi::CStr::from_bytes_with_nul(b"outputs::no_shadow::DeclarationVisibleWithin\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(67, ::std::ffi::CStr::from_bytes_with_nul(b"outputs::no_shadow::NoShadow\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(68, ::std::ffi::CStr::from_bytes_with_nul(b"outputs::no_undef::ChainedWith\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(69, ::std::ffi::CStr::from_bytes_with_nul(b"outputs::no_undef::NoUndef\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(70, ::std::ffi::CStr::from_bytes_with_nul(b"outputs::no_unused_labels::LabelUsage\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(71, ::std::ffi::CStr::from_bytes_with_nul(b"outputs::no_unused_labels::NoUnusedLabels\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(72, ::std::ffi::CStr::from_bytes_with_nul(b"outputs::no_unused_labels::UsedLabels\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(73, ::std::ffi::CStr::from_bytes_with_nul(b"outputs::typeof_undef::TypeofUndef\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(74, ::std::ffi::CStr::from_bytes_with_nul(b"outputs::typeof_undef::WithinTypeofExpr\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(75, ::std::ffi::CStr::from_bytes_with_nul(b"outputs::unused_vars::UnusedVariables\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(76, ::std::ffi::CStr::from_bytes_with_nul(b"outputs::use_before_def::UseBeforeDef\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(77, ::std::ffi::CStr::from_bytes_with_nul(b"scopes::FunctionLevelScope\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(78, ::std::ffi::CStr::from_bytes_with_nul(b"scopes::IsHoistable\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(79, ::std::ffi::CStr::from_bytes_with_nul(b"scopes::NeedsScopeChildren\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(80, ::std::ffi::CStr::from_bytes_with_nul(b"scopes::NeedsScopeParents\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(81, ::std::ffi::CStr::from_bytes_with_nul(b"scopes::ScopeFamily\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(82, ::std::ffi::CStr::from_bytes_with_nul(b"scopes::ScopeOfId\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(83, ::std::ffi::CStr::from_bytes_with_nul(b"var_decls::VariableDeclarations\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(84, ::std::ffi::CStr::from_bytes_with_nul(b"variable_decl::VariableDecl\0").expect("Unreachable: A null byte was specifically inserted"));
        map
    });
    /// A map of input `Relations`s to their name as an `&'static str`
pub static INPUT_RELIDMAP: ::once_cell::sync::Lazy<::fnv::FnvHashMap<Relations, &'static str>> =
    ::once_cell::sync::Lazy::new(|| {
        let mut map = ::fnv::FnvHashMap::with_capacity_and_hasher(53, ::fnv::FnvBuildHasher::default());
        map.insert(Relations::inputs_Array, "inputs::Array");
        map.insert(Relations::inputs_Arrow, "inputs::Arrow");
        map.insert(Relations::inputs_ArrowParam, "inputs::ArrowParam");
        map.insert(Relations::inputs_Assign, "inputs::Assign");
        map.insert(Relations::inputs_Await, "inputs::Await");
        map.insert(Relations::inputs_BinOp, "inputs::BinOp");
        map.insert(Relations::inputs_BracketAccess, "inputs::BracketAccess");
        map.insert(Relations::inputs_Break, "inputs::Break");
        map.insert(Relations::inputs_Call, "inputs::Call");
        map.insert(Relations::inputs_Class, "inputs::Class");
        map.insert(Relations::inputs_ClassExpr, "inputs::ClassExpr");
        map.insert(Relations::inputs_ConstDecl, "inputs::ConstDecl");
        map.insert(Relations::inputs_Continue, "inputs::Continue");
        map.insert(Relations::inputs_DoWhile, "inputs::DoWhile");
        map.insert(Relations::inputs_DotAccess, "inputs::DotAccess");
        map.insert(Relations::inputs_EveryScope, "inputs::EveryScope");
        map.insert(Relations::inputs_ExprBigInt, "inputs::ExprBigInt");
        map.insert(Relations::inputs_ExprBool, "inputs::ExprBool");
        map.insert(Relations::inputs_ExprNumber, "inputs::ExprNumber");
        map.insert(Relations::inputs_ExprString, "inputs::ExprString");
        map.insert(Relations::inputs_Expression, "inputs::Expression");
        map.insert(Relations::inputs_File, "inputs::File");
        map.insert(Relations::inputs_FileExport, "inputs::FileExport");
        map.insert(Relations::inputs_For, "inputs::For");
        map.insert(Relations::inputs_ForIn, "inputs::ForIn");
        map.insert(Relations::inputs_ForOf, "inputs::ForOf");
        map.insert(Relations::inputs_Function, "inputs::Function");
        map.insert(Relations::inputs_FunctionArg, "inputs::FunctionArg");
        map.insert(Relations::inputs_If, "inputs::If");
        map.insert(Relations::inputs_ImplicitGlobal, "inputs::ImplicitGlobal");
        map.insert(Relations::inputs_ImportDecl, "inputs::ImportDecl");
        map.insert(Relations::inputs_InlineFunc, "inputs::InlineFunc");
        map.insert(Relations::inputs_InlineFuncParam, "inputs::InlineFuncParam");
        map.insert(Relations::inputs_InputScope, "inputs::InputScope");
        map.insert(Relations::inputs_Label, "inputs::Label");
        map.insert(Relations::inputs_LetDecl, "inputs::LetDecl");
        map.insert(Relations::inputs_NameRef, "inputs::NameRef");
        map.insert(Relations::inputs_New, "inputs::New");
        map.insert(Relations::inputs_Property, "inputs::Property");
        map.insert(Relations::inputs_Return, "inputs::Return");
        map.insert(Relations::inputs_Statement, "inputs::Statement");
        map.insert(Relations::inputs_Switch, "inputs::Switch");
        map.insert(Relations::inputs_SwitchCase, "inputs::SwitchCase");
        map.insert(Relations::inputs_Template, "inputs::Template");
        map.insert(Relations::inputs_Ternary, "inputs::Ternary");
        map.insert(Relations::inputs_Throw, "inputs::Throw");
        map.insert(Relations::inputs_Try, "inputs::Try");
        map.insert(Relations::inputs_UnaryOp, "inputs::UnaryOp");
        map.insert(Relations::inputs_UserGlobal, "inputs::UserGlobal");
        map.insert(Relations::inputs_VarDecl, "inputs::VarDecl");
        map.insert(Relations::inputs_While, "inputs::While");
        map.insert(Relations::inputs_With, "inputs::With");
        map.insert(Relations::inputs_Yield, "inputs::Yield");
        map
    });
    /// A map of output `Relations`s to their name as an `&'static str`
pub static OUTPUT_RELIDMAP: ::once_cell::sync::Lazy<::fnv::FnvHashMap<Relations, &'static str>> =
    ::once_cell::sync::Lazy::new(|| {
        let mut map = ::fnv::FnvHashMap::with_capacity_and_hasher(7, ::fnv::FnvBuildHasher::default());
        map.insert(Relations::outputs_no_shadow_NoShadow, "outputs::no_shadow::NoShadow");
        map.insert(Relations::outputs_no_undef_NoUndef, "outputs::no_undef::NoUndef");
        map.insert(Relations::outputs_no_unused_labels_NoUnusedLabels, "outputs::no_unused_labels::NoUnusedLabels");
        map.insert(Relations::outputs_no_unused_labels_UsedLabels, "outputs::no_unused_labels::UsedLabels");
        map.insert(Relations::outputs_typeof_undef_TypeofUndef, "outputs::typeof_undef::TypeofUndef");
        map.insert(Relations::outputs_unused_vars_UnusedVariables, "outputs::unused_vars::UnusedVariables");
        map.insert(Relations::outputs_use_before_def_UseBeforeDef, "outputs::use_before_def::UseBeforeDef");
        map
    });
impl TryFrom<&str> for Indexes {
    type Error = ();
    fn try_from(iname: &str) -> ::std::result::Result<Self, ()> {
         match iname {
        "inputs::EveryScopeByFile" => Ok(Indexes::inputs_EveryScopeByFile),
        "inputs::ExpressionByFile" => Ok(Indexes::inputs_ExpressionByFile),
        "inputs::ExpressionById" => Ok(Indexes::inputs_ExpressionById),
        "inputs::ExpressionBySpan" => Ok(Indexes::inputs_ExpressionBySpan),
        "inputs::FileById" => Ok(Indexes::inputs_FileById),
        "inputs::InputScopeByChild" => Ok(Indexes::inputs_InputScopeByChild),
        "inputs::InputScopeByFile" => Ok(Indexes::inputs_InputScopeByFile),
        "inputs::InputScopeByParent" => Ok(Indexes::inputs_InputScopeByParent),
        "inputs::StatementByFile" => Ok(Indexes::inputs_StatementByFile),
        "inputs::StatementById" => Ok(Indexes::inputs_StatementById),
        "inputs::StatementBySpan" => Ok(Indexes::inputs_StatementBySpan),
        "name_in_scope::Index_VariableInScope" => Ok(Indexes::name_in_scope_Index_VariableInScope),
        "name_in_scope::Index_VariablesForScope" => Ok(Indexes::name_in_scope_Index_VariablesForScope),
        "scopes::ScopeFamilyByParent" => Ok(Indexes::scopes_ScopeFamilyByParent),
             _  => Err(())
         }
    }
}
impl TryFrom<IdxId> for Indexes {
    type Error = ();
    fn try_from(iid: IdxId) -> ::core::result::Result<Self, ()> {
         match iid {
        0 => Ok(Indexes::inputs_EveryScopeByFile),
        1 => Ok(Indexes::inputs_ExpressionByFile),
        2 => Ok(Indexes::inputs_ExpressionById),
        3 => Ok(Indexes::inputs_ExpressionBySpan),
        4 => Ok(Indexes::inputs_FileById),
        5 => Ok(Indexes::inputs_InputScopeByChild),
        6 => Ok(Indexes::inputs_InputScopeByFile),
        7 => Ok(Indexes::inputs_InputScopeByParent),
        8 => Ok(Indexes::inputs_StatementByFile),
        9 => Ok(Indexes::inputs_StatementById),
        10 => Ok(Indexes::inputs_StatementBySpan),
        11 => Ok(Indexes::name_in_scope_Index_VariableInScope),
        12 => Ok(Indexes::name_in_scope_Index_VariablesForScope),
        13 => Ok(Indexes::scopes_ScopeFamilyByParent),
             _  => Err(())
         }
    }
}
pub fn indexid2name(iid: IdxId) -> Option<&'static str> {
   match iid {
        0 => Some(&"inputs::EveryScopeByFile"),
        1 => Some(&"inputs::ExpressionByFile"),
        2 => Some(&"inputs::ExpressionById"),
        3 => Some(&"inputs::ExpressionBySpan"),
        4 => Some(&"inputs::FileById"),
        5 => Some(&"inputs::InputScopeByChild"),
        6 => Some(&"inputs::InputScopeByFile"),
        7 => Some(&"inputs::InputScopeByParent"),
        8 => Some(&"inputs::StatementByFile"),
        9 => Some(&"inputs::StatementById"),
        10 => Some(&"inputs::StatementBySpan"),
        11 => Some(&"name_in_scope::Index_VariableInScope"),
        12 => Some(&"name_in_scope::Index_VariablesForScope"),
        13 => Some(&"scopes::ScopeFamilyByParent"),
       _  => None
   }
}
#[cfg(feature = "c_api")]
pub fn indexid2cname(iid: IdxId) -> Option<&'static ::std::ffi::CStr> {
    IDXIDMAPC.get(&iid).copied()
}   /// A map of `Indexes` to their name as an `&'static str`
pub static IDXIDMAP: ::once_cell::sync::Lazy<::fnv::FnvHashMap<Indexes, &'static str>> =
    ::once_cell::sync::Lazy::new(|| {
        let mut map = ::fnv::FnvHashMap::with_capacity_and_hasher(14, ::fnv::FnvBuildHasher::default());
        map.insert(Indexes::inputs_EveryScopeByFile, "inputs::EveryScopeByFile");
        map.insert(Indexes::inputs_ExpressionByFile, "inputs::ExpressionByFile");
        map.insert(Indexes::inputs_ExpressionById, "inputs::ExpressionById");
        map.insert(Indexes::inputs_ExpressionBySpan, "inputs::ExpressionBySpan");
        map.insert(Indexes::inputs_FileById, "inputs::FileById");
        map.insert(Indexes::inputs_InputScopeByChild, "inputs::InputScopeByChild");
        map.insert(Indexes::inputs_InputScopeByFile, "inputs::InputScopeByFile");
        map.insert(Indexes::inputs_InputScopeByParent, "inputs::InputScopeByParent");
        map.insert(Indexes::inputs_StatementByFile, "inputs::StatementByFile");
        map.insert(Indexes::inputs_StatementById, "inputs::StatementById");
        map.insert(Indexes::inputs_StatementBySpan, "inputs::StatementBySpan");
        map.insert(Indexes::name_in_scope_Index_VariableInScope, "name_in_scope::Index_VariableInScope");
        map.insert(Indexes::name_in_scope_Index_VariablesForScope, "name_in_scope::Index_VariablesForScope");
        map.insert(Indexes::scopes_ScopeFamilyByParent, "scopes::ScopeFamilyByParent");
        map
    });
    /// A map of `IdxId`s to their name as an `&'static CStr`
#[cfg(feature = "c_api")]
pub static IDXIDMAPC: ::once_cell::sync::Lazy<::fnv::FnvHashMap<IdxId, &'static ::std::ffi::CStr>> =
    ::once_cell::sync::Lazy::new(|| {
        let mut map = ::fnv::FnvHashMap::with_capacity_and_hasher(14, ::fnv::FnvBuildHasher::default());
        map.insert(0, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::EveryScopeByFile\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(1, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::ExpressionByFile\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(2, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::ExpressionById\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(3, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::ExpressionBySpan\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(4, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::FileById\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(5, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::InputScopeByChild\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(6, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::InputScopeByFile\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(7, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::InputScopeByParent\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(8, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::StatementByFile\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(9, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::StatementById\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(10, ::std::ffi::CStr::from_bytes_with_nul(b"inputs::StatementBySpan\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(11, ::std::ffi::CStr::from_bytes_with_nul(b"name_in_scope::Index_VariableInScope\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(12, ::std::ffi::CStr::from_bytes_with_nul(b"name_in_scope::Index_VariablesForScope\0").expect("Unreachable: A null byte was specifically inserted"));
        map.insert(13, ::std::ffi::CStr::from_bytes_with_nul(b"scopes::ScopeFamilyByParent\0").expect("Unreachable: A null byte was specifically inserted"));
        map
    });
pub fn relval_from_record(rel: Relations, _rec: &differential_datalog::record::Record) -> ::std::result::Result<DDValue, String> {
    match rel {
        Relations::__Prefix_0 => {
            Ok(<::types::ddlog_std::tuple7<::types::ast::FileId, ::types::config::Config, ::types::ast::ExprId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span, ::types::internment::Intern<String>>>::from_record(_rec)?.into_ddvalue())
        },
        Relations::__Prefix_1 => {
            Ok(<::types::ddlog_std::tuple6<::types::ast::FileId, ::types::config::Config, ::types::ast::ExprId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span>>::from_record(_rec)?.into_ddvalue())
        },
        Relations::__Prefix_2 => {
            Ok(<::types::ddlog_std::tuple5<::types::ast::FileId, ::types::config::Config, ::types::ast::StmtId, ::types::ast::Spanned<::types::internment::Intern<String>>, ::types::ast::ScopeId>>::from_record(_rec)?.into_ddvalue())
        },
        Relations::__Prefix_3 => {
            Ok(<::types::ddlog_std::tuple4<::types::ast::FileId, ::types::config::Config, ::types::ast::ExprId, ::types::ast::ExprId>>::from_record(_rec)?.into_ddvalue())
        },
        Relations::__Prefix_4 => {
            Ok(<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_record(_rec)?.into_ddvalue())
        },
        Relations::__Prefix_5 => {
            Ok(<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_record(_rec)?.into_ddvalue())
        },
        Relations::__Prefix_6 => {
            Ok(<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_record(_rec)?.into_ddvalue())
        },
        Relations::__Prefix_7 => {
            Ok(<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_record(_rec)?.into_ddvalue())
        },
        Relations::__Prefix_8 => {
            Ok(<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_record(_rec)?.into_ddvalue())
        },
        Relations::__Prefix_9 => {
            Ok(<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_Array => {
            Ok(<::types::inputs::Array>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_Arrow => {
            Ok(<::types::inputs::Arrow>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_ArrowParam => {
            Ok(<::types::inputs::ArrowParam>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_Assign => {
            Ok(<::types::inputs::Assign>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_Await => {
            Ok(<::types::inputs::Await>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_BinOp => {
            Ok(<::types::inputs::BinOp>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_BracketAccess => {
            Ok(<::types::inputs::BracketAccess>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_Break => {
            Ok(<::types::inputs::Break>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_Call => {
            Ok(<::types::inputs::Call>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_Class => {
            Ok(<::types::inputs::Class>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_ClassExpr => {
            Ok(<::types::inputs::ClassExpr>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_ConstDecl => {
            Ok(<::types::inputs::ConstDecl>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_Continue => {
            Ok(<::types::inputs::Continue>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_DoWhile => {
            Ok(<::types::inputs::DoWhile>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_DotAccess => {
            Ok(<::types::inputs::DotAccess>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_EveryScope => {
            Ok(<::types::inputs::EveryScope>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_ExprBigInt => {
            Ok(<::types::inputs::ExprBigInt>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_ExprBool => {
            Ok(<::types::inputs::ExprBool>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_ExprNumber => {
            Ok(<::types::inputs::ExprNumber>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_ExprString => {
            Ok(<::types::inputs::ExprString>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_Expression => {
            Ok(<::types::inputs::Expression>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_File => {
            Ok(<::types::inputs::File>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_FileExport => {
            Ok(<::types::inputs::FileExport>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_For => {
            Ok(<::types::inputs::For>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_ForIn => {
            Ok(<::types::inputs::ForIn>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_ForOf => {
            Ok(<::types::inputs::ForOf>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_Function => {
            Ok(<::types::inputs::Function>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_FunctionArg => {
            Ok(<::types::inputs::FunctionArg>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_If => {
            Ok(<::types::inputs::If>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_ImplicitGlobal => {
            Ok(<::types::inputs::ImplicitGlobal>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_ImportDecl => {
            Ok(<::types::inputs::ImportDecl>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_InlineFunc => {
            Ok(<::types::inputs::InlineFunc>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_InlineFuncParam => {
            Ok(<::types::inputs::InlineFuncParam>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_InputScope => {
            Ok(<::types::inputs::InputScope>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_Label => {
            Ok(<::types::inputs::Label>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_LetDecl => {
            Ok(<::types::inputs::LetDecl>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_NameRef => {
            Ok(<::types::inputs::NameRef>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_New => {
            Ok(<::types::inputs::New>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_Property => {
            Ok(<::types::inputs::Property>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_Return => {
            Ok(<::types::inputs::Return>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_Statement => {
            Ok(<::types::inputs::Statement>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_Switch => {
            Ok(<::types::inputs::Switch>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_SwitchCase => {
            Ok(<::types::inputs::SwitchCase>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_Template => {
            Ok(<::types::inputs::Template>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_Ternary => {
            Ok(<::types::inputs::Ternary>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_Throw => {
            Ok(<::types::inputs::Throw>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_Try => {
            Ok(<::types::inputs::Try>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_UnaryOp => {
            Ok(<::types::inputs::UnaryOp>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_UserGlobal => {
            Ok(<::types::inputs::UserGlobal>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_VarDecl => {
            Ok(<::types::inputs::VarDecl>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_While => {
            Ok(<::types::inputs::While>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_With => {
            Ok(<::types::inputs::With>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_Yield => {
            Ok(<::types::inputs::Yield>::from_record(_rec)?.into_ddvalue())
        },
        Relations::is_exported_IsExported => {
            Ok(<::types::is_exported::IsExported>::from_record(_rec)?.into_ddvalue())
        },
        Relations::name_in_scope_NameInScope => {
            Ok(<::types::name_in_scope::NameInScope>::from_record(_rec)?.into_ddvalue())
        },
        Relations::name_in_scope_NameOccursInScope => {
            Ok(<::types::name_in_scope::NameOccursInScope>::from_record(_rec)?.into_ddvalue())
        },
        Relations::outputs_no_shadow_DeclarationVisibleWithin => {
            Ok(<::types::outputs::no_shadow::DeclarationVisibleWithin>::from_record(_rec)?.into_ddvalue())
        },
        Relations::outputs_no_shadow_NoShadow => {
            Ok(<::types::outputs::no_shadow::NoShadow>::from_record(_rec)?.into_ddvalue())
        },
        Relations::outputs_no_undef_ChainedWith => {
            Ok(<::types::outputs::no_undef::ChainedWith>::from_record(_rec)?.into_ddvalue())
        },
        Relations::outputs_no_undef_NoUndef => {
            Ok(<::types::outputs::no_undef::NoUndef>::from_record(_rec)?.into_ddvalue())
        },
        Relations::outputs_no_unused_labels_LabelUsage => {
            Ok(<::types::outputs::no_unused_labels::LabelUsage>::from_record(_rec)?.into_ddvalue())
        },
        Relations::outputs_no_unused_labels_NoUnusedLabels => {
            Ok(<::types::outputs::no_unused_labels::NoUnusedLabels>::from_record(_rec)?.into_ddvalue())
        },
        Relations::outputs_no_unused_labels_UsedLabels => {
            Ok(<::types::outputs::no_unused_labels::UsedLabels>::from_record(_rec)?.into_ddvalue())
        },
        Relations::outputs_typeof_undef_TypeofUndef => {
            Ok(<::types::outputs::typeof_undef::TypeofUndef>::from_record(_rec)?.into_ddvalue())
        },
        Relations::outputs_typeof_undef_WithinTypeofExpr => {
            Ok(<::types::outputs::typeof_undef::WithinTypeofExpr>::from_record(_rec)?.into_ddvalue())
        },
        Relations::outputs_unused_vars_UnusedVariables => {
            Ok(<::types::outputs::unused_vars::UnusedVariables>::from_record(_rec)?.into_ddvalue())
        },
        Relations::outputs_use_before_def_UseBeforeDef => {
            Ok(<::types::outputs::use_before_def::UseBeforeDef>::from_record(_rec)?.into_ddvalue())
        },
        Relations::scopes_FunctionLevelScope => {
            Ok(<::types::scopes::FunctionLevelScope>::from_record(_rec)?.into_ddvalue())
        },
        Relations::scopes_IsHoistable => {
            Ok(<::types::scopes::IsHoistable>::from_record(_rec)?.into_ddvalue())
        },
        Relations::scopes_NeedsScopeChildren => {
            Ok(<::types::scopes::NeedsScopeChildren>::from_record(_rec)?.into_ddvalue())
        },
        Relations::scopes_NeedsScopeParents => {
            Ok(<::types::scopes::NeedsScopeParents>::from_record(_rec)?.into_ddvalue())
        },
        Relations::scopes_ScopeFamily => {
            Ok(<::types::scopes::ScopeFamily>::from_record(_rec)?.into_ddvalue())
        },
        Relations::scopes_ScopeOfId => {
            Ok(<::types::scopes::ScopeOfId>::from_record(_rec)?.into_ddvalue())
        },
        Relations::var_decls_VariableDeclarations => {
            Ok(<::types::var_decls::VariableDeclarations>::from_record(_rec)?.into_ddvalue())
        },
        Relations::variable_decl_VariableDecl => {
            Ok(<::types::variable_decl::VariableDecl>::from_record(_rec)?.into_ddvalue())
        }
    }
}
pub fn relkey_from_record(rel: Relations, _rec: &differential_datalog::record::Record) -> ::std::result::Result<DDValue, String> {
    match rel {
        Relations::inputs_Class => {
            Ok(<::types::ddlog_std::tuple2<::types::ast::ClassId, ::types::ast::FileId>>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_Expression => {
            Ok(<::types::ddlog_std::tuple2<::types::ast::ExprId, ::types::ast::FileId>>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_File => {
            Ok(<::types::ast::FileId>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_Function => {
            Ok(<::types::ddlog_std::tuple2<::types::ast::FuncId, ::types::ast::FileId>>::from_record(_rec)?.into_ddvalue())
        },
        Relations::inputs_Statement => {
            Ok(<::types::ddlog_std::tuple2<::types::ast::StmtId, ::types::ast::FileId>>::from_record(_rec)?.into_ddvalue())
        }
        _ => Err(format!("relation {:?} does not have a primary key", rel))
    }
}
pub fn idxkey_from_record(idx: Indexes, _rec: &differential_datalog::record::Record) -> ::std::result::Result<DDValue, String> {
    match idx {
        Indexes::inputs_EveryScopeByFile => {
            Ok(<::types::ast::FileId>::from_record(_rec)?.into_ddvalue())
        },
        Indexes::inputs_ExpressionByFile => {
            Ok(<::types::ast::FileId>::from_record(_rec)?.into_ddvalue())
        },
        Indexes::inputs_ExpressionById => {
            Ok(<::types::ddlog_std::tuple2<::types::ast::ExprId, ::types::ast::FileId>>::from_record(_rec)?.into_ddvalue())
        },
        Indexes::inputs_ExpressionBySpan => {
            Ok(<::types::ddlog_std::tuple2<::types::ast::Span, ::types::ast::FileId>>::from_record(_rec)?.into_ddvalue())
        },
        Indexes::inputs_FileById => {
            Ok(<::types::ast::FileId>::from_record(_rec)?.into_ddvalue())
        },
        Indexes::inputs_InputScopeByChild => {
            Ok(<::types::ddlog_std::tuple2<::types::ast::ScopeId, ::types::ast::FileId>>::from_record(_rec)?.into_ddvalue())
        },
        Indexes::inputs_InputScopeByFile => {
            Ok(<::types::ast::FileId>::from_record(_rec)?.into_ddvalue())
        },
        Indexes::inputs_InputScopeByParent => {
            Ok(<::types::ddlog_std::tuple2<::types::ast::ScopeId, ::types::ast::FileId>>::from_record(_rec)?.into_ddvalue())
        },
        Indexes::inputs_StatementByFile => {
            Ok(<::types::ast::FileId>::from_record(_rec)?.into_ddvalue())
        },
        Indexes::inputs_StatementById => {
            Ok(<::types::ddlog_std::tuple2<::types::ast::StmtId, ::types::ast::FileId>>::from_record(_rec)?.into_ddvalue())
        },
        Indexes::inputs_StatementBySpan => {
            Ok(<::types::ddlog_std::tuple2<::types::ast::Span, ::types::ast::FileId>>::from_record(_rec)?.into_ddvalue())
        },
        Indexes::name_in_scope_Index_VariableInScope => {
            Ok(<::types::ddlog_std::tuple3<::types::ast::FileId, ::types::ast::ScopeId, ::types::internment::Intern<String>>>::from_record(_rec)?.into_ddvalue())
        },
        Indexes::name_in_scope_Index_VariablesForScope => {
            Ok(<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::ast::ScopeId>>::from_record(_rec)?.into_ddvalue())
        },
        Indexes::scopes_ScopeFamilyByParent => {
            Ok(<::types::ddlog_std::tuple2<::types::ast::ScopeId, ::types::ast::FileId>>::from_record(_rec)?.into_ddvalue())
        }
    }
}
pub fn indexes2arrid(idx: Indexes) -> ArrId {
    match idx {
        Indexes::inputs_EveryScopeByFile => ( 25, 0),
        Indexes::inputs_ExpressionByFile => ( 30, 4),
        Indexes::inputs_ExpressionById => ( 30, 5),
        Indexes::inputs_ExpressionBySpan => ( 30, 6),
        Indexes::inputs_FileById => ( 31, 2),
        Indexes::inputs_InputScopeByChild => ( 43, 2),
        Indexes::inputs_InputScopeByFile => ( 43, 3),
        Indexes::inputs_InputScopeByParent => ( 43, 4),
        Indexes::inputs_StatementByFile => ( 30, 4),
        Indexes::inputs_StatementById => ( 50, 2),
        Indexes::inputs_StatementBySpan => ( 50, 3),
        Indexes::name_in_scope_Index_VariableInScope => ( 64, 6),
        Indexes::name_in_scope_Index_VariablesForScope => ( 64, 7),
        Indexes::scopes_ScopeFamilyByParent => ( 81, 2),
    }
}
#[derive(Copy,Clone,Debug,PartialEq,Eq,Hash)]
pub enum Relations {
    __Prefix_0 = 0,
    __Prefix_1 = 1,
    __Prefix_2 = 2,
    __Prefix_3 = 3,
    __Prefix_4 = 4,
    __Prefix_5 = 5,
    __Prefix_6 = 6,
    __Prefix_7 = 7,
    __Prefix_8 = 8,
    __Prefix_9 = 9,
    inputs_Array = 10,
    inputs_Arrow = 11,
    inputs_ArrowParam = 12,
    inputs_Assign = 13,
    inputs_Await = 14,
    inputs_BinOp = 15,
    inputs_BracketAccess = 16,
    inputs_Break = 17,
    inputs_Call = 18,
    inputs_Class = 19,
    inputs_ClassExpr = 20,
    inputs_ConstDecl = 21,
    inputs_Continue = 22,
    inputs_DoWhile = 23,
    inputs_DotAccess = 24,
    inputs_EveryScope = 25,
    inputs_ExprBigInt = 26,
    inputs_ExprBool = 27,
    inputs_ExprNumber = 28,
    inputs_ExprString = 29,
    inputs_Expression = 30,
    inputs_File = 31,
    inputs_FileExport = 32,
    inputs_For = 33,
    inputs_ForIn = 34,
    inputs_ForOf = 35,
    inputs_Function = 36,
    inputs_FunctionArg = 37,
    inputs_If = 38,
    inputs_ImplicitGlobal = 39,
    inputs_ImportDecl = 40,
    inputs_InlineFunc = 41,
    inputs_InlineFuncParam = 42,
    inputs_InputScope = 43,
    inputs_Label = 44,
    inputs_LetDecl = 45,
    inputs_NameRef = 46,
    inputs_New = 47,
    inputs_Property = 48,
    inputs_Return = 49,
    inputs_Statement = 50,
    inputs_Switch = 51,
    inputs_SwitchCase = 52,
    inputs_Template = 53,
    inputs_Ternary = 54,
    inputs_Throw = 55,
    inputs_Try = 56,
    inputs_UnaryOp = 57,
    inputs_UserGlobal = 58,
    inputs_VarDecl = 59,
    inputs_While = 60,
    inputs_With = 61,
    inputs_Yield = 62,
    is_exported_IsExported = 63,
    name_in_scope_NameInScope = 64,
    name_in_scope_NameOccursInScope = 65,
    outputs_no_shadow_DeclarationVisibleWithin = 66,
    outputs_no_shadow_NoShadow = 67,
    outputs_no_undef_ChainedWith = 68,
    outputs_no_undef_NoUndef = 69,
    outputs_no_unused_labels_LabelUsage = 70,
    outputs_no_unused_labels_NoUnusedLabels = 71,
    outputs_no_unused_labels_UsedLabels = 72,
    outputs_typeof_undef_TypeofUndef = 73,
    outputs_typeof_undef_WithinTypeofExpr = 74,
    outputs_unused_vars_UnusedVariables = 75,
    outputs_use_before_def_UseBeforeDef = 76,
    scopes_FunctionLevelScope = 77,
    scopes_IsHoistable = 78,
    scopes_NeedsScopeChildren = 79,
    scopes_NeedsScopeParents = 80,
    scopes_ScopeFamily = 81,
    scopes_ScopeOfId = 82,
    var_decls_VariableDeclarations = 83,
    variable_decl_VariableDecl = 84
}
#[derive(Copy,Clone,Debug,PartialEq,Eq,Hash)]
pub enum Indexes {
    inputs_EveryScopeByFile = 0,
    inputs_ExpressionByFile = 1,
    inputs_ExpressionById = 2,
    inputs_ExpressionBySpan = 3,
    inputs_FileById = 4,
    inputs_InputScopeByChild = 5,
    inputs_InputScopeByFile = 6,
    inputs_InputScopeByParent = 7,
    inputs_StatementByFile = 8,
    inputs_StatementById = 9,
    inputs_StatementBySpan = 10,
    name_in_scope_Index_VariableInScope = 11,
    name_in_scope_Index_VariablesForScope = 12,
    scopes_ScopeFamilyByParent = 13
}
pub fn prog(__update_cb: Box<dyn CBFn>) -> Program {
    let inputs_Array = Relation {
                           name:         "inputs::Array".to_string(),
                           input:        true,
                           distinct:     false,
                           caching_mode: CachingMode::Set,
                           key_func:     None,
                           id:           Relations::inputs_Array as RelId,
                           rules:        vec![
                               ],
                           arrangements: vec![
                               ],
                           change_cb:    None
                       };
    let inputs_Arrow = Relation {
                           name:         "inputs::Arrow".to_string(),
                           input:        true,
                           distinct:     false,
                           caching_mode: CachingMode::Set,
                           key_func:     None,
                           id:           Relations::inputs_Arrow as RelId,
                           rules:        vec![
                               ],
                           arrangements: vec![
                               Arrangement::Map{
                                  name: r###"(inputs::Arrow{.expr_id=(_0: ast::ExprId), .file=(_1: ast::FileId), .body=(ddlog_std::Some{.x=((_: ddlog_std::Either<ast::ExprId,ast::StmtId>), (_: ast::ScopeId))}: ddlog_std::Option<(ddlog_std::Either<ast::ExprId,ast::StmtId>, ast::ScopeId)>)}: inputs::Arrow) /*join*/"###.to_string(),
                                   afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                   {
                                       let __cloned = __v.clone();
                                       match < ::types::inputs::Arrow>::from_ddvalue(__v) {
                                           ::types::inputs::Arrow{expr_id: ref _0, file: ref _1, body: ::types::ddlog_std::Option::Some{x: ::types::ddlog_std::tuple2(_, _)}} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                           _ => None
                                       }.map(|x|(x,__cloned))
                                   }
                                   __f},
                                   queryable: false
                               }],
                           change_cb:    None
                       };
    let inputs_ArrowParam = Relation {
                                name:         "inputs::ArrowParam".to_string(),
                                input:        true,
                                distinct:     false,
                                caching_mode: CachingMode::Set,
                                key_func:     None,
                                id:           Relations::inputs_ArrowParam as RelId,
                                rules:        vec![
                                    ],
                                arrangements: vec![
                                    Arrangement::Map{
                                       name: r###"(inputs::ArrowParam{.expr_id=(_0: ast::ExprId), .file=(_1: ast::FileId), .param=(_: internment::Intern<ast::Pattern>)}: inputs::ArrowParam) /*join*/"###.to_string(),
                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                        {
                                            let __cloned = __v.clone();
                                            match < ::types::inputs::ArrowParam>::from_ddvalue(__v) {
                                                ::types::inputs::ArrowParam{expr_id: ref _0, file: ref _1, param: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                _ => None
                                            }.map(|x|(x,__cloned))
                                        }
                                        __f},
                                        queryable: false
                                    }],
                                change_cb:    None
                            };
    let inputs_Assign = Relation {
                            name:         "inputs::Assign".to_string(),
                            input:        true,
                            distinct:     false,
                            caching_mode: CachingMode::Set,
                            key_func:     None,
                            id:           Relations::inputs_Assign as RelId,
                            rules:        vec![
                                ],
                            arrangements: vec![
                                Arrangement::Map{
                                   name: r###"(inputs::Assign{.expr_id=(_0: ast::ExprId), .file=(_1: ast::FileId), .lhs=(ddlog_std::Some{.x=(ddlog_std::Left{.l=(_: internment::Intern<ast::Pattern>)}: ddlog_std::Either<internment::Intern<ast::Pattern>,ast::ExprId>)}: ddlog_std::Option<ddlog_std::Either<ast::IPattern,ast::ExprId>>), .rhs=(_: ddlog_std::Option<ast::ExprId>), .op=(_: ddlog_std::Option<ast::AssignOperand>)}: inputs::Assign) /*join*/"###.to_string(),
                                    afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                    {
                                        let __cloned = __v.clone();
                                        match < ::types::inputs::Assign>::from_ddvalue(__v) {
                                            ::types::inputs::Assign{expr_id: ref _0, file: ref _1, lhs: ::types::ddlog_std::Option::Some{x: ::types::ddlog_std::Either::Left{l: _}}, rhs: _, op: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                            _ => None
                                        }.map(|x|(x,__cloned))
                                    }
                                    __f},
                                    queryable: false
                                },
                                Arrangement::Map{
                                   name: r###"(inputs::Assign{.expr_id=(_: ast::ExprId), .file=(_0: ast::FileId), .lhs=(ddlog_std::Some{.x=(ddlog_std::Left{.l=(_: internment::Intern<ast::Pattern>)}: ddlog_std::Either<internment::Intern<ast::Pattern>,ast::ExprId>)}: ddlog_std::Option<ddlog_std::Either<ast::IPattern,ast::ExprId>>), .rhs=(_: ddlog_std::Option<ast::ExprId>), .op=(_: ddlog_std::Option<ast::AssignOperand>)}: inputs::Assign) /*join*/"###.to_string(),
                                    afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                    {
                                        let __cloned = __v.clone();
                                        match < ::types::inputs::Assign>::from_ddvalue(__v) {
                                            ::types::inputs::Assign{expr_id: _, file: ref _0, lhs: ::types::ddlog_std::Option::Some{x: ::types::ddlog_std::Either::Left{l: _}}, rhs: _, op: _} => Some(((*_0).clone()).into_ddvalue()),
                                            _ => None
                                        }.map(|x|(x,__cloned))
                                    }
                                    __f},
                                    queryable: false
                                }],
                            change_cb:    None
                        };
    let inputs_Await = Relation {
                           name:         "inputs::Await".to_string(),
                           input:        true,
                           distinct:     false,
                           caching_mode: CachingMode::Set,
                           key_func:     None,
                           id:           Relations::inputs_Await as RelId,
                           rules:        vec![
                               ],
                           arrangements: vec![
                               ],
                           change_cb:    None
                       };
    let inputs_BinOp = Relation {
                           name:         "inputs::BinOp".to_string(),
                           input:        true,
                           distinct:     false,
                           caching_mode: CachingMode::Set,
                           key_func:     None,
                           id:           Relations::inputs_BinOp as RelId,
                           rules:        vec![
                               ],
                           arrangements: vec![
                               ],
                           change_cb:    None
                       };
    let inputs_BracketAccess = Relation {
                                   name:         "inputs::BracketAccess".to_string(),
                                   input:        true,
                                   distinct:     false,
                                   caching_mode: CachingMode::Set,
                                   key_func:     None,
                                   id:           Relations::inputs_BracketAccess as RelId,
                                   rules:        vec![
                                       ],
                                   arrangements: vec![
                                       Arrangement::Map{
                                          name: r###"(inputs::BracketAccess{.expr_id=(_: ast::ExprId), .file=(_0: ast::FileId), .object=(ddlog_std::Some{.x=(_: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .prop=(ddlog_std::Some{.x=(_: ast::ExprId)}: ddlog_std::Option<ast::ExprId>)}: inputs::BracketAccess) /*join*/"###.to_string(),
                                           afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                           {
                                               let __cloned = __v.clone();
                                               match < ::types::inputs::BracketAccess>::from_ddvalue(__v) {
                                                   ::types::inputs::BracketAccess{expr_id: _, file: ref _0, object: ::types::ddlog_std::Option::Some{x: _}, prop: ::types::ddlog_std::Option::Some{x: _}} => Some(((*_0).clone()).into_ddvalue()),
                                                   _ => None
                                               }.map(|x|(x,__cloned))
                                           }
                                           __f},
                                           queryable: false
                                       }],
                                   change_cb:    None
                               };
    let inputs_Break = Relation {
                           name:         "inputs::Break".to_string(),
                           input:        true,
                           distinct:     false,
                           caching_mode: CachingMode::Set,
                           key_func:     None,
                           id:           Relations::inputs_Break as RelId,
                           rules:        vec![
                               ],
                           arrangements: vec![
                               Arrangement::Map{
                                  name: r###"(inputs::Break{.stmt_id=(_: ast::StmtId), .file=(_0: ast::FileId), .label=(ddlog_std::Some{.x=(ast::Spanned{.data=(_: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>)}: inputs::Break) /*join*/"###.to_string(),
                                   afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                   {
                                       let __cloned = __v.clone();
                                       match < ::types::inputs::Break>::from_ddvalue(__v) {
                                           ::types::inputs::Break{stmt_id: _, file: ref _0, label: ::types::ddlog_std::Option::Some{x: ::types::ast::Spanned{data: _, span: _}}} => Some(((*_0).clone()).into_ddvalue()),
                                           _ => None
                                       }.map(|x|(x,__cloned))
                                   }
                                   __f},
                                   queryable: false
                               }],
                           change_cb:    None
                       };
    let inputs_Call = Relation {
                          name:         "inputs::Call".to_string(),
                          input:        true,
                          distinct:     false,
                          caching_mode: CachingMode::Set,
                          key_func:     None,
                          id:           Relations::inputs_Call as RelId,
                          rules:        vec![
                              ],
                          arrangements: vec![
                              Arrangement::Map{
                                 name: r###"(inputs::Call{.expr_id=(_: ast::ExprId), .file=(_0: ast::FileId), .callee=(ddlog_std::Some{.x=(_: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::Call) /*join*/"###.to_string(),
                                  afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                  {
                                      let __cloned = __v.clone();
                                      match < ::types::inputs::Call>::from_ddvalue(__v) {
                                          ::types::inputs::Call{expr_id: _, file: ref _0, callee: ::types::ddlog_std::Option::Some{x: _}, args: _} => Some(((*_0).clone()).into_ddvalue()),
                                          _ => None
                                      }.map(|x|(x,__cloned))
                                  }
                                  __f},
                                  queryable: false
                              }],
                          change_cb:    None
                      };
    let inputs_Class = Relation {
                           name:         "inputs::Class".to_string(),
                           input:        true,
                           distinct:     false,
                           caching_mode: CachingMode::Set,
                           key_func:     Some((|__key: &DDValue| {
                                                  let ref c = *<::types::inputs::Class>::from_ddvalue_ref(__key);
                                                  (::types::ddlog_std::tuple2(c.id.clone(), c.file.clone())).into_ddvalue()
                                              })),
                           id:           Relations::inputs_Class as RelId,
                           rules:        vec![
                               ],
                           arrangements: vec![
                               Arrangement::Map{
                                  name: r###"(inputs::Class{.id=(_0: ast::ClassId), .file=(_1: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(_: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Class) /*join*/"###.to_string(),
                                   afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                   {
                                       let __cloned = __v.clone();
                                       match < ::types::inputs::Class>::from_ddvalue(__v) {
                                           ::types::inputs::Class{id: ref _0, file: ref _1, name: ::types::ddlog_std::Option::Some{x: ::types::ast::Spanned{data: _, span: _}}, parent: _, elements: _, scope: _, exported: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                           _ => None
                                       }.map(|x|(x,__cloned))
                                   }
                                   __f},
                                   queryable: false
                               },
                               Arrangement::Map{
                                  name: r###"(inputs::Class{.id=(_: ast::ClassId), .file=(_0: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(_1: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Class) /*join*/"###.to_string(),
                                   afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                   {
                                       let __cloned = __v.clone();
                                       match < ::types::inputs::Class>::from_ddvalue(__v) {
                                           ::types::inputs::Class{id: _, file: ref _0, name: ::types::ddlog_std::Option::Some{x: ::types::ast::Spanned{data: ref _1, span: _}}, parent: _, elements: _, scope: _, exported: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                           _ => None
                                       }.map(|x|(x,__cloned))
                                   }
                                   __f},
                                   queryable: false
                               }],
                           change_cb:    None
                       };
    let inputs_ClassExpr = Relation {
                               name:         "inputs::ClassExpr".to_string(),
                               input:        true,
                               distinct:     false,
                               caching_mode: CachingMode::Set,
                               key_func:     None,
                               id:           Relations::inputs_ClassExpr as RelId,
                               rules:        vec![
                                   ],
                               arrangements: vec![
                                   Arrangement::Set{
                                       name: r###"(inputs::ClassExpr{.expr_id=(_0: ast::ExprId), .file=(_1: ast::FileId), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>)}: inputs::ClassExpr) /*semijoin*/"###.to_string(),
                                       fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                       {
                                           match < ::types::inputs::ClassExpr>::from_ddvalue(__v) {
                                               ::types::inputs::ClassExpr{expr_id: ref _0, file: ref _1, elements: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                               _ => None
                                           }
                                       }
                                       __f},
                                       distinct: false
                                   }],
                               change_cb:    None
                           };
    let inputs_ConstDecl = Relation {
                               name:         "inputs::ConstDecl".to_string(),
                               input:        true,
                               distinct:     false,
                               caching_mode: CachingMode::Set,
                               key_func:     None,
                               id:           Relations::inputs_ConstDecl as RelId,
                               rules:        vec![
                                   ],
                               arrangements: vec![
                                   Arrangement::Map{
                                      name: r###"(inputs::ConstDecl{.stmt_id=(_0: ast::StmtId), .file=(_1: ast::FileId), .pattern=(ddlog_std::Some{.x=(_: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: inputs::ConstDecl) /*join*/"###.to_string(),
                                       afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                       {
                                           let __cloned = __v.clone();
                                           match < ::types::inputs::ConstDecl>::from_ddvalue(__v) {
                                               ::types::inputs::ConstDecl{stmt_id: ref _0, file: ref _1, pattern: ::types::ddlog_std::Option::Some{x: _}, value: _, exported: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                               _ => None
                                           }.map(|x|(x,__cloned))
                                       }
                                       __f},
                                       queryable: false
                                   }],
                               change_cb:    None
                           };
    let inputs_Continue = Relation {
                              name:         "inputs::Continue".to_string(),
                              input:        true,
                              distinct:     false,
                              caching_mode: CachingMode::Set,
                              key_func:     None,
                              id:           Relations::inputs_Continue as RelId,
                              rules:        vec![
                                  ],
                              arrangements: vec![
                                  Arrangement::Map{
                                     name: r###"(inputs::Continue{.stmt_id=(_: ast::StmtId), .file=(_0: ast::FileId), .label=(ddlog_std::Some{.x=(ast::Spanned{.data=(_: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>)}: inputs::Continue) /*join*/"###.to_string(),
                                      afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                      {
                                          let __cloned = __v.clone();
                                          match < ::types::inputs::Continue>::from_ddvalue(__v) {
                                              ::types::inputs::Continue{stmt_id: _, file: ref _0, label: ::types::ddlog_std::Option::Some{x: ::types::ast::Spanned{data: _, span: _}}} => Some(((*_0).clone()).into_ddvalue()),
                                              _ => None
                                          }.map(|x|(x,__cloned))
                                      }
                                      __f},
                                      queryable: false
                                  }],
                              change_cb:    None
                          };
    let inputs_DoWhile = Relation {
                             name:         "inputs::DoWhile".to_string(),
                             input:        true,
                             distinct:     false,
                             caching_mode: CachingMode::Set,
                             key_func:     None,
                             id:           Relations::inputs_DoWhile as RelId,
                             rules:        vec![
                                 ],
                             arrangements: vec![
                                 ],
                             change_cb:    None
                         };
    let inputs_DotAccess = Relation {
                               name:         "inputs::DotAccess".to_string(),
                               input:        true,
                               distinct:     false,
                               caching_mode: CachingMode::Set,
                               key_func:     None,
                               id:           Relations::inputs_DotAccess as RelId,
                               rules:        vec![
                                   ],
                               arrangements: vec![
                                   Arrangement::Map{
                                      name: r###"(inputs::DotAccess{.expr_id=(_: ast::ExprId), .file=(_0: ast::FileId), .object=(ddlog_std::Some{.x=(_: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .prop=(_: ddlog_std::Option<ast::Spanned<ast::Name>>)}: inputs::DotAccess) /*join*/"###.to_string(),
                                       afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                       {
                                           let __cloned = __v.clone();
                                           match < ::types::inputs::DotAccess>::from_ddvalue(__v) {
                                               ::types::inputs::DotAccess{expr_id: _, file: ref _0, object: ::types::ddlog_std::Option::Some{x: _}, prop: _} => Some(((*_0).clone()).into_ddvalue()),
                                               _ => None
                                           }.map(|x|(x,__cloned))
                                       }
                                       __f},
                                       queryable: false
                                   }],
                               change_cb:    None
                           };
    let inputs_EveryScope = Relation {
                                name:         "inputs::EveryScope".to_string(),
                                input:        true,
                                distinct:     false,
                                caching_mode: CachingMode::Set,
                                key_func:     None,
                                id:           Relations::inputs_EveryScope as RelId,
                                rules:        vec![
                                    ],
                                arrangements: vec![
                                    Arrangement::Map{
                                       name: r###"(inputs::EveryScope{.scope=(_: ast::ScopeId), .file=_0}: inputs::EveryScope) /*join*/"###.to_string(),
                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                        {
                                            let __cloned = __v.clone();
                                            match < ::types::inputs::EveryScope>::from_ddvalue(__v) {
                                                ::types::inputs::EveryScope{scope: _, file: ref _0} => Some(((*_0).clone()).into_ddvalue()),
                                                _ => None
                                            }.map(|x|(x,__cloned))
                                        }
                                        __f},
                                        queryable: true
                                    }],
                                change_cb:    None
                            };
    let inputs_ExprBigInt = Relation {
                                name:         "inputs::ExprBigInt".to_string(),
                                input:        true,
                                distinct:     false,
                                caching_mode: CachingMode::Set,
                                key_func:     None,
                                id:           Relations::inputs_ExprBigInt as RelId,
                                rules:        vec![
                                    ],
                                arrangements: vec![
                                    ],
                                change_cb:    None
                            };
    let inputs_ExprBool = Relation {
                              name:         "inputs::ExprBool".to_string(),
                              input:        true,
                              distinct:     false,
                              caching_mode: CachingMode::Set,
                              key_func:     None,
                              id:           Relations::inputs_ExprBool as RelId,
                              rules:        vec![
                                  ],
                              arrangements: vec![
                                  ],
                              change_cb:    None
                          };
    let inputs_ExprNumber = Relation {
                                name:         "inputs::ExprNumber".to_string(),
                                input:        true,
                                distinct:     false,
                                caching_mode: CachingMode::Set,
                                key_func:     None,
                                id:           Relations::inputs_ExprNumber as RelId,
                                rules:        vec![
                                    ],
                                arrangements: vec![
                                    ],
                                change_cb:    None
                            };
    let inputs_ExprString = Relation {
                                name:         "inputs::ExprString".to_string(),
                                input:        true,
                                distinct:     false,
                                caching_mode: CachingMode::Set,
                                key_func:     None,
                                id:           Relations::inputs_ExprString as RelId,
                                rules:        vec![
                                    ],
                                arrangements: vec![
                                    ],
                                change_cb:    None
                            };
    let inputs_Expression = Relation {
                                name:         "inputs::Expression".to_string(),
                                input:        true,
                                distinct:     false,
                                caching_mode: CachingMode::Set,
                                key_func:     Some((|__key: &DDValue| {
                                                       let ref e = *<::types::inputs::Expression>::from_ddvalue_ref(__key);
                                                       (::types::ddlog_std::tuple2(e.id.clone(), e.file.clone())).into_ddvalue()
                                                   })),
                                id:           Relations::inputs_Expression as RelId,
                                rules:        vec![
                                    ],
                                arrangements: vec![
                                    Arrangement::Map{
                                       name: r###"(inputs::Expression{.id=(_0: ast::ExprId), .file=(_1: ast::FileId), .kind=(_: ast::ExprKind), .scope=(_: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression) /*join*/"###.to_string(),
                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                        {
                                            let __cloned = __v.clone();
                                            match < ::types::inputs::Expression>::from_ddvalue(__v) {
                                                ::types::inputs::Expression{id: ref _0, file: ref _1, kind: _, scope: _, span: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                _ => None
                                            }.map(|x|(x,__cloned))
                                        }
                                        __f},
                                        queryable: false
                                    },
                                    Arrangement::Map{
                                       name: r###"(inputs::Expression{.id=(_0: ast::ExprId), .file=(_1: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(_: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression) /*join*/"###.to_string(),
                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                        {
                                            let __cloned = __v.clone();
                                            match < ::types::inputs::Expression>::from_ddvalue(__v) {
                                                ::types::inputs::Expression{id: ref _0, file: ref _1, kind: ::types::ast::ExprKind::ExprNameRef{}, scope: _, span: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                _ => None
                                            }.map(|x|(x,__cloned))
                                        }
                                        __f},
                                        queryable: false
                                    },
                                    Arrangement::Map{
                                       name: r###"(inputs::Expression{.id=(_0: ast::ExprId), .file=(_1: ast::FileId), .kind=(ast::ExprGrouping{.inner=(ddlog_std::Some{.x=(_: ast::ExprId)}: ddlog_std::Option<ast::ExprId>)}: ast::ExprKind), .scope=(_: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression) /*join*/"###.to_string(),
                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                        {
                                            let __cloned = __v.clone();
                                            match < ::types::inputs::Expression>::from_ddvalue(__v) {
                                                ::types::inputs::Expression{id: ref _0, file: ref _1, kind: ::types::ast::ExprKind::ExprGrouping{inner: ::types::ddlog_std::Option::Some{x: _}}, scope: _, span: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                _ => None
                                            }.map(|x|(x,__cloned))
                                        }
                                        __f},
                                        queryable: false
                                    },
                                    Arrangement::Map{
                                       name: r###"(inputs::Expression{.id=(_0: ast::ExprId), .file=(_1: ast::FileId), .kind=(ast::ExprSequence{.exprs=(_: ddlog_std::Vec<ast::ExprId>)}: ast::ExprKind), .scope=(_: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression) /*join*/"###.to_string(),
                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                        {
                                            let __cloned = __v.clone();
                                            match < ::types::inputs::Expression>::from_ddvalue(__v) {
                                                ::types::inputs::Expression{id: ref _0, file: ref _1, kind: ::types::ast::ExprKind::ExprSequence{exprs: _}, scope: _, span: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                _ => None
                                            }.map(|x|(x,__cloned))
                                        }
                                        __f},
                                        queryable: false
                                    },
                                    Arrangement::Map{
                                       name: r###"(inputs::Expression{.id=(_: ast::ExprId), .file=_0, .kind=(_: ast::ExprKind), .scope=(_: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression) /*join*/"###.to_string(),
                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                        {
                                            let __cloned = __v.clone();
                                            match < ::types::inputs::Expression>::from_ddvalue(__v) {
                                                ::types::inputs::Expression{id: _, file: ref _0, kind: _, scope: _, span: _} => Some(((*_0).clone()).into_ddvalue()),
                                                _ => None
                                            }.map(|x|(x,__cloned))
                                        }
                                        __f},
                                        queryable: true
                                    },
                                    Arrangement::Map{
                                       name: r###"(inputs::Expression{.id=_0, .file=_1, .kind=(_: ast::ExprKind), .scope=(_: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression) /*join*/"###.to_string(),
                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                        {
                                            let __cloned = __v.clone();
                                            match < ::types::inputs::Expression>::from_ddvalue(__v) {
                                                ::types::inputs::Expression{id: ref _0, file: ref _1, kind: _, scope: _, span: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                _ => None
                                            }.map(|x|(x,__cloned))
                                        }
                                        __f},
                                        queryable: true
                                    },
                                    Arrangement::Map{
                                       name: r###"(inputs::Expression{.id=(_: ast::ExprId), .file=_1, .kind=(_: ast::ExprKind), .scope=(_: ast::ScopeId), .span=_0}: inputs::Expression) /*join*/"###.to_string(),
                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                        {
                                            let __cloned = __v.clone();
                                            match < ::types::inputs::Expression>::from_ddvalue(__v) {
                                                ::types::inputs::Expression{id: _, file: ref _1, kind: _, scope: _, span: ref _0} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                _ => None
                                            }.map(|x|(x,__cloned))
                                        }
                                        __f},
                                        queryable: true
                                    }],
                                change_cb:    None
                            };
    let inputs_File = Relation {
                          name:         "inputs::File".to_string(),
                          input:        true,
                          distinct:     false,
                          caching_mode: CachingMode::Set,
                          key_func:     Some((|__key: &DDValue| {
                                                 let ref f = *<::types::inputs::File>::from_ddvalue_ref(__key);
                                                 (f.id.clone()).into_ddvalue()
                                             })),
                          id:           Relations::inputs_File as RelId,
                          rules:        vec![
                              ],
                          arrangements: vec![
                              Arrangement::Map{
                                 name: r###"(inputs::File{.id=(_0: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(_: ast::ScopeId), .config=(_: config::Config)}: inputs::File) /*join*/"###.to_string(),
                                  afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                  {
                                      let __cloned = __v.clone();
                                      match < ::types::inputs::File>::from_ddvalue(__v) {
                                          ::types::inputs::File{id: ref _0, kind: _, top_level_scope: _, config: _} => Some(((*_0).clone()).into_ddvalue()),
                                          _ => None
                                      }.map(|x|(x,__cloned))
                                  }
                                  __f},
                                  queryable: false
                              },
                              Arrangement::Map{
                                 name: r###"(inputs::File{.id=(_: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(_: ast::ScopeId), .config=(_: config::Config)}: inputs::File) /*join*/"###.to_string(),
                                  afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                  {
                                      let __cloned = __v.clone();
                                      match < ::types::inputs::File>::from_ddvalue(__v) {
                                          ::types::inputs::File{id: _, kind: _, top_level_scope: _, config: _} => Some((()).into_ddvalue()),
                                          _ => None
                                      }.map(|x|(x,__cloned))
                                  }
                                  __f},
                                  queryable: false
                              },
                              Arrangement::Map{
                                 name: r###"(inputs::File{.id=_0, .kind=(_: ast::FileKind), .top_level_scope=(_: ast::ScopeId), .config=(_: config::Config)}: inputs::File) /*join*/"###.to_string(),
                                  afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                  {
                                      let __cloned = __v.clone();
                                      match < ::types::inputs::File>::from_ddvalue(__v) {
                                          ::types::inputs::File{id: ref _0, kind: _, top_level_scope: _, config: _} => Some(((*_0).clone()).into_ddvalue()),
                                          _ => None
                                      }.map(|x|(x,__cloned))
                                  }
                                  __f},
                                  queryable: true
                              }],
                          change_cb:    None
                      };
    let __Prefix_4 = Relation {
                         name:         "__Prefix_4".to_string(),
                         input:        false,
                         distinct:     false,
                         caching_mode: CachingMode::Set,
                         key_func:     None,
                         id:           Relations::__Prefix_4 as RelId,
                         rules:        vec![
                             /* __Prefix_4[((file: ast::FileId), (config: config::Config))] :- inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(_: ast::ScopeId), .config=(config: config::Config)}: inputs::File)], (config::no_unused_vars_enabled(config)). */
                             Rule::CollectionRule {
                                 description: "__Prefix_4[((file: ast::FileId), (config: config::Config))] :- inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(_: ast::ScopeId), .config=(config: config::Config)}: inputs::File)], (config::no_unused_vars_enabled(config)).".to_string(),
                                 rel: Relations::inputs_File as RelId,
                                 xform: Some(XFormCollection::FilterMap{
                                                 description: "head of __Prefix_4[((file: ast::FileId), (config: config::Config))] :- inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(_: ast::ScopeId), .config=(config: config::Config)}: inputs::File)], (config::no_unused_vars_enabled(config))." .to_string(),
                                                 fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                 {
                                                     let (ref file, ref config) = match *<::types::inputs::File>::from_ddvalue_ref(&__v) {
                                                         ::types::inputs::File{id: ref file, kind: _, top_level_scope: _, config: ref config} => ((*file).clone(), (*config).clone()),
                                                         _ => return None
                                                     };
                                                     if !::types::config::no_unused_vars_enabled(config) {return None;};
                                                     Some((::types::ddlog_std::tuple2((*file).clone(), (*config).clone())).into_ddvalue())
                                                 }
                                                 __f},
                                                 next: Box::new(None)
                                             })
                             }],
                         arrangements: vec![
                             Arrangement::Map{
                                name: r###"((_0: ast::FileId), (_: config::Config)) /*join*/"###.to_string(),
                                 afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                 {
                                     let __cloned = __v.clone();
                                     match < ::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue(__v) {
                                         ::types::ddlog_std::tuple2(ref _0, _) => Some(((*_0).clone()).into_ddvalue()),
                                         _ => None
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             }],
                         change_cb:    None
                     };
    let __Prefix_5 = Relation {
                         name:         "__Prefix_5".to_string(),
                         input:        false,
                         distinct:     false,
                         caching_mode: CachingMode::Set,
                         key_func:     None,
                         id:           Relations::__Prefix_5 as RelId,
                         rules:        vec![
                             /* __Prefix_5[((file: ast::FileId), (config: config::Config))] :- inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(_: ast::ScopeId), .config=(config: config::Config)}: inputs::File)], (config::no_shadow_enabled(config)). */
                             Rule::CollectionRule {
                                 description: "__Prefix_5[((file: ast::FileId), (config: config::Config))] :- inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(_: ast::ScopeId), .config=(config: config::Config)}: inputs::File)], (config::no_shadow_enabled(config)).".to_string(),
                                 rel: Relations::inputs_File as RelId,
                                 xform: Some(XFormCollection::FilterMap{
                                                 description: "head of __Prefix_5[((file: ast::FileId), (config: config::Config))] :- inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(_: ast::ScopeId), .config=(config: config::Config)}: inputs::File)], (config::no_shadow_enabled(config))." .to_string(),
                                                 fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                 {
                                                     let (ref file, ref config) = match *<::types::inputs::File>::from_ddvalue_ref(&__v) {
                                                         ::types::inputs::File{id: ref file, kind: _, top_level_scope: _, config: ref config} => ((*file).clone(), (*config).clone()),
                                                         _ => return None
                                                     };
                                                     if !::types::config::no_shadow_enabled(config) {return None;};
                                                     Some((::types::ddlog_std::tuple2((*file).clone(), (*config).clone())).into_ddvalue())
                                                 }
                                                 __f},
                                                 next: Box::new(None)
                                             })
                             }],
                         arrangements: vec![
                             Arrangement::Map{
                                name: r###"((_0: ast::FileId), (_: config::Config)) /*join*/"###.to_string(),
                                 afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                 {
                                     let __cloned = __v.clone();
                                     match < ::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue(__v) {
                                         ::types::ddlog_std::tuple2(ref _0, _) => Some(((*_0).clone()).into_ddvalue()),
                                         _ => None
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             }],
                         change_cb:    None
                     };
    let __Prefix_6 = Relation {
                         name:         "__Prefix_6".to_string(),
                         input:        false,
                         distinct:     false,
                         caching_mode: CachingMode::Set,
                         key_func:     None,
                         id:           Relations::__Prefix_6 as RelId,
                         rules:        vec![
                             /* __Prefix_6[((file: ast::FileId), (config: config::Config))] :- inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(_: ast::ScopeId), .config=(config: config::Config)}: inputs::File)], (config::no_undef_enabled(config)). */
                             Rule::CollectionRule {
                                 description: "__Prefix_6[((file: ast::FileId), (config: config::Config))] :- inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(_: ast::ScopeId), .config=(config: config::Config)}: inputs::File)], (config::no_undef_enabled(config)).".to_string(),
                                 rel: Relations::inputs_File as RelId,
                                 xform: Some(XFormCollection::FilterMap{
                                                 description: "head of __Prefix_6[((file: ast::FileId), (config: config::Config))] :- inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(_: ast::ScopeId), .config=(config: config::Config)}: inputs::File)], (config::no_undef_enabled(config))." .to_string(),
                                                 fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                 {
                                                     let (ref file, ref config) = match *<::types::inputs::File>::from_ddvalue_ref(&__v) {
                                                         ::types::inputs::File{id: ref file, kind: _, top_level_scope: _, config: ref config} => ((*file).clone(), (*config).clone()),
                                                         _ => return None
                                                     };
                                                     if !::types::config::no_undef_enabled(config) {return None;};
                                                     Some((::types::ddlog_std::tuple2((*file).clone(), (*config).clone())).into_ddvalue())
                                                 }
                                                 __f},
                                                 next: Box::new(None)
                                             })
                             }],
                         arrangements: vec![
                             Arrangement::Map{
                                name: r###"((_0: ast::FileId), (_: config::Config)) /*join*/"###.to_string(),
                                 afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                 {
                                     let __cloned = __v.clone();
                                     match < ::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue(__v) {
                                         ::types::ddlog_std::tuple2(ref _0, _) => Some(((*_0).clone()).into_ddvalue()),
                                         _ => None
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             }],
                         change_cb:    None
                     };
    let outputs_no_undef_ChainedWith = Relation {
                                           name:         "outputs::no_undef::ChainedWith".to_string(),
                                           input:        false,
                                           distinct:     false,
                                           caching_mode: CachingMode::Set,
                                           key_func:     None,
                                           id:           Relations::outputs_no_undef_ChainedWith as RelId,
                                           rules:        vec![
                                               /* outputs::no_undef::ChainedWith[(outputs::no_undef::ChainedWith{.object=object, .property=property, .file=file}: outputs::no_undef::ChainedWith)] :- __Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::BracketAccess[(inputs::BracketAccess{.expr_id=(_: ast::ExprId), .file=(file: ast::FileId), .object=(ddlog_std::Some{.x=(object: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .prop=(ddlog_std::Some{.x=(property: ast::ExprId)}: ddlog_std::Option<ast::ExprId>)}: inputs::BracketAccess)]. */
                                               Rule::ArrangementRule {
                                                   description: "outputs::no_undef::ChainedWith[(outputs::no_undef::ChainedWith{.object=object, .property=property, .file=file}: outputs::no_undef::ChainedWith)] :- __Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::BracketAccess[(inputs::BracketAccess{.expr_id=(_: ast::ExprId), .file=(file: ast::FileId), .object=(ddlog_std::Some{.x=(object: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .prop=(ddlog_std::Some{.x=(property: ast::ExprId)}: ddlog_std::Option<ast::ExprId>)}: inputs::BracketAccess)].".to_string(),
                                                   arr: ( Relations::__Prefix_6 as RelId, 0),
                                                   xform: XFormArrangement::Join{
                                                              description: "__Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::BracketAccess[(inputs::BracketAccess{.expr_id=(_: ast::ExprId), .file=(file: ast::FileId), .object=(ddlog_std::Some{.x=(object: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .prop=(ddlog_std::Some{.x=(property: ast::ExprId)}: ddlog_std::Option<ast::ExprId>)}: inputs::BracketAccess)]".to_string(),
                                                              ffun: None,
                                                              arrangement: (Relations::inputs_BracketAccess as RelId,0),
                                                              jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                              {
                                                                  let (ref file, ref config) = match *<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue_ref(__v1) {
                                                                      ::types::ddlog_std::tuple2(ref file, ref config) => ((*file).clone(), (*config).clone()),
                                                                      _ => return None
                                                                  };
                                                                  let (ref object, ref property) = match *<::types::inputs::BracketAccess>::from_ddvalue_ref(__v2) {
                                                                      ::types::inputs::BracketAccess{expr_id: _, file: _, object: ::types::ddlog_std::Option::Some{x: ref object}, prop: ::types::ddlog_std::Option::Some{x: ref property}} => ((*object).clone(), (*property).clone()),
                                                                      _ => return None
                                                                  };
                                                                  Some(((::types::outputs::no_undef::ChainedWith{object: (*object).clone(), property: (*property).clone(), file: (*file).clone()})).into_ddvalue())
                                                              }
                                                              __f},
                                                              next: Box::new(None)
                                                          }
                                               },
                                               /* outputs::no_undef::ChainedWith[(outputs::no_undef::ChainedWith{.object=object, .property=property, .file=file}: outputs::no_undef::ChainedWith)] :- __Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::DotAccess[(inputs::DotAccess{.expr_id=(property: ast::ExprId), .file=(file: ast::FileId), .object=(ddlog_std::Some{.x=(object: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .prop=(_: ddlog_std::Option<ast::Spanned<ast::Name>>)}: inputs::DotAccess)]. */
                                               Rule::ArrangementRule {
                                                   description: "outputs::no_undef::ChainedWith[(outputs::no_undef::ChainedWith{.object=object, .property=property, .file=file}: outputs::no_undef::ChainedWith)] :- __Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::DotAccess[(inputs::DotAccess{.expr_id=(property: ast::ExprId), .file=(file: ast::FileId), .object=(ddlog_std::Some{.x=(object: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .prop=(_: ddlog_std::Option<ast::Spanned<ast::Name>>)}: inputs::DotAccess)].".to_string(),
                                                   arr: ( Relations::__Prefix_6 as RelId, 0),
                                                   xform: XFormArrangement::Join{
                                                              description: "__Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::DotAccess[(inputs::DotAccess{.expr_id=(property: ast::ExprId), .file=(file: ast::FileId), .object=(ddlog_std::Some{.x=(object: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .prop=(_: ddlog_std::Option<ast::Spanned<ast::Name>>)}: inputs::DotAccess)]".to_string(),
                                                              ffun: None,
                                                              arrangement: (Relations::inputs_DotAccess as RelId,0),
                                                              jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                              {
                                                                  let (ref file, ref config) = match *<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue_ref(__v1) {
                                                                      ::types::ddlog_std::tuple2(ref file, ref config) => ((*file).clone(), (*config).clone()),
                                                                      _ => return None
                                                                  };
                                                                  let (ref property, ref object) = match *<::types::inputs::DotAccess>::from_ddvalue_ref(__v2) {
                                                                      ::types::inputs::DotAccess{expr_id: ref property, file: _, object: ::types::ddlog_std::Option::Some{x: ref object}, prop: _} => ((*property).clone(), (*object).clone()),
                                                                      _ => return None
                                                                  };
                                                                  Some(((::types::outputs::no_undef::ChainedWith{object: (*object).clone(), property: (*property).clone(), file: (*file).clone()})).into_ddvalue())
                                                              }
                                                              __f},
                                                              next: Box::new(None)
                                                          }
                                               },
                                               /* outputs::no_undef::ChainedWith[(outputs::no_undef::ChainedWith{.object=object, .property=property, .file=file}: outputs::no_undef::ChainedWith)] :- __Prefix_6[((file: ast::FileId), (config: config::Config))], outputs::no_undef::ChainedWith[(outputs::no_undef::ChainedWith{.object=(object: ast::ExprId), .property=(interum: ast::ExprId), .file=(file: ast::FileId)}: outputs::no_undef::ChainedWith)], outputs::no_undef::ChainedWith[(outputs::no_undef::ChainedWith{.object=(interum: ast::ExprId), .property=(property: ast::ExprId), .file=(file: ast::FileId)}: outputs::no_undef::ChainedWith)]. */
                                               Rule::ArrangementRule {
                                                   description: "outputs::no_undef::ChainedWith[(outputs::no_undef::ChainedWith{.object=object, .property=property, .file=file}: outputs::no_undef::ChainedWith)] :- __Prefix_6[((file: ast::FileId), (config: config::Config))], outputs::no_undef::ChainedWith[(outputs::no_undef::ChainedWith{.object=(object: ast::ExprId), .property=(interum: ast::ExprId), .file=(file: ast::FileId)}: outputs::no_undef::ChainedWith)], outputs::no_undef::ChainedWith[(outputs::no_undef::ChainedWith{.object=(interum: ast::ExprId), .property=(property: ast::ExprId), .file=(file: ast::FileId)}: outputs::no_undef::ChainedWith)].".to_string(),
                                                   arr: ( Relations::__Prefix_6 as RelId, 0),
                                                   xform: XFormArrangement::Join{
                                                              description: "__Prefix_6[((file: ast::FileId), (config: config::Config))], outputs::no_undef::ChainedWith[(outputs::no_undef::ChainedWith{.object=(object: ast::ExprId), .property=(interum: ast::ExprId), .file=(file: ast::FileId)}: outputs::no_undef::ChainedWith)]".to_string(),
                                                              ffun: None,
                                                              arrangement: (Relations::outputs_no_undef_ChainedWith as RelId,0),
                                                              jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                              {
                                                                  let (ref file, ref config) = match *<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue_ref(__v1) {
                                                                      ::types::ddlog_std::tuple2(ref file, ref config) => ((*file).clone(), (*config).clone()),
                                                                      _ => return None
                                                                  };
                                                                  let (ref object, ref interum) = match *<::types::outputs::no_undef::ChainedWith>::from_ddvalue_ref(__v2) {
                                                                      ::types::outputs::no_undef::ChainedWith{object: ref object, property: ref interum, file: _} => ((*object).clone(), (*interum).clone()),
                                                                      _ => return None
                                                                  };
                                                                  Some((::types::ddlog_std::tuple3((*file).clone(), (*object).clone(), (*interum).clone())).into_ddvalue())
                                                              }
                                                              __f},
                                                              next: Box::new(Some(XFormCollection::Arrange {
                                                                                      description: "arrange __Prefix_6[((file: ast::FileId), (config: config::Config))], outputs::no_undef::ChainedWith[(outputs::no_undef::ChainedWith{.object=(object: ast::ExprId), .property=(interum: ast::ExprId), .file=(file: ast::FileId)}: outputs::no_undef::ChainedWith)] by (interum, file)" .to_string(),
                                                                                      afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                      {
                                                                                          let ::types::ddlog_std::tuple3(ref file, ref object, ref interum) = *<::types::ddlog_std::tuple3<::types::ast::FileId, ::types::ast::ExprId, ::types::ast::ExprId>>::from_ddvalue_ref( &__v );
                                                                                          Some(((::types::ddlog_std::tuple2((*interum).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple2((*file).clone(), (*object).clone())).into_ddvalue()))
                                                                                      }
                                                                                      __f},
                                                                                      next: Box::new(XFormArrangement::Join{
                                                                                                         description: "__Prefix_6[((file: ast::FileId), (config: config::Config))], outputs::no_undef::ChainedWith[(outputs::no_undef::ChainedWith{.object=(object: ast::ExprId), .property=(interum: ast::ExprId), .file=(file: ast::FileId)}: outputs::no_undef::ChainedWith)], outputs::no_undef::ChainedWith[(outputs::no_undef::ChainedWith{.object=(interum: ast::ExprId), .property=(property: ast::ExprId), .file=(file: ast::FileId)}: outputs::no_undef::ChainedWith)]".to_string(),
                                                                                                         ffun: None,
                                                                                                         arrangement: (Relations::outputs_no_undef_ChainedWith as RelId,1),
                                                                                                         jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                         {
                                                                                                             let ::types::ddlog_std::tuple2(ref file, ref object) = *<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::ast::ExprId>>::from_ddvalue_ref( __v1 );
                                                                                                             let ref property = match *<::types::outputs::no_undef::ChainedWith>::from_ddvalue_ref(__v2) {
                                                                                                                 ::types::outputs::no_undef::ChainedWith{object: _, property: ref property, file: _} => (*property).clone(),
                                                                                                                 _ => return None
                                                                                                             };
                                                                                                             Some(((::types::outputs::no_undef::ChainedWith{object: (*object).clone(), property: (*property).clone(), file: (*file).clone()})).into_ddvalue())
                                                                                                         }
                                                                                                         __f},
                                                                                                         next: Box::new(None)
                                                                                                     })
                                                                                  }))
                                                          }
                                               }],
                                           arrangements: vec![
                                               Arrangement::Map{
                                                  name: r###"(outputs::no_undef::ChainedWith{.object=(_: ast::ExprId), .property=(_: ast::ExprId), .file=(_0: ast::FileId)}: outputs::no_undef::ChainedWith) /*join*/"###.to_string(),
                                                   afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                   {
                                                       let __cloned = __v.clone();
                                                       match < ::types::outputs::no_undef::ChainedWith>::from_ddvalue(__v) {
                                                           ::types::outputs::no_undef::ChainedWith{object: _, property: _, file: ref _0} => Some(((*_0).clone()).into_ddvalue()),
                                                           _ => None
                                                       }.map(|x|(x,__cloned))
                                                   }
                                                   __f},
                                                   queryable: false
                                               },
                                               Arrangement::Map{
                                                  name: r###"(outputs::no_undef::ChainedWith{.object=(_0: ast::ExprId), .property=(_: ast::ExprId), .file=(_1: ast::FileId)}: outputs::no_undef::ChainedWith) /*join*/"###.to_string(),
                                                   afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                   {
                                                       let __cloned = __v.clone();
                                                       match < ::types::outputs::no_undef::ChainedWith>::from_ddvalue(__v) {
                                                           ::types::outputs::no_undef::ChainedWith{object: ref _0, property: _, file: ref _1} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                           _ => None
                                                       }.map(|x|(x,__cloned))
                                                   }
                                                   __f},
                                                   queryable: false
                                               },
                                               Arrangement::Set{
                                                   name: r###"(outputs::no_undef::ChainedWith{.object=(_: ast::ExprId), .property=(_0: ast::ExprId), .file=(_1: ast::FileId)}: outputs::no_undef::ChainedWith) /*antijoin*/"###.to_string(),
                                                   fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                   {
                                                       match < ::types::outputs::no_undef::ChainedWith>::from_ddvalue(__v) {
                                                           ::types::outputs::no_undef::ChainedWith{object: _, property: ref _0, file: ref _1} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                           _ => None
                                                       }
                                                   }
                                                   __f},
                                                   distinct: true
                                               }],
                                           change_cb:    None
                                       };
    let __Prefix_7 = Relation {
                         name:         "__Prefix_7".to_string(),
                         input:        false,
                         distinct:     false,
                         caching_mode: CachingMode::Set,
                         key_func:     None,
                         id:           Relations::__Prefix_7 as RelId,
                         rules:        vec![
                             /* __Prefix_7[((file: ast::FileId), (config: config::Config))] :- inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(_: ast::ScopeId), .config=(config: config::Config)}: inputs::File)], (config::no_use_before_def_enabled(config)). */
                             Rule::CollectionRule {
                                 description: "__Prefix_7[((file: ast::FileId), (config: config::Config))] :- inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(_: ast::ScopeId), .config=(config: config::Config)}: inputs::File)], (config::no_use_before_def_enabled(config)).".to_string(),
                                 rel: Relations::inputs_File as RelId,
                                 xform: Some(XFormCollection::FilterMap{
                                                 description: "head of __Prefix_7[((file: ast::FileId), (config: config::Config))] :- inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(_: ast::ScopeId), .config=(config: config::Config)}: inputs::File)], (config::no_use_before_def_enabled(config))." .to_string(),
                                                 fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                 {
                                                     let (ref file, ref config) = match *<::types::inputs::File>::from_ddvalue_ref(&__v) {
                                                         ::types::inputs::File{id: ref file, kind: _, top_level_scope: _, config: ref config} => ((*file).clone(), (*config).clone()),
                                                         _ => return None
                                                     };
                                                     if !::types::config::no_use_before_def_enabled(config) {return None;};
                                                     Some((::types::ddlog_std::tuple2((*file).clone(), (*config).clone())).into_ddvalue())
                                                 }
                                                 __f},
                                                 next: Box::new(None)
                                             })
                             }],
                         arrangements: vec![
                             Arrangement::Map{
                                name: r###"((_0: ast::FileId), (_: config::Config)) /*join*/"###.to_string(),
                                 afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                 {
                                     let __cloned = __v.clone();
                                     match < ::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue(__v) {
                                         ::types::ddlog_std::tuple2(ref _0, _) => Some(((*_0).clone()).into_ddvalue()),
                                         _ => None
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             }],
                         change_cb:    None
                     };
    let __Prefix_8 = Relation {
                         name:         "__Prefix_8".to_string(),
                         input:        false,
                         distinct:     false,
                         caching_mode: CachingMode::Set,
                         key_func:     None,
                         id:           Relations::__Prefix_8 as RelId,
                         rules:        vec![
                             /* __Prefix_8[((file: ast::FileId), (config: config::Config))] :- inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(_: ast::ScopeId), .config=(config: config::Config)}: inputs::File)], (config::no_unused_labels_enabled(config)). */
                             Rule::CollectionRule {
                                 description: "__Prefix_8[((file: ast::FileId), (config: config::Config))] :- inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(_: ast::ScopeId), .config=(config: config::Config)}: inputs::File)], (config::no_unused_labels_enabled(config)).".to_string(),
                                 rel: Relations::inputs_File as RelId,
                                 xform: Some(XFormCollection::FilterMap{
                                                 description: "head of __Prefix_8[((file: ast::FileId), (config: config::Config))] :- inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(_: ast::ScopeId), .config=(config: config::Config)}: inputs::File)], (config::no_unused_labels_enabled(config))." .to_string(),
                                                 fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                 {
                                                     let (ref file, ref config) = match *<::types::inputs::File>::from_ddvalue_ref(&__v) {
                                                         ::types::inputs::File{id: ref file, kind: _, top_level_scope: _, config: ref config} => ((*file).clone(), (*config).clone()),
                                                         _ => return None
                                                     };
                                                     if !::types::config::no_unused_labels_enabled(config) {return None;};
                                                     Some((::types::ddlog_std::tuple2((*file).clone(), (*config).clone())).into_ddvalue())
                                                 }
                                                 __f},
                                                 next: Box::new(None)
                                             })
                             }],
                         arrangements: vec![
                             Arrangement::Map{
                                name: r###"((_0: ast::FileId), (_: config::Config)) /*join*/"###.to_string(),
                                 afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                 {
                                     let __cloned = __v.clone();
                                     match < ::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue(__v) {
                                         ::types::ddlog_std::tuple2(ref _0, _) => Some(((*_0).clone()).into_ddvalue()),
                                         _ => None
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             }],
                         change_cb:    None
                     };
    let __Prefix_9 = Relation {
                         name:         "__Prefix_9".to_string(),
                         input:        false,
                         distinct:     false,
                         caching_mode: CachingMode::Set,
                         key_func:     None,
                         id:           Relations::__Prefix_9 as RelId,
                         rules:        vec![
                             /* __Prefix_9[((file: ast::FileId), (config: config::Config))] :- inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(_: ast::ScopeId), .config=(config: config::Config)}: inputs::File)], ((config::no_undef_enabled(config)) or (config::no_typeof_undef_enabled(config))). */
                             Rule::CollectionRule {
                                 description: "__Prefix_9[((file: ast::FileId), (config: config::Config))] :- inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(_: ast::ScopeId), .config=(config: config::Config)}: inputs::File)], ((config::no_undef_enabled(config)) or (config::no_typeof_undef_enabled(config))).".to_string(),
                                 rel: Relations::inputs_File as RelId,
                                 xform: Some(XFormCollection::FilterMap{
                                                 description: "head of __Prefix_9[((file: ast::FileId), (config: config::Config))] :- inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(_: ast::ScopeId), .config=(config: config::Config)}: inputs::File)], ((config::no_undef_enabled(config)) or (config::no_typeof_undef_enabled(config)))." .to_string(),
                                                 fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                 {
                                                     let (ref file, ref config) = match *<::types::inputs::File>::from_ddvalue_ref(&__v) {
                                                         ::types::inputs::File{id: ref file, kind: _, top_level_scope: _, config: ref config} => ((*file).clone(), (*config).clone()),
                                                         _ => return None
                                                     };
                                                     if !(::types::config::no_undef_enabled(config) || ::types::config::no_typeof_undef_enabled(config)) {return None;};
                                                     Some((::types::ddlog_std::tuple2((*file).clone(), (*config).clone())).into_ddvalue())
                                                 }
                                                 __f},
                                                 next: Box::new(None)
                                             })
                             }],
                         arrangements: vec![
                             Arrangement::Map{
                                name: r###"((_0: ast::FileId), (_: config::Config)) /*join*/"###.to_string(),
                                 afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                 {
                                     let __cloned = __v.clone();
                                     match < ::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue(__v) {
                                         ::types::ddlog_std::tuple2(ref _0, _) => Some(((*_0).clone()).into_ddvalue()),
                                         _ => None
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             }],
                         change_cb:    None
                     };
    let inputs_FileExport = Relation {
                                name:         "inputs::FileExport".to_string(),
                                input:        true,
                                distinct:     false,
                                caching_mode: CachingMode::Set,
                                key_func:     None,
                                id:           Relations::inputs_FileExport as RelId,
                                rules:        vec![
                                    ],
                                arrangements: vec![
                                    ],
                                change_cb:    None
                            };
    let inputs_For = Relation {
                         name:         "inputs::For".to_string(),
                         input:        true,
                         distinct:     false,
                         caching_mode: CachingMode::Set,
                         key_func:     None,
                         id:           Relations::inputs_For as RelId,
                         rules:        vec![
                             ],
                         arrangements: vec![
                             ],
                         change_cb:    None
                     };
    let inputs_ForIn = Relation {
                           name:         "inputs::ForIn".to_string(),
                           input:        true,
                           distinct:     false,
                           caching_mode: CachingMode::Set,
                           key_func:     None,
                           id:           Relations::inputs_ForIn as RelId,
                           rules:        vec![
                               ],
                           arrangements: vec![
                               ],
                           change_cb:    None
                       };
    let inputs_ForOf = Relation {
                           name:         "inputs::ForOf".to_string(),
                           input:        true,
                           distinct:     false,
                           caching_mode: CachingMode::Set,
                           key_func:     None,
                           id:           Relations::inputs_ForOf as RelId,
                           rules:        vec![
                               ],
                           arrangements: vec![
                               ],
                           change_cb:    None
                       };
    let inputs_Function = Relation {
                              name:         "inputs::Function".to_string(),
                              input:        true,
                              distinct:     false,
                              caching_mode: CachingMode::Set,
                              key_func:     Some((|__key: &DDValue| {
                                                     let ref f = *<::types::inputs::Function>::from_ddvalue_ref(__key);
                                                     (::types::ddlog_std::tuple2(f.id.clone(), f.file.clone())).into_ddvalue()
                                                 })),
                              id:           Relations::inputs_Function as RelId,
                              rules:        vec![
                                  ],
                              arrangements: vec![
                                  Arrangement::Map{
                                     name: r###"(inputs::Function{.id=(_0: ast::FuncId), .file=(_1: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(_: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(_: ast::ScopeId), .body=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Function) /*join*/"###.to_string(),
                                      afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                      {
                                          let __cloned = __v.clone();
                                          match < ::types::inputs::Function>::from_ddvalue(__v) {
                                              ::types::inputs::Function{id: ref _0, file: ref _1, name: ::types::ddlog_std::Option::Some{x: ::types::ast::Spanned{data: _, span: _}}, scope: _, body: _, exported: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                              _ => None
                                          }.map(|x|(x,__cloned))
                                      }
                                      __f},
                                      queryable: false
                                  },
                                  Arrangement::Map{
                                     name: r###"(inputs::Function{.id=(_: ast::FuncId), .file=(_1: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(_: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(_0: ast::ScopeId), .body=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Function) /*join*/"###.to_string(),
                                      afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                      {
                                          let __cloned = __v.clone();
                                          match < ::types::inputs::Function>::from_ddvalue(__v) {
                                              ::types::inputs::Function{id: _, file: ref _1, name: ::types::ddlog_std::Option::Some{x: ::types::ast::Spanned{data: _, span: _}}, scope: ref _0, body: _, exported: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                              _ => None
                                          }.map(|x|(x,__cloned))
                                      }
                                      __f},
                                      queryable: false
                                  },
                                  Arrangement::Map{
                                     name: r###"(inputs::Function{.id=(_0: ast::FuncId), .file=(_1: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(_: ast::ScopeId), .body=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Function) /*join*/"###.to_string(),
                                      afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                      {
                                          let __cloned = __v.clone();
                                          match < ::types::inputs::Function>::from_ddvalue(__v) {
                                              ::types::inputs::Function{id: ref _0, file: ref _1, name: _, scope: _, body: _, exported: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                              _ => None
                                          }.map(|x|(x,__cloned))
                                      }
                                      __f},
                                      queryable: false
                                  }],
                              change_cb:    None
                          };
    let inputs_FunctionArg = Relation {
                                 name:         "inputs::FunctionArg".to_string(),
                                 input:        true,
                                 distinct:     false,
                                 caching_mode: CachingMode::Set,
                                 key_func:     None,
                                 id:           Relations::inputs_FunctionArg as RelId,
                                 rules:        vec![
                                     ],
                                 arrangements: vec![
                                     Arrangement::Map{
                                        name: r###"(inputs::FunctionArg{.parent_func=(_0: ast::FuncId), .file=(_1: ast::FileId), .pattern=(_: internment::Intern<ast::Pattern>), .implicit=(_: bool)}: inputs::FunctionArg) /*join*/"###.to_string(),
                                         afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                         {
                                             let __cloned = __v.clone();
                                             match < ::types::inputs::FunctionArg>::from_ddvalue(__v) {
                                                 ::types::inputs::FunctionArg{parent_func: ref _0, file: ref _1, pattern: _, implicit: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                 _ => None
                                             }.map(|x|(x,__cloned))
                                         }
                                         __f},
                                         queryable: false
                                     }],
                                 change_cb:    None
                             };
    let inputs_If = Relation {
                        name:         "inputs::If".to_string(),
                        input:        true,
                        distinct:     false,
                        caching_mode: CachingMode::Set,
                        key_func:     None,
                        id:           Relations::inputs_If as RelId,
                        rules:        vec![
                            ],
                        arrangements: vec![
                            ],
                        change_cb:    None
                    };
    let inputs_ImplicitGlobal = Relation {
                                    name:         "inputs::ImplicitGlobal".to_string(),
                                    input:        true,
                                    distinct:     false,
                                    caching_mode: CachingMode::Set,
                                    key_func:     None,
                                    id:           Relations::inputs_ImplicitGlobal as RelId,
                                    rules:        vec![
                                        ],
                                    arrangements: vec![
                                        Arrangement::Map{
                                           name: r###"(inputs::ImplicitGlobal{.id=(_: ast::GlobalId), .name=(_: internment::Intern<string>), .privileges=(_: ast::GlobalPriv)}: inputs::ImplicitGlobal) /*join*/"###.to_string(),
                                            afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                            {
                                                let __cloned = __v.clone();
                                                match < ::types::inputs::ImplicitGlobal>::from_ddvalue(__v) {
                                                    ::types::inputs::ImplicitGlobal{id: _, name: _, privileges: _} => Some((()).into_ddvalue()),
                                                    _ => None
                                                }.map(|x|(x,__cloned))
                                            }
                                            __f},
                                            queryable: false
                                        }],
                                    change_cb:    None
                                };
    let inputs_ImportDecl = Relation {
                                name:         "inputs::ImportDecl".to_string(),
                                input:        true,
                                distinct:     false,
                                caching_mode: CachingMode::Set,
                                key_func:     None,
                                id:           Relations::inputs_ImportDecl as RelId,
                                rules:        vec![
                                    ],
                                arrangements: vec![
                                    Arrangement::Map{
                                       name: r###"(inputs::ImportDecl{.id=(_: ast::ImportId), .file=(_0: ast::FileId), .clause=(_: ast::ImportClause)}: inputs::ImportDecl) /*join*/"###.to_string(),
                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                        {
                                            let __cloned = __v.clone();
                                            match < ::types::inputs::ImportDecl>::from_ddvalue(__v) {
                                                ::types::inputs::ImportDecl{id: _, file: ref _0, clause: _} => Some(((*_0).clone()).into_ddvalue()),
                                                _ => None
                                            }.map(|x|(x,__cloned))
                                        }
                                        __f},
                                        queryable: false
                                    }],
                                change_cb:    None
                            };
    let inputs_InlineFunc = Relation {
                                name:         "inputs::InlineFunc".to_string(),
                                input:        true,
                                distinct:     false,
                                caching_mode: CachingMode::Set,
                                key_func:     None,
                                id:           Relations::inputs_InlineFunc as RelId,
                                rules:        vec![
                                    ],
                                arrangements: vec![
                                    Arrangement::Map{
                                       name: r###"(inputs::InlineFunc{.expr_id=(_: ast::ExprId), .file=(_1: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(ddlog_std::Some{.x=(_0: ast::StmtId)}: ddlog_std::Option<ast::StmtId>)}: inputs::InlineFunc) /*join*/"###.to_string(),
                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                        {
                                            let __cloned = __v.clone();
                                            match < ::types::inputs::InlineFunc>::from_ddvalue(__v) {
                                                ::types::inputs::InlineFunc{expr_id: _, file: ref _1, name: _, body: ::types::ddlog_std::Option::Some{x: ref _0}} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                _ => None
                                            }.map(|x|(x,__cloned))
                                        }
                                        __f},
                                        queryable: false
                                    },
                                    Arrangement::Map{
                                       name: r###"(inputs::InlineFunc{.expr_id=(_: ast::ExprId), .file=(_1: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(_: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(ddlog_std::Some{.x=(_0: ast::StmtId)}: ddlog_std::Option<ast::StmtId>)}: inputs::InlineFunc) /*join*/"###.to_string(),
                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                        {
                                            let __cloned = __v.clone();
                                            match < ::types::inputs::InlineFunc>::from_ddvalue(__v) {
                                                ::types::inputs::InlineFunc{expr_id: _, file: ref _1, name: ::types::ddlog_std::Option::Some{x: ::types::ast::Spanned{data: _, span: _}}, body: ::types::ddlog_std::Option::Some{x: ref _0}} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                _ => None
                                            }.map(|x|(x,__cloned))
                                        }
                                        __f},
                                        queryable: false
                                    },
                                    Arrangement::Map{
                                       name: r###"(inputs::InlineFunc{.expr_id=(_0: ast::ExprId), .file=(_1: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(ddlog_std::Some{.x=(_: ast::StmtId)}: ddlog_std::Option<ast::StmtId>)}: inputs::InlineFunc) /*join*/"###.to_string(),
                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                        {
                                            let __cloned = __v.clone();
                                            match < ::types::inputs::InlineFunc>::from_ddvalue(__v) {
                                                ::types::inputs::InlineFunc{expr_id: ref _0, file: ref _1, name: _, body: ::types::ddlog_std::Option::Some{x: _}} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                _ => None
                                            }.map(|x|(x,__cloned))
                                        }
                                        __f},
                                        queryable: false
                                    }],
                                change_cb:    None
                            };
    let inputs_InlineFuncParam = Relation {
                                     name:         "inputs::InlineFuncParam".to_string(),
                                     input:        true,
                                     distinct:     false,
                                     caching_mode: CachingMode::Set,
                                     key_func:     None,
                                     id:           Relations::inputs_InlineFuncParam as RelId,
                                     rules:        vec![
                                         ],
                                     arrangements: vec![
                                         Arrangement::Map{
                                            name: r###"(inputs::InlineFuncParam{.expr_id=(_0: ast::ExprId), .file=(_1: ast::FileId), .param=(_: internment::Intern<ast::Pattern>)}: inputs::InlineFuncParam) /*join*/"###.to_string(),
                                             afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                             {
                                                 let __cloned = __v.clone();
                                                 match < ::types::inputs::InlineFuncParam>::from_ddvalue(__v) {
                                                     ::types::inputs::InlineFuncParam{expr_id: ref _0, file: ref _1, param: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                     _ => None
                                                 }.map(|x|(x,__cloned))
                                             }
                                             __f},
                                             queryable: false
                                         }],
                                     change_cb:    None
                                 };
    let inputs_InputScope = Relation {
                                name:         "inputs::InputScope".to_string(),
                                input:        true,
                                distinct:     false,
                                caching_mode: CachingMode::Set,
                                key_func:     None,
                                id:           Relations::inputs_InputScope as RelId,
                                rules:        vec![
                                    ],
                                arrangements: vec![
                                    Arrangement::Map{
                                       name: r###"(inputs::InputScope{.parent=(_: ast::ScopeId), .child=(_0: ast::ScopeId), .file=(_1: ast::FileId)}: inputs::InputScope) /*join*/"###.to_string(),
                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                        {
                                            let __cloned = __v.clone();
                                            match < ::types::inputs::InputScope>::from_ddvalue(__v) {
                                                ::types::inputs::InputScope{parent: _, child: ref _0, file: ref _1} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                _ => None
                                            }.map(|x|(x,__cloned))
                                        }
                                        __f},
                                        queryable: false
                                    },
                                    Arrangement::Map{
                                       name: r###"(inputs::InputScope{.parent=(_0: ast::ScopeId), .child=(_: ast::ScopeId), .file=(_1: ast::FileId)}: inputs::InputScope) /*join*/"###.to_string(),
                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                        {
                                            let __cloned = __v.clone();
                                            match < ::types::inputs::InputScope>::from_ddvalue(__v) {
                                                ::types::inputs::InputScope{parent: ref _0, child: _, file: ref _1} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                _ => None
                                            }.map(|x|(x,__cloned))
                                        }
                                        __f},
                                        queryable: false
                                    },
                                    Arrangement::Map{
                                       name: r###"(inputs::InputScope{.parent=(_: ast::ScopeId), .child=_0, .file=_1}: inputs::InputScope) /*join*/"###.to_string(),
                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                        {
                                            let __cloned = __v.clone();
                                            match < ::types::inputs::InputScope>::from_ddvalue(__v) {
                                                ::types::inputs::InputScope{parent: _, child: ref _0, file: ref _1} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                _ => None
                                            }.map(|x|(x,__cloned))
                                        }
                                        __f},
                                        queryable: true
                                    },
                                    Arrangement::Map{
                                       name: r###"(inputs::InputScope{.parent=(_: ast::ScopeId), .child=(_: ast::ScopeId), .file=_0}: inputs::InputScope) /*join*/"###.to_string(),
                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                        {
                                            let __cloned = __v.clone();
                                            match < ::types::inputs::InputScope>::from_ddvalue(__v) {
                                                ::types::inputs::InputScope{parent: _, child: _, file: ref _0} => Some(((*_0).clone()).into_ddvalue()),
                                                _ => None
                                            }.map(|x|(x,__cloned))
                                        }
                                        __f},
                                        queryable: true
                                    },
                                    Arrangement::Map{
                                       name: r###"(inputs::InputScope{.parent=_0, .child=(_: ast::ScopeId), .file=_1}: inputs::InputScope) /*join*/"###.to_string(),
                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                        {
                                            let __cloned = __v.clone();
                                            match < ::types::inputs::InputScope>::from_ddvalue(__v) {
                                                ::types::inputs::InputScope{parent: ref _0, child: _, file: ref _1} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                _ => None
                                            }.map(|x|(x,__cloned))
                                        }
                                        __f},
                                        queryable: true
                                    }],
                                change_cb:    None
                            };
    let inputs_Label = Relation {
                           name:         "inputs::Label".to_string(),
                           input:        true,
                           distinct:     false,
                           caching_mode: CachingMode::Set,
                           key_func:     None,
                           id:           Relations::inputs_Label as RelId,
                           rules:        vec![
                               ],
                           arrangements: vec![
                               Arrangement::Map{
                                  name: r###"(inputs::Label{.stmt_id=(_: ast::StmtId), .file=(_0: ast::FileId), .name=(ddlog_std::Some{.x=(_: ast::Spanned<ast::Name>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(_: ddlog_std::Option<ast::StmtId>), .body_scope=(_: ast::ScopeId)}: inputs::Label) /*join*/"###.to_string(),
                                   afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                   {
                                       let __cloned = __v.clone();
                                       match < ::types::inputs::Label>::from_ddvalue(__v) {
                                           ::types::inputs::Label{stmt_id: _, file: ref _0, name: ::types::ddlog_std::Option::Some{x: _}, body: _, body_scope: _} => Some(((*_0).clone()).into_ddvalue()),
                                           _ => None
                                       }.map(|x|(x,__cloned))
                                   }
                                   __f},
                                   queryable: false
                               },
                               Arrangement::Map{
                                  name: r###"(inputs::Label{.stmt_id=(_: ast::StmtId), .file=(_0: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(_: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(_: ddlog_std::Option<ast::StmtId>), .body_scope=(_: ast::ScopeId)}: inputs::Label) /*join*/"###.to_string(),
                                   afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                   {
                                       let __cloned = __v.clone();
                                       match < ::types::inputs::Label>::from_ddvalue(__v) {
                                           ::types::inputs::Label{stmt_id: _, file: ref _0, name: ::types::ddlog_std::Option::Some{x: ::types::ast::Spanned{data: _, span: _}}, body: _, body_scope: _} => Some(((*_0).clone()).into_ddvalue()),
                                           _ => None
                                       }.map(|x|(x,__cloned))
                                   }
                                   __f},
                                   queryable: false
                               }],
                           change_cb:    None
                       };
    let __Prefix_2 = Relation {
                         name:         "__Prefix_2".to_string(),
                         input:        false,
                         distinct:     false,
                         caching_mode: CachingMode::Set,
                         key_func:     None,
                         id:           Relations::__Prefix_2 as RelId,
                         rules:        vec![
                             /* __Prefix_2[((file: ast::FileId), (config: config::Config), (stmt: ast::StmtId), (name: ast::Spanned<ast::Name>), (body_scope: ast::ScopeId))] :- __Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Label[(inputs::Label{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(name: ast::Spanned<ast::Name>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(_: ddlog_std::Option<ast::StmtId>), .body_scope=(body_scope: ast::ScopeId)}: inputs::Label)]. */
                             Rule::ArrangementRule {
                                 description: "__Prefix_2[((file: ast::FileId), (config: config::Config), (stmt: ast::StmtId), (name: ast::Spanned<ast::Name>), (body_scope: ast::ScopeId))] :- __Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Label[(inputs::Label{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(name: ast::Spanned<ast::Name>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(_: ddlog_std::Option<ast::StmtId>), .body_scope=(body_scope: ast::ScopeId)}: inputs::Label)].".to_string(),
                                 arr: ( Relations::__Prefix_8 as RelId, 0),
                                 xform: XFormArrangement::Join{
                                            description: "__Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Label[(inputs::Label{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(name: ast::Spanned<ast::Name>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(_: ddlog_std::Option<ast::StmtId>), .body_scope=(body_scope: ast::ScopeId)}: inputs::Label)]".to_string(),
                                            ffun: None,
                                            arrangement: (Relations::inputs_Label as RelId,0),
                                            jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                            {
                                                let (ref file, ref config) = match *<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue_ref(__v1) {
                                                    ::types::ddlog_std::tuple2(ref file, ref config) => ((*file).clone(), (*config).clone()),
                                                    _ => return None
                                                };
                                                let (ref stmt, ref name, ref body_scope) = match *<::types::inputs::Label>::from_ddvalue_ref(__v2) {
                                                    ::types::inputs::Label{stmt_id: ref stmt, file: _, name: ::types::ddlog_std::Option::Some{x: ref name}, body: _, body_scope: ref body_scope} => ((*stmt).clone(), (*name).clone(), (*body_scope).clone()),
                                                    _ => return None
                                                };
                                                Some((::types::ddlog_std::tuple5((*file).clone(), (*config).clone(), (*stmt).clone(), (*name).clone(), (*body_scope).clone())).into_ddvalue())
                                            }
                                            __f},
                                            next: Box::new(None)
                                        }
                             }],
                         arrangements: vec![
                             Arrangement::Map{
                                name: r###"((_0: ast::FileId), (_: config::Config), (_: ast::StmtId), ((ast::Spanned{.data=_1, .span=_}: ast::Spanned{data: ast::Name, span: ast::Span}): ast::Spanned<ast::Name>), (_2: ast::ScopeId)) /*join*/"###.to_string(),
                                 afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                 {
                                     let __cloned = __v.clone();
                                     match < ::types::ddlog_std::tuple5<::types::ast::FileId, ::types::config::Config, ::types::ast::StmtId, ::types::ast::Spanned<::types::internment::Intern<String>>, ::types::ast::ScopeId>>::from_ddvalue(__v) {
                                         ::types::ddlog_std::tuple5(ref _0, _, _, ::types::ast::Spanned{data: ref _1, span: _}, ref _2) => Some((::types::ddlog_std::tuple3((*_0).clone(), (*_1).clone(), (*_2).clone())).into_ddvalue()),
                                         _ => None
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             },
                             Arrangement::Map{
                                name: r###"((_1: ast::FileId), (_: config::Config), (_: ast::StmtId), (_: ast::Spanned<ast::Name>), (_0: ast::ScopeId)) /*join*/"###.to_string(),
                                 afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                 {
                                     let __cloned = __v.clone();
                                     match < ::types::ddlog_std::tuple5<::types::ast::FileId, ::types::config::Config, ::types::ast::StmtId, ::types::ast::Spanned<::types::internment::Intern<String>>, ::types::ast::ScopeId>>::from_ddvalue(__v) {
                                         ::types::ddlog_std::tuple5(ref _1, _, _, _, ref _0) => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                         _ => None
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             }],
                         change_cb:    None
                     };
    let inputs_LetDecl = Relation {
                             name:         "inputs::LetDecl".to_string(),
                             input:        true,
                             distinct:     false,
                             caching_mode: CachingMode::Set,
                             key_func:     None,
                             id:           Relations::inputs_LetDecl as RelId,
                             rules:        vec![
                                 ],
                             arrangements: vec![
                                 Arrangement::Map{
                                    name: r###"(inputs::LetDecl{.stmt_id=(_0: ast::StmtId), .file=(_1: ast::FileId), .pattern=(ddlog_std::Some{.x=(_: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: inputs::LetDecl) /*join*/"###.to_string(),
                                     afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                     {
                                         let __cloned = __v.clone();
                                         match < ::types::inputs::LetDecl>::from_ddvalue(__v) {
                                             ::types::inputs::LetDecl{stmt_id: ref _0, file: ref _1, pattern: ::types::ddlog_std::Option::Some{x: _}, value: _, exported: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                             _ => None
                                         }.map(|x|(x,__cloned))
                                     }
                                     __f},
                                     queryable: false
                                 }],
                             change_cb:    None
                         };
    let inputs_NameRef = Relation {
                             name:         "inputs::NameRef".to_string(),
                             input:        true,
                             distinct:     false,
                             caching_mode: CachingMode::Set,
                             key_func:     None,
                             id:           Relations::inputs_NameRef as RelId,
                             rules:        vec![
                                 ],
                             arrangements: vec![
                                 Arrangement::Map{
                                    name: r###"(inputs::NameRef{.expr_id=(_0: ast::ExprId), .file=(_1: ast::FileId), .value=(_: internment::Intern<string>)}: inputs::NameRef) /*join*/"###.to_string(),
                                     afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                     {
                                         let __cloned = __v.clone();
                                         match < ::types::inputs::NameRef>::from_ddvalue(__v) {
                                             ::types::inputs::NameRef{expr_id: ref _0, file: ref _1, value: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                             _ => None
                                         }.map(|x|(x,__cloned))
                                     }
                                     __f},
                                     queryable: false
                                 },
                                 Arrangement::Map{
                                    name: r###"(inputs::NameRef{.expr_id=(_: ast::ExprId), .file=(_0: ast::FileId), .value=(_: internment::Intern<string>)}: inputs::NameRef) /*join*/"###.to_string(),
                                     afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                     {
                                         let __cloned = __v.clone();
                                         match < ::types::inputs::NameRef>::from_ddvalue(__v) {
                                             ::types::inputs::NameRef{expr_id: _, file: ref _0, value: _} => Some(((*_0).clone()).into_ddvalue()),
                                             _ => None
                                         }.map(|x|(x,__cloned))
                                     }
                                     __f},
                                     queryable: false
                                 }],
                             change_cb:    None
                         };
    let name_in_scope_NameOccursInScope = Relation {
                                              name:         "name_in_scope::NameOccursInScope".to_string(),
                                              input:        false,
                                              distinct:     false,
                                              caching_mode: CachingMode::Set,
                                              key_func:     None,
                                              id:           Relations::name_in_scope_NameOccursInScope as RelId,
                                              rules:        vec![
                                                  /* name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=name, .scope=scope, .file=file}: name_in_scope::NameOccursInScope)] :- inputs::NameRef[(inputs::NameRef{.expr_id=(id: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(id: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression)]. */
                                                  Rule::ArrangementRule {
                                                      description: "name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=name, .scope=scope, .file=file}: name_in_scope::NameOccursInScope)] :- inputs::NameRef[(inputs::NameRef{.expr_id=(id: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(id: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression)].".to_string(),
                                                      arr: ( Relations::inputs_NameRef as RelId, 0),
                                                      xform: XFormArrangement::Join{
                                                                 description: "inputs::NameRef[(inputs::NameRef{.expr_id=(id: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(id: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression)]".to_string(),
                                                                 ffun: None,
                                                                 arrangement: (Relations::inputs_Expression as RelId,0),
                                                                 jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                 {
                                                                     let (ref id, ref file, ref name) = match *<::types::inputs::NameRef>::from_ddvalue_ref(__v1) {
                                                                         ::types::inputs::NameRef{expr_id: ref id, file: ref file, value: ref name} => ((*id).clone(), (*file).clone(), (*name).clone()),
                                                                         _ => return None
                                                                     };
                                                                     let ref scope = match *<::types::inputs::Expression>::from_ddvalue_ref(__v2) {
                                                                         ::types::inputs::Expression{id: _, file: _, kind: _, scope: ref scope, span: _} => (*scope).clone(),
                                                                         _ => return None
                                                                     };
                                                                     Some(((::types::name_in_scope::NameOccursInScope{name: (*name).clone(), scope: (*scope).clone(), file: (*file).clone()})).into_ddvalue())
                                                                 }
                                                                 __f},
                                                                 next: Box::new(None)
                                                             }
                                                  },
                                                  /* name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=name, .scope=scope, .file=file}: name_in_scope::NameOccursInScope)] :- inputs::Assign[(inputs::Assign{.expr_id=(id: ast::ExprId), .file=(file: ast::FileId), .lhs=(ddlog_std::Some{.x=(ddlog_std::Left{.l=(pattern: internment::Intern<ast::Pattern>)}: ddlog_std::Either<internment::Intern<ast::Pattern>,ast::ExprId>)}: ddlog_std::Option<ddlog_std::Either<ast::IPattern,ast::ExprId>>), .rhs=(_: ddlog_std::Option<ast::ExprId>), .op=(_: ddlog_std::Option<ast::AssignOperand>)}: inputs::Assign)], inputs::Expression[(inputs::Expression{.id=(id: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression)], var name = FlatMap(((vec::map: function(ddlog_std::Vec<ast::Spanned<ast::Name>>, function(ast::Spanned<ast::Name>):internment::Intern<string>):ddlog_std::Vec<internment::Intern<string>>)(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pattern)), (function(name: ast::Spanned<ast::Name>):internment::Intern<string>{(name.data)})))). */
                                                  Rule::ArrangementRule {
                                                      description: "name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=name, .scope=scope, .file=file}: name_in_scope::NameOccursInScope)] :- inputs::Assign[(inputs::Assign{.expr_id=(id: ast::ExprId), .file=(file: ast::FileId), .lhs=(ddlog_std::Some{.x=(ddlog_std::Left{.l=(pattern: internment::Intern<ast::Pattern>)}: ddlog_std::Either<internment::Intern<ast::Pattern>,ast::ExprId>)}: ddlog_std::Option<ddlog_std::Either<ast::IPattern,ast::ExprId>>), .rhs=(_: ddlog_std::Option<ast::ExprId>), .op=(_: ddlog_std::Option<ast::AssignOperand>)}: inputs::Assign)], inputs::Expression[(inputs::Expression{.id=(id: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression)], var name = FlatMap(((vec::map: function(ddlog_std::Vec<ast::Spanned<ast::Name>>, function(ast::Spanned<ast::Name>):internment::Intern<string>):ddlog_std::Vec<internment::Intern<string>>)(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pattern)), (function(name: ast::Spanned<ast::Name>):internment::Intern<string>{(name.data)})))).".to_string(),
                                                      arr: ( Relations::inputs_Assign as RelId, 0),
                                                      xform: XFormArrangement::Join{
                                                                 description: "inputs::Assign[(inputs::Assign{.expr_id=(id: ast::ExprId), .file=(file: ast::FileId), .lhs=(ddlog_std::Some{.x=(ddlog_std::Left{.l=(pattern: internment::Intern<ast::Pattern>)}: ddlog_std::Either<internment::Intern<ast::Pattern>,ast::ExprId>)}: ddlog_std::Option<ddlog_std::Either<ast::IPattern,ast::ExprId>>), .rhs=(_: ddlog_std::Option<ast::ExprId>), .op=(_: ddlog_std::Option<ast::AssignOperand>)}: inputs::Assign)], inputs::Expression[(inputs::Expression{.id=(id: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression)]".to_string(),
                                                                 ffun: None,
                                                                 arrangement: (Relations::inputs_Expression as RelId,0),
                                                                 jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                 {
                                                                     let (ref id, ref file, ref pattern) = match *<::types::inputs::Assign>::from_ddvalue_ref(__v1) {
                                                                         ::types::inputs::Assign{expr_id: ref id, file: ref file, lhs: ::types::ddlog_std::Option::Some{x: ::types::ddlog_std::Either::Left{l: ref pattern}}, rhs: _, op: _} => ((*id).clone(), (*file).clone(), (*pattern).clone()),
                                                                         _ => return None
                                                                     };
                                                                     let ref scope = match *<::types::inputs::Expression>::from_ddvalue_ref(__v2) {
                                                                         ::types::inputs::Expression{id: _, file: _, kind: _, scope: ref scope, span: _} => (*scope).clone(),
                                                                         _ => return None
                                                                     };
                                                                     Some((::types::ddlog_std::tuple3((*file).clone(), (*pattern).clone(), (*scope).clone())).into_ddvalue())
                                                                 }
                                                                 __f},
                                                                 next: Box::new(Some(XFormCollection::FlatMap{
                                                                                         description: "inputs::Assign[(inputs::Assign{.expr_id=(id: ast::ExprId), .file=(file: ast::FileId), .lhs=(ddlog_std::Some{.x=(ddlog_std::Left{.l=(pattern: internment::Intern<ast::Pattern>)}: ddlog_std::Either<internment::Intern<ast::Pattern>,ast::ExprId>)}: ddlog_std::Option<ddlog_std::Either<ast::IPattern,ast::ExprId>>), .rhs=(_: ddlog_std::Option<ast::ExprId>), .op=(_: ddlog_std::Option<ast::AssignOperand>)}: inputs::Assign)], inputs::Expression[(inputs::Expression{.id=(id: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression)], var name = FlatMap(((vec::map: function(ddlog_std::Vec<ast::Spanned<ast::Name>>, function(ast::Spanned<ast::Name>):internment::Intern<string>):ddlog_std::Vec<internment::Intern<string>>)(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pattern)), (function(name: ast::Spanned<ast::Name>):internment::Intern<string>{(name.data)}))))" .to_string(),
                                                                                         fmfun: {fn __f(__v: DDValue) -> Option<Box<dyn Iterator<Item=DDValue>>>
                                                                                         {
                                                                                             let ::types::ddlog_std::tuple3(ref file, ref pattern, ref scope) = *<::types::ddlog_std::tuple3<::types::ast::FileId, ::types::internment::Intern<::types::ast::Pattern>, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                             let __flattened = ::types::vec::map::<::types::ast::Spanned<::types::ast::Name>, ::types::internment::Intern<String>>((&::types::ast::bound_vars_internment_Intern__ast_Pattern_ddlog_std_Vec__ast_Spanned__internment_Intern____Stringval(pattern)), (&{
                                                                                                                                                                                                                                                                                                                                                         (Box::new(closure::ClosureImpl{
                                                                                                                                                                                                                                                                                                                                                             description: "(function(name: ast::Spanned<ast::Name>):internment::Intern<string>{(name.data)})",
                                                                                                                                                                                                                                                                                                                                                             captured: (),
                                                                                                                                                                                                                                                                                                                                                             f: {
                                                                                                                                                                                                                                                                                                                                                                    fn __f(__args:*const ::types::ast::Spanned<::types::ast::Name>, __captured: &()) -> ::types::internment::Intern<String>
                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                        let name = unsafe{&*__args};
                                                                                                                                                                                                                                                                                                                                                                        name.data.clone()
                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                    __f
                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                         }) as Box<dyn closure::Closure<(*const ::types::ast::Spanned<::types::ast::Name>), ::types::internment::Intern<String>>>)
                                                                                                                                                                                                                                                                                                                                                     }));
                                                                                             let file = (*file).clone();
                                                                                             let scope = (*scope).clone();
                                                                                             Some(Box::new(__flattened.into_iter().map(move |name|(::types::ddlog_std::tuple3(name.clone(), file.clone(), scope.clone())).into_ddvalue())))
                                                                                         }
                                                                                         __f},
                                                                                         next: Box::new(Some(XFormCollection::FilterMap{
                                                                                                                 description: "head of name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=name, .scope=scope, .file=file}: name_in_scope::NameOccursInScope)] :- inputs::Assign[(inputs::Assign{.expr_id=(id: ast::ExprId), .file=(file: ast::FileId), .lhs=(ddlog_std::Some{.x=(ddlog_std::Left{.l=(pattern: internment::Intern<ast::Pattern>)}: ddlog_std::Either<internment::Intern<ast::Pattern>,ast::ExprId>)}: ddlog_std::Option<ddlog_std::Either<ast::IPattern,ast::ExprId>>), .rhs=(_: ddlog_std::Option<ast::ExprId>), .op=(_: ddlog_std::Option<ast::AssignOperand>)}: inputs::Assign)], inputs::Expression[(inputs::Expression{.id=(id: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression)], var name = FlatMap(((vec::map: function(ddlog_std::Vec<ast::Spanned<ast::Name>>, function(ast::Spanned<ast::Name>):internment::Intern<string>):ddlog_std::Vec<internment::Intern<string>>)(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pattern)), (function(name: ast::Spanned<ast::Name>):internment::Intern<string>{(name.data)}))))." .to_string(),
                                                                                                                 fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                                                                 {
                                                                                                                     let ::types::ddlog_std::tuple3(ref name, ref file, ref scope) = *<::types::ddlog_std::tuple3<::types::internment::Intern<String>, ::types::ast::FileId, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                                                     Some(((::types::name_in_scope::NameOccursInScope{name: (*name).clone(), scope: (*scope).clone(), file: (*file).clone()})).into_ddvalue())
                                                                                                                 }
                                                                                                                 __f},
                                                                                                                 next: Box::new(None)
                                                                                                             }))
                                                                                     }))
                                                             }
                                                  },
                                                  /* name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=name, .scope=scope, .file=file}: name_in_scope::NameOccursInScope)] :- inputs::FileExport[(inputs::FileExport{.file=(file: ast::FileId), .export=(ast::NamedExport{.name=(export_name: ddlog_std::Option<ast::Spanned<ast::Name>>), .alias=(export_alias: ddlog_std::Option<ast::Spanned<ast::Name>>)}: ast::ExportKind), .scope=(scope: ast::ScopeId)}: inputs::FileExport)], ((ddlog_std::Some{.x=(ast::Spanned{.data=(var name: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<internment::Intern<string>>>) = ((utils::or_else: function(ddlog_std::Option<ast::Spanned<ast::Name>>, ddlog_std::Option<ast::Spanned<ast::Name>>):ddlog_std::Option<ast::Spanned<internment::Intern<string>>>)(export_alias, export_name))). */
                                                  Rule::CollectionRule {
                                                      description: "name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=name, .scope=scope, .file=file}: name_in_scope::NameOccursInScope)] :- inputs::FileExport[(inputs::FileExport{.file=(file: ast::FileId), .export=(ast::NamedExport{.name=(export_name: ddlog_std::Option<ast::Spanned<ast::Name>>), .alias=(export_alias: ddlog_std::Option<ast::Spanned<ast::Name>>)}: ast::ExportKind), .scope=(scope: ast::ScopeId)}: inputs::FileExport)], ((ddlog_std::Some{.x=(ast::Spanned{.data=(var name: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<internment::Intern<string>>>) = ((utils::or_else: function(ddlog_std::Option<ast::Spanned<ast::Name>>, ddlog_std::Option<ast::Spanned<ast::Name>>):ddlog_std::Option<ast::Spanned<internment::Intern<string>>>)(export_alias, export_name))).".to_string(),
                                                      rel: Relations::inputs_FileExport as RelId,
                                                      xform: Some(XFormCollection::FilterMap{
                                                                      description: "head of name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=name, .scope=scope, .file=file}: name_in_scope::NameOccursInScope)] :- inputs::FileExport[(inputs::FileExport{.file=(file: ast::FileId), .export=(ast::NamedExport{.name=(export_name: ddlog_std::Option<ast::Spanned<ast::Name>>), .alias=(export_alias: ddlog_std::Option<ast::Spanned<ast::Name>>)}: ast::ExportKind), .scope=(scope: ast::ScopeId)}: inputs::FileExport)], ((ddlog_std::Some{.x=(ast::Spanned{.data=(var name: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<internment::Intern<string>>>) = ((utils::or_else: function(ddlog_std::Option<ast::Spanned<ast::Name>>, ddlog_std::Option<ast::Spanned<ast::Name>>):ddlog_std::Option<ast::Spanned<internment::Intern<string>>>)(export_alias, export_name)))." .to_string(),
                                                                      fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                      {
                                                                          let (ref file, ref export_name, ref export_alias, ref scope) = match *<::types::inputs::FileExport>::from_ddvalue_ref(&__v) {
                                                                              ::types::inputs::FileExport{file: ref file, export: ::types::ast::ExportKind::NamedExport{name: ref export_name, alias: ref export_alias}, scope: ref scope} => ((*file).clone(), (*export_name).clone(), (*export_alias).clone(), (*scope).clone()),
                                                                              _ => return None
                                                                          };
                                                                          let ref name: ::types::internment::Intern<String> = match ::types::utils::or_else::<::types::ast::Spanned<::types::ast::Name>>(export_alias, export_name) {
                                                                              ::types::ddlog_std::Option::Some{x: ::types::ast::Spanned{data: name, span: _}} => name,
                                                                              _ => return None
                                                                          };
                                                                          Some(((::types::name_in_scope::NameOccursInScope{name: (*name).clone(), scope: (*scope).clone(), file: (*file).clone()})).into_ddvalue())
                                                                      }
                                                                      __f},
                                                                      next: Box::new(None)
                                                                  })
                                                  },
                                                  /* name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=name, .scope=parent, .file=file}: name_in_scope::NameOccursInScope)] :- name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=(name: internment::Intern<string>), .scope=(child: ast::ScopeId), .file=(file: ast::FileId)}: name_in_scope::NameOccursInScope)], inputs::InputScope[(inputs::InputScope{.parent=(parent: ast::ScopeId), .child=(child: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)]. */
                                                  Rule::ArrangementRule {
                                                      description: "name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=name, .scope=parent, .file=file}: name_in_scope::NameOccursInScope)] :- name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=(name: internment::Intern<string>), .scope=(child: ast::ScopeId), .file=(file: ast::FileId)}: name_in_scope::NameOccursInScope)], inputs::InputScope[(inputs::InputScope{.parent=(parent: ast::ScopeId), .child=(child: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)].".to_string(),
                                                      arr: ( Relations::name_in_scope_NameOccursInScope as RelId, 2),
                                                      xform: XFormArrangement::Join{
                                                                 description: "name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=(name: internment::Intern<string>), .scope=(child: ast::ScopeId), .file=(file: ast::FileId)}: name_in_scope::NameOccursInScope)], inputs::InputScope[(inputs::InputScope{.parent=(parent: ast::ScopeId), .child=(child: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)]".to_string(),
                                                                 ffun: None,
                                                                 arrangement: (Relations::inputs_InputScope as RelId,0),
                                                                 jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                 {
                                                                     let (ref name, ref child, ref file) = match *<::types::name_in_scope::NameOccursInScope>::from_ddvalue_ref(__v1) {
                                                                         ::types::name_in_scope::NameOccursInScope{name: ref name, scope: ref child, file: ref file} => ((*name).clone(), (*child).clone(), (*file).clone()),
                                                                         _ => return None
                                                                     };
                                                                     let ref parent = match *<::types::inputs::InputScope>::from_ddvalue_ref(__v2) {
                                                                         ::types::inputs::InputScope{parent: ref parent, child: _, file: _} => (*parent).clone(),
                                                                         _ => return None
                                                                     };
                                                                     Some(((::types::name_in_scope::NameOccursInScope{name: (*name).clone(), scope: (*parent).clone(), file: (*file).clone()})).into_ddvalue())
                                                                 }
                                                                 __f},
                                                                 next: Box::new(None)
                                                             }
                                                  }],
                                              arrangements: vec![
                                                  Arrangement::Set{
                                                      name: r###"(name_in_scope::NameOccursInScope{.name=(_0: internment::Intern<string>), .scope=(_1: ast::ScopeId), .file=(_2: ast::FileId)}: name_in_scope::NameOccursInScope) /*semijoin*/"###.to_string(),
                                                      fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                      {
                                                          match < ::types::name_in_scope::NameOccursInScope>::from_ddvalue(__v) {
                                                              ::types::name_in_scope::NameOccursInScope{name: ref _0, scope: ref _1, file: ref _2} => Some((::types::ddlog_std::tuple3((*_0).clone(), (*_1).clone(), (*_2).clone())).into_ddvalue()),
                                                              _ => None
                                                          }
                                                      }
                                                      __f},
                                                      distinct: false
                                                  },
                                                  Arrangement::Map{
                                                     name: r###"(name_in_scope::NameOccursInScope{.name=(_1: internment::Intern<string>), .scope=(_2: ast::ScopeId), .file=(_0: ast::FileId)}: name_in_scope::NameOccursInScope) /*join*/"###.to_string(),
                                                      afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                      {
                                                          let __cloned = __v.clone();
                                                          match < ::types::name_in_scope::NameOccursInScope>::from_ddvalue(__v) {
                                                              ::types::name_in_scope::NameOccursInScope{name: ref _1, scope: ref _2, file: ref _0} => Some((::types::ddlog_std::tuple3((*_0).clone(), (*_1).clone(), (*_2).clone())).into_ddvalue()),
                                                              _ => None
                                                          }.map(|x|(x,__cloned))
                                                      }
                                                      __f},
                                                      queryable: false
                                                  },
                                                  Arrangement::Map{
                                                     name: r###"(name_in_scope::NameOccursInScope{.name=(_: internment::Intern<string>), .scope=(_0: ast::ScopeId), .file=(_1: ast::FileId)}: name_in_scope::NameOccursInScope) /*join*/"###.to_string(),
                                                      afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                      {
                                                          let __cloned = __v.clone();
                                                          match < ::types::name_in_scope::NameOccursInScope>::from_ddvalue(__v) {
                                                              ::types::name_in_scope::NameOccursInScope{name: _, scope: ref _0, file: ref _1} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                              _ => None
                                                          }.map(|x|(x,__cloned))
                                                      }
                                                      __f},
                                                      queryable: false
                                                  }],
                                              change_cb:    None
                                          };
    let inputs_New = Relation {
                         name:         "inputs::New".to_string(),
                         input:        true,
                         distinct:     false,
                         caching_mode: CachingMode::Set,
                         key_func:     None,
                         id:           Relations::inputs_New as RelId,
                         rules:        vec![
                             ],
                         arrangements: vec![
                             Arrangement::Map{
                                name: r###"(inputs::New{.expr_id=(_: ast::ExprId), .file=(_0: ast::FileId), .object=(ddlog_std::Some{.x=(_: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::New) /*join*/"###.to_string(),
                                 afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                 {
                                     let __cloned = __v.clone();
                                     match < ::types::inputs::New>::from_ddvalue(__v) {
                                         ::types::inputs::New{expr_id: _, file: ref _0, object: ::types::ddlog_std::Option::Some{x: _}, args: _} => Some(((*_0).clone()).into_ddvalue()),
                                         _ => None
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             },
                             Arrangement::Set{
                                 name: r###"(inputs::New{.expr_id=(_: ast::ExprId), .file=(_0: ast::FileId), .object=(ddlog_std::Some{.x=(_1: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::New) /*antijoin*/"###.to_string(),
                                 fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                 {
                                     match < ::types::inputs::New>::from_ddvalue(__v) {
                                         ::types::inputs::New{expr_id: _, file: ref _0, object: ::types::ddlog_std::Option::Some{x: ref _1}, args: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                         _ => None
                                     }
                                 }
                                 __f},
                                 distinct: true
                             }],
                         change_cb:    None
                     };
    let __Prefix_1 = Relation {
                         name:         "__Prefix_1".to_string(),
                         input:        false,
                         distinct:     false,
                         caching_mode: CachingMode::Set,
                         key_func:     None,
                         id:           Relations::__Prefix_1 as RelId,
                         rules:        vec![
                             /* __Prefix_1[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span))] :- __Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::New[(inputs::New{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .object=(ddlog_std::Some{.x=(object: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::New)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(used_scope: ast::ScopeId), .span=(used_in: ast::Span)}: inputs::Expression)]. */
                             Rule::ArrangementRule {
                                 description: "__Prefix_1[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span))] :- __Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::New[(inputs::New{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .object=(ddlog_std::Some{.x=(object: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::New)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(used_scope: ast::ScopeId), .span=(used_in: ast::Span)}: inputs::Expression)].".to_string(),
                                 arr: ( Relations::__Prefix_7 as RelId, 0),
                                 xform: XFormArrangement::Join{
                                            description: "__Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::New[(inputs::New{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .object=(ddlog_std::Some{.x=(object: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::New)]".to_string(),
                                            ffun: None,
                                            arrangement: (Relations::inputs_New as RelId,0),
                                            jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                            {
                                                let (ref file, ref config) = match *<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue_ref(__v1) {
                                                    ::types::ddlog_std::tuple2(ref file, ref config) => ((*file).clone(), (*config).clone()),
                                                    _ => return None
                                                };
                                                let (ref expr, ref object) = match *<::types::inputs::New>::from_ddvalue_ref(__v2) {
                                                    ::types::inputs::New{expr_id: ref expr, file: _, object: ::types::ddlog_std::Option::Some{x: ref object}, args: _} => ((*expr).clone(), (*object).clone()),
                                                    _ => return None
                                                };
                                                Some((::types::ddlog_std::tuple4((*file).clone(), (*config).clone(), (*expr).clone(), (*object).clone())).into_ddvalue())
                                            }
                                            __f},
                                            next: Box::new(Some(XFormCollection::Arrange {
                                                                    description: "arrange __Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::New[(inputs::New{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .object=(ddlog_std::Some{.x=(object: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::New)] by (expr, file)" .to_string(),
                                                                    afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                    {
                                                                        let ::types::ddlog_std::tuple4(ref file, ref config, ref expr, ref object) = *<::types::ddlog_std::tuple4<::types::ast::FileId, ::types::config::Config, ::types::ast::ExprId, ::types::ast::ExprId>>::from_ddvalue_ref( &__v );
                                                                        Some(((::types::ddlog_std::tuple2((*expr).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple4((*file).clone(), (*config).clone(), (*expr).clone(), (*object).clone())).into_ddvalue()))
                                                                    }
                                                                    __f},
                                                                    next: Box::new(XFormArrangement::Join{
                                                                                       description: "__Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::New[(inputs::New{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .object=(ddlog_std::Some{.x=(object: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::New)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(used_scope: ast::ScopeId), .span=(used_in: ast::Span)}: inputs::Expression)]".to_string(),
                                                                                       ffun: None,
                                                                                       arrangement: (Relations::inputs_Expression as RelId,0),
                                                                                       jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                       {
                                                                                           let ::types::ddlog_std::tuple4(ref file, ref config, ref expr, ref object) = *<::types::ddlog_std::tuple4<::types::ast::FileId, ::types::config::Config, ::types::ast::ExprId, ::types::ast::ExprId>>::from_ddvalue_ref( __v1 );
                                                                                           let (ref used_scope, ref used_in) = match *<::types::inputs::Expression>::from_ddvalue_ref(__v2) {
                                                                                               ::types::inputs::Expression{id: _, file: _, kind: _, scope: ref used_scope, span: ref used_in} => ((*used_scope).clone(), (*used_in).clone()),
                                                                                               _ => return None
                                                                                           };
                                                                                           Some((::types::ddlog_std::tuple6((*file).clone(), (*config).clone(), (*expr).clone(), (*object).clone(), (*used_scope).clone(), (*used_in).clone())).into_ddvalue())
                                                                                       }
                                                                                       __f},
                                                                                       next: Box::new(None)
                                                                                   })
                                                                }))
                                        }
                             }],
                         arrangements: vec![
                             Arrangement::Map{
                                name: r###"((_1: ast::FileId), (_: config::Config), (_: ast::ExprId), (_0: ast::ExprId), (_: ast::ScopeId), (_: ast::Span)) /*join*/"###.to_string(),
                                 afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                 {
                                     let __cloned = __v.clone();
                                     match < ::types::ddlog_std::tuple6<::types::ast::FileId, ::types::config::Config, ::types::ast::ExprId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span>>::from_ddvalue(__v) {
                                         ::types::ddlog_std::tuple6(ref _1, _, _, ref _0, _, _) => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                         _ => None
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             },
                             Arrangement::Map{
                                name: r###"((_0: ast::FileId), (_: config::Config), (_: ast::ExprId), (_: ast::ExprId), (_: ast::ScopeId), (_: ast::Span)) /*join*/"###.to_string(),
                                 afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                 {
                                     let __cloned = __v.clone();
                                     match < ::types::ddlog_std::tuple6<::types::ast::FileId, ::types::config::Config, ::types::ast::ExprId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span>>::from_ddvalue(__v) {
                                         ::types::ddlog_std::tuple6(ref _0, _, _, _, _, _) => Some(((*_0).clone()).into_ddvalue()),
                                         _ => None
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             }],
                         change_cb:    None
                     };
    let __Prefix_0 = Relation {
                         name:         "__Prefix_0".to_string(),
                         input:        false,
                         distinct:     false,
                         caching_mode: CachingMode::Set,
                         key_func:     None,
                         id:           Relations::__Prefix_0 as RelId,
                         rules:        vec![
                             /* __Prefix_0[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span), (name: internment::Intern<string>))] :- __Prefix_1[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span))], inputs::NameRef[(inputs::NameRef{.expr_id=(object: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)]. */
                             Rule::ArrangementRule {
                                 description: "__Prefix_0[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span), (name: internment::Intern<string>))] :- __Prefix_1[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span))], inputs::NameRef[(inputs::NameRef{.expr_id=(object: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)].".to_string(),
                                 arr: ( Relations::__Prefix_1 as RelId, 0),
                                 xform: XFormArrangement::Join{
                                            description: "__Prefix_1[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span))], inputs::NameRef[(inputs::NameRef{.expr_id=(object: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)]".to_string(),
                                            ffun: None,
                                            arrangement: (Relations::inputs_NameRef as RelId,0),
                                            jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                            {
                                                let (ref file, ref config, ref expr, ref object, ref used_scope, ref used_in) = match *<::types::ddlog_std::tuple6<::types::ast::FileId, ::types::config::Config, ::types::ast::ExprId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span>>::from_ddvalue_ref(__v1) {
                                                    ::types::ddlog_std::tuple6(ref file, ref config, ref expr, ref object, ref used_scope, ref used_in) => ((*file).clone(), (*config).clone(), (*expr).clone(), (*object).clone(), (*used_scope).clone(), (*used_in).clone()),
                                                    _ => return None
                                                };
                                                let ref name = match *<::types::inputs::NameRef>::from_ddvalue_ref(__v2) {
                                                    ::types::inputs::NameRef{expr_id: _, file: _, value: ref name} => (*name).clone(),
                                                    _ => return None
                                                };
                                                Some((::types::ddlog_std::tuple7((*file).clone(), (*config).clone(), (*expr).clone(), (*object).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone())).into_ddvalue())
                                            }
                                            __f},
                                            next: Box::new(None)
                                        }
                             }],
                         arrangements: vec![
                             Arrangement::Map{
                                name: r###"((_0: ast::FileId), (_: config::Config), (_: ast::ExprId), (_: ast::ExprId), (_2: ast::ScopeId), (_: ast::Span), (_1: internment::Intern<string>)) /*join*/"###.to_string(),
                                 afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                 {
                                     let __cloned = __v.clone();
                                     match < ::types::ddlog_std::tuple7<::types::ast::FileId, ::types::config::Config, ::types::ast::ExprId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span, ::types::internment::Intern<String>>>::from_ddvalue(__v) {
                                         ::types::ddlog_std::tuple7(ref _0, _, _, _, ref _2, _, ref _1) => Some((::types::ddlog_std::tuple3((*_0).clone(), (*_1).clone(), (*_2).clone())).into_ddvalue()),
                                         _ => None
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             },
                             Arrangement::Map{
                                name: r###"((_0: ast::FileId), (_: config::Config), (_: ast::ExprId), (_: ast::ExprId), (_: ast::ScopeId), (_: ast::Span), (_1: internment::Intern<string>)) /*join*/"###.to_string(),
                                 afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                 {
                                     let __cloned = __v.clone();
                                     match < ::types::ddlog_std::tuple7<::types::ast::FileId, ::types::config::Config, ::types::ast::ExprId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span, ::types::internment::Intern<String>>>::from_ddvalue(__v) {
                                         ::types::ddlog_std::tuple7(ref _0, _, _, _, _, _, ref _1) => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                         _ => None
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             }],
                         change_cb:    None
                     };
    let inputs_Property = Relation {
                              name:         "inputs::Property".to_string(),
                              input:        true,
                              distinct:     false,
                              caching_mode: CachingMode::Set,
                              key_func:     None,
                              id:           Relations::inputs_Property as RelId,
                              rules:        vec![
                                  ],
                              arrangements: vec![
                                  ],
                              change_cb:    None
                          };
    let inputs_Return = Relation {
                            name:         "inputs::Return".to_string(),
                            input:        true,
                            distinct:     false,
                            caching_mode: CachingMode::Set,
                            key_func:     None,
                            id:           Relations::inputs_Return as RelId,
                            rules:        vec![
                                ],
                            arrangements: vec![
                                ],
                            change_cb:    None
                        };
    let inputs_Statement = Relation {
                               name:         "inputs::Statement".to_string(),
                               input:        true,
                               distinct:     false,
                               caching_mode: CachingMode::Set,
                               key_func:     Some((|__key: &DDValue| {
                                                      let ref stmt = *<::types::inputs::Statement>::from_ddvalue_ref(__key);
                                                      (::types::ddlog_std::tuple2(stmt.id.clone(), stmt.file.clone())).into_ddvalue()
                                                  })),
                               id:           Relations::inputs_Statement as RelId,
                               rules:        vec![
                                   ],
                               arrangements: vec![
                                   Arrangement::Map{
                                      name: r###"(inputs::Statement{.id=(_0: ast::StmtId), .file=(_1: ast::FileId), .kind=(_: ast::StmtKind), .scope=(_: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement) /*join*/"###.to_string(),
                                       afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                       {
                                           let __cloned = __v.clone();
                                           match < ::types::inputs::Statement>::from_ddvalue(__v) {
                                               ::types::inputs::Statement{id: ref _0, file: ref _1, kind: _, scope: _, span: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                               _ => None
                                           }.map(|x|(x,__cloned))
                                       }
                                       __f},
                                       queryable: false
                                   },
                                   Arrangement::Map{
                                      name: r###"(inputs::Statement{.id=(_0: ast::StmtId), .file=(_1: ast::FileId), .kind=(ast::StmtVarDecl{}: ast::StmtKind), .scope=(_: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement) /*join*/"###.to_string(),
                                       afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                       {
                                           let __cloned = __v.clone();
                                           match < ::types::inputs::Statement>::from_ddvalue(__v) {
                                               ::types::inputs::Statement{id: ref _0, file: ref _1, kind: ::types::ast::StmtKind::StmtVarDecl{}, scope: _, span: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                               _ => None
                                           }.map(|x|(x,__cloned))
                                       }
                                       __f},
                                       queryable: false
                                   },
                                   Arrangement::Map{
                                      name: r###"(inputs::Statement{.id=_0, .file=_1, .kind=(_: ast::StmtKind), .scope=(_: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement) /*join*/"###.to_string(),
                                       afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                       {
                                           let __cloned = __v.clone();
                                           match < ::types::inputs::Statement>::from_ddvalue(__v) {
                                               ::types::inputs::Statement{id: ref _0, file: ref _1, kind: _, scope: _, span: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                               _ => None
                                           }.map(|x|(x,__cloned))
                                       }
                                       __f},
                                       queryable: true
                                   },
                                   Arrangement::Map{
                                      name: r###"(inputs::Statement{.id=(_: ast::StmtId), .file=_1, .kind=(_: ast::StmtKind), .scope=(_: ast::ScopeId), .span=_0}: inputs::Statement) /*join*/"###.to_string(),
                                       afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                       {
                                           let __cloned = __v.clone();
                                           match < ::types::inputs::Statement>::from_ddvalue(__v) {
                                               ::types::inputs::Statement{id: _, file: ref _1, kind: _, scope: _, span: ref _0} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                               _ => None
                                           }.map(|x|(x,__cloned))
                                       }
                                       __f},
                                       queryable: true
                                   }],
                               change_cb:    None
                           };
    let outputs_no_unused_labels_LabelUsage = Relation {
                                                  name:         "outputs::no_unused_labels::LabelUsage".to_string(),
                                                  input:        false,
                                                  distinct:     false,
                                                  caching_mode: CachingMode::Set,
                                                  key_func:     None,
                                                  id:           Relations::outputs_no_unused_labels_LabelUsage as RelId,
                                                  rules:        vec![
                                                      /* outputs::no_unused_labels::LabelUsage[(outputs::no_unused_labels::LabelUsage{.stmt=stmt, .file=file, .label_name=name, .scope=scope}: outputs::no_unused_labels::LabelUsage)] :- __Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Break[(inputs::Break{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .label=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>)}: inputs::Break)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)]. */
                                                      Rule::ArrangementRule {
                                                          description: "outputs::no_unused_labels::LabelUsage[(outputs::no_unused_labels::LabelUsage{.stmt=stmt, .file=file, .label_name=name, .scope=scope}: outputs::no_unused_labels::LabelUsage)] :- __Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Break[(inputs::Break{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .label=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>)}: inputs::Break)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)].".to_string(),
                                                          arr: ( Relations::__Prefix_8 as RelId, 0),
                                                          xform: XFormArrangement::Join{
                                                                     description: "__Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Break[(inputs::Break{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .label=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>)}: inputs::Break)]".to_string(),
                                                                     ffun: None,
                                                                     arrangement: (Relations::inputs_Break as RelId,0),
                                                                     jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                     {
                                                                         let (ref file, ref config) = match *<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue_ref(__v1) {
                                                                             ::types::ddlog_std::tuple2(ref file, ref config) => ((*file).clone(), (*config).clone()),
                                                                             _ => return None
                                                                         };
                                                                         let (ref stmt, ref name) = match *<::types::inputs::Break>::from_ddvalue_ref(__v2) {
                                                                             ::types::inputs::Break{stmt_id: ref stmt, file: _, label: ::types::ddlog_std::Option::Some{x: ::types::ast::Spanned{data: ref name, span: _}}} => ((*stmt).clone(), (*name).clone()),
                                                                             _ => return None
                                                                         };
                                                                         Some((::types::ddlog_std::tuple3((*file).clone(), (*stmt).clone(), (*name).clone())).into_ddvalue())
                                                                     }
                                                                     __f},
                                                                     next: Box::new(Some(XFormCollection::Arrange {
                                                                                             description: "arrange __Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Break[(inputs::Break{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .label=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>)}: inputs::Break)] by (stmt, file)" .to_string(),
                                                                                             afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                             {
                                                                                                 let ::types::ddlog_std::tuple3(ref file, ref stmt, ref name) = *<::types::ddlog_std::tuple3<::types::ast::FileId, ::types::ast::StmtId, ::types::internment::Intern<String>>>::from_ddvalue_ref( &__v );
                                                                                                 Some(((::types::ddlog_std::tuple2((*stmt).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple3((*file).clone(), (*stmt).clone(), (*name).clone())).into_ddvalue()))
                                                                                             }
                                                                                             __f},
                                                                                             next: Box::new(XFormArrangement::Join{
                                                                                                                description: "__Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Break[(inputs::Break{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .label=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>)}: inputs::Break)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)]".to_string(),
                                                                                                                ffun: None,
                                                                                                                arrangement: (Relations::inputs_Statement as RelId,0),
                                                                                                                jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                {
                                                                                                                    let ::types::ddlog_std::tuple3(ref file, ref stmt, ref name) = *<::types::ddlog_std::tuple3<::types::ast::FileId, ::types::ast::StmtId, ::types::internment::Intern<String>>>::from_ddvalue_ref( __v1 );
                                                                                                                    let ref scope = match *<::types::inputs::Statement>::from_ddvalue_ref(__v2) {
                                                                                                                        ::types::inputs::Statement{id: _, file: _, kind: _, scope: ref scope, span: _} => (*scope).clone(),
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    Some(((::types::outputs::no_unused_labels::LabelUsage{stmt: (*stmt).clone(), file: (*file).clone(), label_name: (*name).clone(), scope: (*scope).clone()})).into_ddvalue())
                                                                                                                }
                                                                                                                __f},
                                                                                                                next: Box::new(None)
                                                                                                            })
                                                                                         }))
                                                                 }
                                                      },
                                                      /* outputs::no_unused_labels::LabelUsage[(outputs::no_unused_labels::LabelUsage{.stmt=stmt, .file=file, .label_name=name, .scope=scope}: outputs::no_unused_labels::LabelUsage)] :- __Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Continue[(inputs::Continue{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .label=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>)}: inputs::Continue)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)]. */
                                                      Rule::ArrangementRule {
                                                          description: "outputs::no_unused_labels::LabelUsage[(outputs::no_unused_labels::LabelUsage{.stmt=stmt, .file=file, .label_name=name, .scope=scope}: outputs::no_unused_labels::LabelUsage)] :- __Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Continue[(inputs::Continue{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .label=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>)}: inputs::Continue)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)].".to_string(),
                                                          arr: ( Relations::__Prefix_8 as RelId, 0),
                                                          xform: XFormArrangement::Join{
                                                                     description: "__Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Continue[(inputs::Continue{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .label=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>)}: inputs::Continue)]".to_string(),
                                                                     ffun: None,
                                                                     arrangement: (Relations::inputs_Continue as RelId,0),
                                                                     jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                     {
                                                                         let (ref file, ref config) = match *<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue_ref(__v1) {
                                                                             ::types::ddlog_std::tuple2(ref file, ref config) => ((*file).clone(), (*config).clone()),
                                                                             _ => return None
                                                                         };
                                                                         let (ref stmt, ref name) = match *<::types::inputs::Continue>::from_ddvalue_ref(__v2) {
                                                                             ::types::inputs::Continue{stmt_id: ref stmt, file: _, label: ::types::ddlog_std::Option::Some{x: ::types::ast::Spanned{data: ref name, span: _}}} => ((*stmt).clone(), (*name).clone()),
                                                                             _ => return None
                                                                         };
                                                                         Some((::types::ddlog_std::tuple3((*file).clone(), (*stmt).clone(), (*name).clone())).into_ddvalue())
                                                                     }
                                                                     __f},
                                                                     next: Box::new(Some(XFormCollection::Arrange {
                                                                                             description: "arrange __Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Continue[(inputs::Continue{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .label=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>)}: inputs::Continue)] by (stmt, file)" .to_string(),
                                                                                             afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                             {
                                                                                                 let ::types::ddlog_std::tuple3(ref file, ref stmt, ref name) = *<::types::ddlog_std::tuple3<::types::ast::FileId, ::types::ast::StmtId, ::types::internment::Intern<String>>>::from_ddvalue_ref( &__v );
                                                                                                 Some(((::types::ddlog_std::tuple2((*stmt).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple3((*file).clone(), (*stmt).clone(), (*name).clone())).into_ddvalue()))
                                                                                             }
                                                                                             __f},
                                                                                             next: Box::new(XFormArrangement::Join{
                                                                                                                description: "__Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Continue[(inputs::Continue{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .label=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>)}: inputs::Continue)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)]".to_string(),
                                                                                                                ffun: None,
                                                                                                                arrangement: (Relations::inputs_Statement as RelId,0),
                                                                                                                jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                {
                                                                                                                    let ::types::ddlog_std::tuple3(ref file, ref stmt, ref name) = *<::types::ddlog_std::tuple3<::types::ast::FileId, ::types::ast::StmtId, ::types::internment::Intern<String>>>::from_ddvalue_ref( __v1 );
                                                                                                                    let ref scope = match *<::types::inputs::Statement>::from_ddvalue_ref(__v2) {
                                                                                                                        ::types::inputs::Statement{id: _, file: _, kind: _, scope: ref scope, span: _} => (*scope).clone(),
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    Some(((::types::outputs::no_unused_labels::LabelUsage{stmt: (*stmt).clone(), file: (*file).clone(), label_name: (*name).clone(), scope: (*scope).clone()})).into_ddvalue())
                                                                                                                }
                                                                                                                __f},
                                                                                                                next: Box::new(None)
                                                                                                            })
                                                                                         }))
                                                                 }
                                                      }],
                                                  arrangements: vec![
                                                      Arrangement::Set{
                                                          name: r###"(outputs::no_unused_labels::LabelUsage{.stmt=(_: ast::StmtId), .file=(_0: ast::FileId), .label_name=_1, .scope=(_2: ast::ScopeId)}: outputs::no_unused_labels::LabelUsage) /*semijoin*/"###.to_string(),
                                                          fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                          {
                                                              match < ::types::outputs::no_unused_labels::LabelUsage>::from_ddvalue(__v) {
                                                                  ::types::outputs::no_unused_labels::LabelUsage{stmt: _, file: ref _0, label_name: ref _1, scope: ref _2} => Some((::types::ddlog_std::tuple3((*_0).clone(), (*_1).clone(), (*_2).clone())).into_ddvalue()),
                                                                  _ => None
                                                              }
                                                          }
                                                          __f},
                                                          distinct: false
                                                      },
                                                      Arrangement::Set{
                                                          name: r###"(outputs::no_unused_labels::LabelUsage{.stmt=(_: ast::StmtId), .file=(_0: ast::FileId), .label_name=(_1: internment::Intern<string>), .scope=(_2: ast::ScopeId)}: outputs::no_unused_labels::LabelUsage) /*antijoin*/"###.to_string(),
                                                          fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                          {
                                                              match < ::types::outputs::no_unused_labels::LabelUsage>::from_ddvalue(__v) {
                                                                  ::types::outputs::no_unused_labels::LabelUsage{stmt: _, file: ref _0, label_name: ref _1, scope: ref _2} => Some((::types::ddlog_std::tuple3((*_0).clone(), (*_1).clone(), (*_2).clone())).into_ddvalue()),
                                                                  _ => None
                                                              }
                                                          }
                                                          __f},
                                                          distinct: true
                                                      }],
                                                  change_cb:    None
                                              };
    let scopes_NeedsScopeChildren = Relation {
                                        name:         "scopes::NeedsScopeChildren".to_string(),
                                        input:        false,
                                        distinct:     false,
                                        caching_mode: CachingMode::Set,
                                        key_func:     None,
                                        id:           Relations::scopes_NeedsScopeChildren as RelId,
                                        rules:        vec![
                                            /* scopes::NeedsScopeChildren[(scopes::NeedsScopeChildren{.scope=scope, .file=file}: scopes::NeedsScopeChildren)] :- __Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Label[(inputs::Label{.stmt_id=(_: ast::StmtId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(_: ddlog_std::Option<ast::StmtId>), .body_scope=(scope: ast::ScopeId)}: inputs::Label)], not outputs::no_unused_labels::LabelUsage[(outputs::no_unused_labels::LabelUsage{.stmt=(_: ast::StmtId), .file=(file: ast::FileId), .label_name=(name: internment::Intern<string>), .scope=(scope: ast::ScopeId)}: outputs::no_unused_labels::LabelUsage)]. */
                                            Rule::ArrangementRule {
                                                description: "scopes::NeedsScopeChildren[(scopes::NeedsScopeChildren{.scope=scope, .file=file}: scopes::NeedsScopeChildren)] :- __Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Label[(inputs::Label{.stmt_id=(_: ast::StmtId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(_: ddlog_std::Option<ast::StmtId>), .body_scope=(scope: ast::ScopeId)}: inputs::Label)], not outputs::no_unused_labels::LabelUsage[(outputs::no_unused_labels::LabelUsage{.stmt=(_: ast::StmtId), .file=(file: ast::FileId), .label_name=(name: internment::Intern<string>), .scope=(scope: ast::ScopeId)}: outputs::no_unused_labels::LabelUsage)].".to_string(),
                                                arr: ( Relations::__Prefix_8 as RelId, 0),
                                                xform: XFormArrangement::Join{
                                                           description: "__Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Label[(inputs::Label{.stmt_id=(_: ast::StmtId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(_: ddlog_std::Option<ast::StmtId>), .body_scope=(scope: ast::ScopeId)}: inputs::Label)]".to_string(),
                                                           ffun: None,
                                                           arrangement: (Relations::inputs_Label as RelId,1),
                                                           jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                           {
                                                               let (ref file, ref config) = match *<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue_ref(__v1) {
                                                                   ::types::ddlog_std::tuple2(ref file, ref config) => ((*file).clone(), (*config).clone()),
                                                                   _ => return None
                                                               };
                                                               let (ref name, ref scope) = match *<::types::inputs::Label>::from_ddvalue_ref(__v2) {
                                                                   ::types::inputs::Label{stmt_id: _, file: _, name: ::types::ddlog_std::Option::Some{x: ::types::ast::Spanned{data: ref name, span: _}}, body: _, body_scope: ref scope} => ((*name).clone(), (*scope).clone()),
                                                                   _ => return None
                                                               };
                                                               Some((::types::ddlog_std::tuple3((*file).clone(), (*name).clone(), (*scope).clone())).into_ddvalue())
                                                           }
                                                           __f},
                                                           next: Box::new(Some(XFormCollection::Arrange {
                                                                                   description: "arrange __Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Label[(inputs::Label{.stmt_id=(_: ast::StmtId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(_: ddlog_std::Option<ast::StmtId>), .body_scope=(scope: ast::ScopeId)}: inputs::Label)] by (file, name, scope)" .to_string(),
                                                                                   afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                   {
                                                                                       let ::types::ddlog_std::tuple3(ref file, ref name, ref scope) = *<::types::ddlog_std::tuple3<::types::ast::FileId, ::types::internment::Intern<String>, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                       Some(((::types::ddlog_std::tuple3((*file).clone(), (*name).clone(), (*scope).clone())).into_ddvalue(), (::types::ddlog_std::tuple2((*file).clone(), (*scope).clone())).into_ddvalue()))
                                                                                   }
                                                                                   __f},
                                                                                   next: Box::new(XFormArrangement::Antijoin {
                                                                                                      description: "__Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Label[(inputs::Label{.stmt_id=(_: ast::StmtId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(_: ddlog_std::Option<ast::StmtId>), .body_scope=(scope: ast::ScopeId)}: inputs::Label)], not outputs::no_unused_labels::LabelUsage[(outputs::no_unused_labels::LabelUsage{.stmt=(_: ast::StmtId), .file=(file: ast::FileId), .label_name=(name: internment::Intern<string>), .scope=(scope: ast::ScopeId)}: outputs::no_unused_labels::LabelUsage)]".to_string(),
                                                                                                      ffun: None,
                                                                                                      arrangement: (Relations::outputs_no_unused_labels_LabelUsage as RelId,1),
                                                                                                      next: Box::new(Some(XFormCollection::FilterMap{
                                                                                                                              description: "head of scopes::NeedsScopeChildren[(scopes::NeedsScopeChildren{.scope=scope, .file=file}: scopes::NeedsScopeChildren)] :- __Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Label[(inputs::Label{.stmt_id=(_: ast::StmtId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(_: ddlog_std::Option<ast::StmtId>), .body_scope=(scope: ast::ScopeId)}: inputs::Label)], not outputs::no_unused_labels::LabelUsage[(outputs::no_unused_labels::LabelUsage{.stmt=(_: ast::StmtId), .file=(file: ast::FileId), .label_name=(name: internment::Intern<string>), .scope=(scope: ast::ScopeId)}: outputs::no_unused_labels::LabelUsage)]." .to_string(),
                                                                                                                              fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                                                                              {
                                                                                                                                  let ::types::ddlog_std::tuple2(ref file, ref scope) = *<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                                                                  Some(((::types::scopes::NeedsScopeChildren{scope: (*scope).clone(), file: (*file).clone()})).into_ddvalue())
                                                                                                                              }
                                                                                                                              __f},
                                                                                                                              next: Box::new(None)
                                                                                                                          }))
                                                                                                  })
                                                                               }))
                                                       }
                                            }],
                                        arrangements: vec![
                                            Arrangement::Map{
                                               name: r###"(scopes::NeedsScopeChildren{.scope=(_0: ast::ScopeId), .file=(_1: ast::FileId)}: scopes::NeedsScopeChildren) /*join*/"###.to_string(),
                                                afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                {
                                                    let __cloned = __v.clone();
                                                    match < ::types::scopes::NeedsScopeChildren>::from_ddvalue(__v) {
                                                        ::types::scopes::NeedsScopeChildren{scope: ref _0, file: ref _1} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                        _ => None
                                                    }.map(|x|(x,__cloned))
                                                }
                                                __f},
                                                queryable: false
                                            }],
                                        change_cb:    None
                                    };
    let scopes_FunctionLevelScope = Relation {
                                        name:         "scopes::FunctionLevelScope".to_string(),
                                        input:        false,
                                        distinct:     false,
                                        caching_mode: CachingMode::Set,
                                        key_func:     None,
                                        id:           Relations::scopes_FunctionLevelScope as RelId,
                                        rules:        vec![
                                            /* scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=scope, .nearest=scope, .file=file, .id=(ast::AnyIdFile{.file=file}: ast::AnyId)}: scopes::FunctionLevelScope)] :- inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(scope: ast::ScopeId), .config=(_: config::Config)}: inputs::File)]. */
                                            Rule::CollectionRule {
                                                description: "scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=scope, .nearest=scope, .file=file, .id=(ast::AnyIdFile{.file=file}: ast::AnyId)}: scopes::FunctionLevelScope)] :- inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(scope: ast::ScopeId), .config=(_: config::Config)}: inputs::File)].".to_string(),
                                                rel: Relations::inputs_File as RelId,
                                                xform: Some(XFormCollection::FilterMap{
                                                                description: "head of scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=scope, .nearest=scope, .file=file, .id=(ast::AnyIdFile{.file=file}: ast::AnyId)}: scopes::FunctionLevelScope)] :- inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(scope: ast::ScopeId), .config=(_: config::Config)}: inputs::File)]." .to_string(),
                                                                fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                {
                                                                    let (ref file, ref scope) = match *<::types::inputs::File>::from_ddvalue_ref(&__v) {
                                                                        ::types::inputs::File{id: ref file, kind: _, top_level_scope: ref scope, config: _} => ((*file).clone(), (*scope).clone()),
                                                                        _ => return None
                                                                    };
                                                                    Some(((::types::scopes::FunctionLevelScope{scope: (*scope).clone(), nearest: (*scope).clone(), file: (*file).clone(), id: (::types::ast::AnyId::AnyIdFile{file: (*file).clone()})})).into_ddvalue())
                                                                }
                                                                __f},
                                                                next: Box::new(None)
                                                            })
                                            },
                                            /* scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=body, .nearest=body, .file=file, .id=(ast::AnyIdFunc{.func=func}: ast::AnyId)}: scopes::FunctionLevelScope)] :- inputs::Function[(inputs::Function{.id=(func: ast::FuncId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(_: ast::ScopeId), .body=(body: ast::ScopeId), .exported=(_: bool)}: inputs::Function)]. */
                                            Rule::CollectionRule {
                                                description: "scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=body, .nearest=body, .file=file, .id=(ast::AnyIdFunc{.func=func}: ast::AnyId)}: scopes::FunctionLevelScope)] :- inputs::Function[(inputs::Function{.id=(func: ast::FuncId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(_: ast::ScopeId), .body=(body: ast::ScopeId), .exported=(_: bool)}: inputs::Function)].".to_string(),
                                                rel: Relations::inputs_Function as RelId,
                                                xform: Some(XFormCollection::FilterMap{
                                                                description: "head of scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=body, .nearest=body, .file=file, .id=(ast::AnyIdFunc{.func=func}: ast::AnyId)}: scopes::FunctionLevelScope)] :- inputs::Function[(inputs::Function{.id=(func: ast::FuncId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(_: ast::ScopeId), .body=(body: ast::ScopeId), .exported=(_: bool)}: inputs::Function)]." .to_string(),
                                                                fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                {
                                                                    let (ref func, ref file, ref body) = match *<::types::inputs::Function>::from_ddvalue_ref(&__v) {
                                                                        ::types::inputs::Function{id: ref func, file: ref file, name: _, scope: _, body: ref body, exported: _} => ((*func).clone(), (*file).clone(), (*body).clone()),
                                                                        _ => return None
                                                                    };
                                                                    Some(((::types::scopes::FunctionLevelScope{scope: (*body).clone(), nearest: (*body).clone(), file: (*file).clone(), id: (::types::ast::AnyId::AnyIdFunc{func: (*func).clone()})})).into_ddvalue())
                                                                }
                                                                __f},
                                                                next: Box::new(None)
                                                            })
                                            },
                                            /* scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=scope, .nearest=scope, .file=file, .id=(ast::AnyIdClass{.class=class}: ast::AnyId)}: scopes::FunctionLevelScope)] :- inputs::Class[(inputs::Class{.id=(class: ast::ClassId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(ddlog_std::Some{.x=(elements: ddlog_std::Vec<ast::IClassElement>)}: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Class)], var body = FlatMap(((vec::filter_map: function(ddlog_std::Vec<ast::IClassElement>, function(internment::Intern<ast::ClassElement>):ddlog_std::Option<ast::StmtId>):ddlog_std::Vec<ast::StmtId>)(elements, (function(elem: internment::Intern<ast::ClassElement>):ddlog_std::Option<ast::StmtId>{((ast::body: function(ast::ClassElement):ddlog_std::Option<ast::StmtId>)(((internment::ival: function(internment::Intern<ast::ClassElement>):ast::ClassElement)(elem))))})))), inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)]. */
                                            Rule::CollectionRule {
                                                description: "scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=scope, .nearest=scope, .file=file, .id=(ast::AnyIdClass{.class=class}: ast::AnyId)}: scopes::FunctionLevelScope)] :- inputs::Class[(inputs::Class{.id=(class: ast::ClassId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(ddlog_std::Some{.x=(elements: ddlog_std::Vec<ast::IClassElement>)}: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Class)], var body = FlatMap(((vec::filter_map: function(ddlog_std::Vec<ast::IClassElement>, function(internment::Intern<ast::ClassElement>):ddlog_std::Option<ast::StmtId>):ddlog_std::Vec<ast::StmtId>)(elements, (function(elem: internment::Intern<ast::ClassElement>):ddlog_std::Option<ast::StmtId>{((ast::body: function(ast::ClassElement):ddlog_std::Option<ast::StmtId>)(((internment::ival: function(internment::Intern<ast::ClassElement>):ast::ClassElement)(elem))))})))), inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)].".to_string(),
                                                rel: Relations::inputs_Class as RelId,
                                                xform: Some(XFormCollection::FlatMap{
                                                                description: "inputs::Class[(inputs::Class{.id=(class: ast::ClassId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(ddlog_std::Some{.x=(elements: ddlog_std::Vec<ast::IClassElement>)}: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Class)], var body = FlatMap(((vec::filter_map: function(ddlog_std::Vec<ast::IClassElement>, function(internment::Intern<ast::ClassElement>):ddlog_std::Option<ast::StmtId>):ddlog_std::Vec<ast::StmtId>)(elements, (function(elem: internment::Intern<ast::ClassElement>):ddlog_std::Option<ast::StmtId>{((ast::body: function(ast::ClassElement):ddlog_std::Option<ast::StmtId>)(((internment::ival: function(internment::Intern<ast::ClassElement>):ast::ClassElement)(elem))))}))))" .to_string(),
                                                                fmfun: {fn __f(__v: DDValue) -> Option<Box<dyn Iterator<Item=DDValue>>>
                                                                {
                                                                    let (ref class, ref file, ref elements) = match *<::types::inputs::Class>::from_ddvalue_ref(&__v) {
                                                                        ::types::inputs::Class{id: ref class, file: ref file, name: _, parent: _, elements: ::types::ddlog_std::Option::Some{x: ref elements}, scope: _, exported: _} => ((*class).clone(), (*file).clone(), (*elements).clone()),
                                                                        _ => return None
                                                                    };
                                                                    let __flattened = ::types::vec::filter_map::<::types::internment::Intern<::types::ast::ClassElement>, ::types::ast::StmtId>(elements, (&{
                                                                                                                                                                                                                (Box::new(closure::ClosureImpl{
                                                                                                                                                                                                                    description: "(function(elem: internment::Intern<ast::ClassElement>):ddlog_std::Option<ast::StmtId>{(ast::body((internment::ival(elem))))})",
                                                                                                                                                                                                                    captured: (),
                                                                                                                                                                                                                    f: {
                                                                                                                                                                                                                           fn __f(__args:*const ::types::internment::Intern<::types::ast::ClassElement>, __captured: &()) -> ::types::ddlog_std::Option<::types::ast::StmtId>
                                                                                                                                                                                                                           {
                                                                                                                                                                                                                               let elem = unsafe{&*__args};
                                                                                                                                                                                                                               ::types::ast::body_ast_ClassElement_ddlog_std_Option__ast_StmtId(::types::internment::ival(elem))
                                                                                                                                                                                                                           }
                                                                                                                                                                                                                           __f
                                                                                                                                                                                                                       }
                                                                                                                                                                                                                }) as Box<dyn closure::Closure<(*const ::types::internment::Intern<::types::ast::ClassElement>), ::types::ddlog_std::Option<::types::ast::StmtId>>>)
                                                                                                                                                                                                            }));
                                                                    let class = (*class).clone();
                                                                    let file = (*file).clone();
                                                                    Some(Box::new(__flattened.into_iter().map(move |body|(::types::ddlog_std::tuple3(body.clone(), class.clone(), file.clone())).into_ddvalue())))
                                                                }
                                                                __f},
                                                                next: Box::new(Some(XFormCollection::Arrange {
                                                                                        description: "arrange inputs::Class[(inputs::Class{.id=(class: ast::ClassId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(ddlog_std::Some{.x=(elements: ddlog_std::Vec<ast::IClassElement>)}: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Class)], var body = FlatMap(((vec::filter_map: function(ddlog_std::Vec<ast::IClassElement>, function(internment::Intern<ast::ClassElement>):ddlog_std::Option<ast::StmtId>):ddlog_std::Vec<ast::StmtId>)(elements, (function(elem: internment::Intern<ast::ClassElement>):ddlog_std::Option<ast::StmtId>{((ast::body: function(ast::ClassElement):ddlog_std::Option<ast::StmtId>)(((internment::ival: function(internment::Intern<ast::ClassElement>):ast::ClassElement)(elem))))})))) by (body, file)" .to_string(),
                                                                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                        {
                                                                                            let ::types::ddlog_std::tuple3(ref body, ref class, ref file) = *<::types::ddlog_std::tuple3<::types::ast::StmtId, ::types::ast::ClassId, ::types::ast::FileId>>::from_ddvalue_ref( &__v );
                                                                                            Some(((::types::ddlog_std::tuple2((*body).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple2((*class).clone(), (*file).clone())).into_ddvalue()))
                                                                                        }
                                                                                        __f},
                                                                                        next: Box::new(XFormArrangement::Join{
                                                                                                           description: "inputs::Class[(inputs::Class{.id=(class: ast::ClassId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(ddlog_std::Some{.x=(elements: ddlog_std::Vec<ast::IClassElement>)}: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Class)], var body = FlatMap(((vec::filter_map: function(ddlog_std::Vec<ast::IClassElement>, function(internment::Intern<ast::ClassElement>):ddlog_std::Option<ast::StmtId>):ddlog_std::Vec<ast::StmtId>)(elements, (function(elem: internment::Intern<ast::ClassElement>):ddlog_std::Option<ast::StmtId>{((ast::body: function(ast::ClassElement):ddlog_std::Option<ast::StmtId>)(((internment::ival: function(internment::Intern<ast::ClassElement>):ast::ClassElement)(elem))))})))), inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)]".to_string(),
                                                                                                           ffun: None,
                                                                                                           arrangement: (Relations::inputs_Statement as RelId,0),
                                                                                                           jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                           {
                                                                                                               let ::types::ddlog_std::tuple2(ref class, ref file) = *<::types::ddlog_std::tuple2<::types::ast::ClassId, ::types::ast::FileId>>::from_ddvalue_ref( __v1 );
                                                                                                               let ref scope = match *<::types::inputs::Statement>::from_ddvalue_ref(__v2) {
                                                                                                                   ::types::inputs::Statement{id: _, file: _, kind: _, scope: ref scope, span: _} => (*scope).clone(),
                                                                                                                   _ => return None
                                                                                                               };
                                                                                                               Some(((::types::scopes::FunctionLevelScope{scope: (*scope).clone(), nearest: (*scope).clone(), file: (*file).clone(), id: (::types::ast::AnyId::AnyIdClass{class: (*class).clone()})})).into_ddvalue())
                                                                                                           }
                                                                                                           __f},
                                                                                                           next: Box::new(None)
                                                                                                       })
                                                                                    }))
                                                            })
                                            },
                                            /* scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=scope, .nearest=scope, .file=file, .id=(ast::AnyIdExpr{.expr=expr}: ast::AnyId)}: scopes::FunctionLevelScope)] :- inputs::ClassExpr[(inputs::ClassExpr{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .elements=(ddlog_std::Some{.x=(elements: ddlog_std::Vec<ast::IClassElement>)}: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>)}: inputs::ClassExpr)], var body = FlatMap(((vec::filter_map: function(ddlog_std::Vec<ast::IClassElement>, function(internment::Intern<ast::ClassElement>):ddlog_std::Option<ast::StmtId>):ddlog_std::Vec<ast::StmtId>)(elements, (function(elem: internment::Intern<ast::ClassElement>):ddlog_std::Option<ast::StmtId>{((ast::body: function(ast::ClassElement):ddlog_std::Option<ast::StmtId>)(((internment::ival: function(internment::Intern<ast::ClassElement>):ast::ClassElement)(elem))))})))), inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)]. */
                                            Rule::CollectionRule {
                                                description: "scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=scope, .nearest=scope, .file=file, .id=(ast::AnyIdExpr{.expr=expr}: ast::AnyId)}: scopes::FunctionLevelScope)] :- inputs::ClassExpr[(inputs::ClassExpr{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .elements=(ddlog_std::Some{.x=(elements: ddlog_std::Vec<ast::IClassElement>)}: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>)}: inputs::ClassExpr)], var body = FlatMap(((vec::filter_map: function(ddlog_std::Vec<ast::IClassElement>, function(internment::Intern<ast::ClassElement>):ddlog_std::Option<ast::StmtId>):ddlog_std::Vec<ast::StmtId>)(elements, (function(elem: internment::Intern<ast::ClassElement>):ddlog_std::Option<ast::StmtId>{((ast::body: function(ast::ClassElement):ddlog_std::Option<ast::StmtId>)(((internment::ival: function(internment::Intern<ast::ClassElement>):ast::ClassElement)(elem))))})))), inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)].".to_string(),
                                                rel: Relations::inputs_ClassExpr as RelId,
                                                xform: Some(XFormCollection::FlatMap{
                                                                description: "inputs::ClassExpr[(inputs::ClassExpr{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .elements=(ddlog_std::Some{.x=(elements: ddlog_std::Vec<ast::IClassElement>)}: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>)}: inputs::ClassExpr)], var body = FlatMap(((vec::filter_map: function(ddlog_std::Vec<ast::IClassElement>, function(internment::Intern<ast::ClassElement>):ddlog_std::Option<ast::StmtId>):ddlog_std::Vec<ast::StmtId>)(elements, (function(elem: internment::Intern<ast::ClassElement>):ddlog_std::Option<ast::StmtId>{((ast::body: function(ast::ClassElement):ddlog_std::Option<ast::StmtId>)(((internment::ival: function(internment::Intern<ast::ClassElement>):ast::ClassElement)(elem))))}))))" .to_string(),
                                                                fmfun: {fn __f(__v: DDValue) -> Option<Box<dyn Iterator<Item=DDValue>>>
                                                                {
                                                                    let (ref expr, ref file, ref elements) = match *<::types::inputs::ClassExpr>::from_ddvalue_ref(&__v) {
                                                                        ::types::inputs::ClassExpr{expr_id: ref expr, file: ref file, elements: ::types::ddlog_std::Option::Some{x: ref elements}} => ((*expr).clone(), (*file).clone(), (*elements).clone()),
                                                                        _ => return None
                                                                    };
                                                                    let __flattened = ::types::vec::filter_map::<::types::internment::Intern<::types::ast::ClassElement>, ::types::ast::StmtId>(elements, (&{
                                                                                                                                                                                                                (Box::new(closure::ClosureImpl{
                                                                                                                                                                                                                    description: "(function(elem: internment::Intern<ast::ClassElement>):ddlog_std::Option<ast::StmtId>{(ast::body((internment::ival(elem))))})",
                                                                                                                                                                                                                    captured: (),
                                                                                                                                                                                                                    f: {
                                                                                                                                                                                                                           fn __f(__args:*const ::types::internment::Intern<::types::ast::ClassElement>, __captured: &()) -> ::types::ddlog_std::Option<::types::ast::StmtId>
                                                                                                                                                                                                                           {
                                                                                                                                                                                                                               let elem = unsafe{&*__args};
                                                                                                                                                                                                                               ::types::ast::body_ast_ClassElement_ddlog_std_Option__ast_StmtId(::types::internment::ival(elem))
                                                                                                                                                                                                                           }
                                                                                                                                                                                                                           __f
                                                                                                                                                                                                                       }
                                                                                                                                                                                                                }) as Box<dyn closure::Closure<(*const ::types::internment::Intern<::types::ast::ClassElement>), ::types::ddlog_std::Option<::types::ast::StmtId>>>)
                                                                                                                                                                                                            }));
                                                                    let expr = (*expr).clone();
                                                                    let file = (*file).clone();
                                                                    Some(Box::new(__flattened.into_iter().map(move |body|(::types::ddlog_std::tuple3(body.clone(), expr.clone(), file.clone())).into_ddvalue())))
                                                                }
                                                                __f},
                                                                next: Box::new(Some(XFormCollection::Arrange {
                                                                                        description: "arrange inputs::ClassExpr[(inputs::ClassExpr{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .elements=(ddlog_std::Some{.x=(elements: ddlog_std::Vec<ast::IClassElement>)}: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>)}: inputs::ClassExpr)], var body = FlatMap(((vec::filter_map: function(ddlog_std::Vec<ast::IClassElement>, function(internment::Intern<ast::ClassElement>):ddlog_std::Option<ast::StmtId>):ddlog_std::Vec<ast::StmtId>)(elements, (function(elem: internment::Intern<ast::ClassElement>):ddlog_std::Option<ast::StmtId>{((ast::body: function(ast::ClassElement):ddlog_std::Option<ast::StmtId>)(((internment::ival: function(internment::Intern<ast::ClassElement>):ast::ClassElement)(elem))))})))) by (body, file)" .to_string(),
                                                                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                        {
                                                                                            let ::types::ddlog_std::tuple3(ref body, ref expr, ref file) = *<::types::ddlog_std::tuple3<::types::ast::StmtId, ::types::ast::ExprId, ::types::ast::FileId>>::from_ddvalue_ref( &__v );
                                                                                            Some(((::types::ddlog_std::tuple2((*body).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple2((*expr).clone(), (*file).clone())).into_ddvalue()))
                                                                                        }
                                                                                        __f},
                                                                                        next: Box::new(XFormArrangement::Join{
                                                                                                           description: "inputs::ClassExpr[(inputs::ClassExpr{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .elements=(ddlog_std::Some{.x=(elements: ddlog_std::Vec<ast::IClassElement>)}: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>)}: inputs::ClassExpr)], var body = FlatMap(((vec::filter_map: function(ddlog_std::Vec<ast::IClassElement>, function(internment::Intern<ast::ClassElement>):ddlog_std::Option<ast::StmtId>):ddlog_std::Vec<ast::StmtId>)(elements, (function(elem: internment::Intern<ast::ClassElement>):ddlog_std::Option<ast::StmtId>{((ast::body: function(ast::ClassElement):ddlog_std::Option<ast::StmtId>)(((internment::ival: function(internment::Intern<ast::ClassElement>):ast::ClassElement)(elem))))})))), inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)]".to_string(),
                                                                                                           ffun: None,
                                                                                                           arrangement: (Relations::inputs_Statement as RelId,0),
                                                                                                           jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                           {
                                                                                                               let ::types::ddlog_std::tuple2(ref expr, ref file) = *<::types::ddlog_std::tuple2<::types::ast::ExprId, ::types::ast::FileId>>::from_ddvalue_ref( __v1 );
                                                                                                               let ref scope = match *<::types::inputs::Statement>::from_ddvalue_ref(__v2) {
                                                                                                                   ::types::inputs::Statement{id: _, file: _, kind: _, scope: ref scope, span: _} => (*scope).clone(),
                                                                                                                   _ => return None
                                                                                                               };
                                                                                                               Some(((::types::scopes::FunctionLevelScope{scope: (*scope).clone(), nearest: (*scope).clone(), file: (*file).clone(), id: (::types::ast::AnyId::AnyIdExpr{expr: (*expr).clone()})})).into_ddvalue())
                                                                                                           }
                                                                                                           __f},
                                                                                                           next: Box::new(None)
                                                                                                       })
                                                                                    }))
                                                            })
                                            },
                                            /* scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=scope, .nearest=scope, .file=file, .id=(ast::AnyIdExpr{.expr=expr}: ast::AnyId)}: scopes::FunctionLevelScope)] :- inputs::InlineFunc[(inputs::InlineFunc{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(ddlog_std::Some{.x=(body: ast::StmtId)}: ddlog_std::Option<ast::StmtId>)}: inputs::InlineFunc)], inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)]. */
                                            Rule::ArrangementRule {
                                                description: "scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=scope, .nearest=scope, .file=file, .id=(ast::AnyIdExpr{.expr=expr}: ast::AnyId)}: scopes::FunctionLevelScope)] :- inputs::InlineFunc[(inputs::InlineFunc{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(ddlog_std::Some{.x=(body: ast::StmtId)}: ddlog_std::Option<ast::StmtId>)}: inputs::InlineFunc)], inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)].".to_string(),
                                                arr: ( Relations::inputs_InlineFunc as RelId, 0),
                                                xform: XFormArrangement::Join{
                                                           description: "inputs::InlineFunc[(inputs::InlineFunc{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(ddlog_std::Some{.x=(body: ast::StmtId)}: ddlog_std::Option<ast::StmtId>)}: inputs::InlineFunc)], inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)]".to_string(),
                                                           ffun: None,
                                                           arrangement: (Relations::inputs_Statement as RelId,0),
                                                           jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                           {
                                                               let (ref expr, ref file, ref body) = match *<::types::inputs::InlineFunc>::from_ddvalue_ref(__v1) {
                                                                   ::types::inputs::InlineFunc{expr_id: ref expr, file: ref file, name: _, body: ::types::ddlog_std::Option::Some{x: ref body}} => ((*expr).clone(), (*file).clone(), (*body).clone()),
                                                                   _ => return None
                                                               };
                                                               let ref scope = match *<::types::inputs::Statement>::from_ddvalue_ref(__v2) {
                                                                   ::types::inputs::Statement{id: _, file: _, kind: _, scope: ref scope, span: _} => (*scope).clone(),
                                                                   _ => return None
                                                               };
                                                               Some(((::types::scopes::FunctionLevelScope{scope: (*scope).clone(), nearest: (*scope).clone(), file: (*file).clone(), id: (::types::ast::AnyId::AnyIdExpr{expr: (*expr).clone()})})).into_ddvalue())
                                                           }
                                                           __f},
                                                           next: Box::new(None)
                                                       }
                                            },
                                            /* scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=scope, .nearest=scope, .file=file, .id=(ast::AnyIdExpr{.expr=expr}: ast::AnyId)}: scopes::FunctionLevelScope)] :- inputs::Property[(inputs::Property{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .key=(_: ddlog_std::Option<ast::PropertyKey>), .val=(ddlog_std::Some{.x=(val: ast::PropertyVal)}: ddlog_std::Option<ast::PropertyVal>)}: inputs::Property)], ((ddlog_std::Some{.x=(var body: ast::StmtId)}: ddlog_std::Option<ast::StmtId>) = ((ast::body: function(ast::PropertyVal):ddlog_std::Option<ast::StmtId>)(val))), inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)]. */
                                            Rule::CollectionRule {
                                                description: "scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=scope, .nearest=scope, .file=file, .id=(ast::AnyIdExpr{.expr=expr}: ast::AnyId)}: scopes::FunctionLevelScope)] :- inputs::Property[(inputs::Property{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .key=(_: ddlog_std::Option<ast::PropertyKey>), .val=(ddlog_std::Some{.x=(val: ast::PropertyVal)}: ddlog_std::Option<ast::PropertyVal>)}: inputs::Property)], ((ddlog_std::Some{.x=(var body: ast::StmtId)}: ddlog_std::Option<ast::StmtId>) = ((ast::body: function(ast::PropertyVal):ddlog_std::Option<ast::StmtId>)(val))), inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)].".to_string(),
                                                rel: Relations::inputs_Property as RelId,
                                                xform: Some(XFormCollection::Arrange {
                                                                description: "arrange inputs::Property[(inputs::Property{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .key=(_: ddlog_std::Option<ast::PropertyKey>), .val=(ddlog_std::Some{.x=(val: ast::PropertyVal)}: ddlog_std::Option<ast::PropertyVal>)}: inputs::Property)] by (body, file)" .to_string(),
                                                                afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                {
                                                                    let (ref expr, ref file, ref val) = match *<::types::inputs::Property>::from_ddvalue_ref(&__v) {
                                                                        ::types::inputs::Property{expr_id: ref expr, file: ref file, key: _, val: ::types::ddlog_std::Option::Some{x: ref val}} => ((*expr).clone(), (*file).clone(), (*val).clone()),
                                                                        _ => return None
                                                                    };
                                                                    let ref body: ::types::ast::StmtId = match ::types::ast::body_ast_PropertyVal_ddlog_std_Option__ast_StmtId(val) {
                                                                        ::types::ddlog_std::Option::Some{x: body} => body,
                                                                        _ => return None
                                                                    };
                                                                    Some(((::types::ddlog_std::tuple2((*body).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple2((*expr).clone(), (*file).clone())).into_ddvalue()))
                                                                }
                                                                __f},
                                                                next: Box::new(XFormArrangement::Join{
                                                                                   description: "inputs::Property[(inputs::Property{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .key=(_: ddlog_std::Option<ast::PropertyKey>), .val=(ddlog_std::Some{.x=(val: ast::PropertyVal)}: ddlog_std::Option<ast::PropertyVal>)}: inputs::Property)], ((ddlog_std::Some{.x=(var body: ast::StmtId)}: ddlog_std::Option<ast::StmtId>) = ((ast::body: function(ast::PropertyVal):ddlog_std::Option<ast::StmtId>)(val))), inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)]".to_string(),
                                                                                   ffun: None,
                                                                                   arrangement: (Relations::inputs_Statement as RelId,0),
                                                                                   jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                   {
                                                                                       let ::types::ddlog_std::tuple2(ref expr, ref file) = *<::types::ddlog_std::tuple2<::types::ast::ExprId, ::types::ast::FileId>>::from_ddvalue_ref( __v1 );
                                                                                       let ref scope = match *<::types::inputs::Statement>::from_ddvalue_ref(__v2) {
                                                                                           ::types::inputs::Statement{id: _, file: _, kind: _, scope: ref scope, span: _} => (*scope).clone(),
                                                                                           _ => return None
                                                                                       };
                                                                                       Some(((::types::scopes::FunctionLevelScope{scope: (*scope).clone(), nearest: (*scope).clone(), file: (*file).clone(), id: (::types::ast::AnyId::AnyIdExpr{expr: (*expr).clone()})})).into_ddvalue())
                                                                                   }
                                                                                   __f},
                                                                                   next: Box::new(None)
                                                                               })
                                                            })
                                            },
                                            /* scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=scope, .nearest=scope, .file=file, .id=(ast::AnyIdExpr{.expr=expr}: ast::AnyId)}: scopes::FunctionLevelScope)] :- inputs::Arrow[(inputs::Arrow{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .body=(ddlog_std::Some{.x=((_: ddlog_std::Either<ast::ExprId,ast::StmtId>), (scope: ast::ScopeId))}: ddlog_std::Option<(ddlog_std::Either<ast::ExprId,ast::StmtId>, ast::ScopeId)>)}: inputs::Arrow)]. */
                                            Rule::CollectionRule {
                                                description: "scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=scope, .nearest=scope, .file=file, .id=(ast::AnyIdExpr{.expr=expr}: ast::AnyId)}: scopes::FunctionLevelScope)] :- inputs::Arrow[(inputs::Arrow{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .body=(ddlog_std::Some{.x=((_: ddlog_std::Either<ast::ExprId,ast::StmtId>), (scope: ast::ScopeId))}: ddlog_std::Option<(ddlog_std::Either<ast::ExprId,ast::StmtId>, ast::ScopeId)>)}: inputs::Arrow)].".to_string(),
                                                rel: Relations::inputs_Arrow as RelId,
                                                xform: Some(XFormCollection::FilterMap{
                                                                description: "head of scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=scope, .nearest=scope, .file=file, .id=(ast::AnyIdExpr{.expr=expr}: ast::AnyId)}: scopes::FunctionLevelScope)] :- inputs::Arrow[(inputs::Arrow{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .body=(ddlog_std::Some{.x=((_: ddlog_std::Either<ast::ExprId,ast::StmtId>), (scope: ast::ScopeId))}: ddlog_std::Option<(ddlog_std::Either<ast::ExprId,ast::StmtId>, ast::ScopeId)>)}: inputs::Arrow)]." .to_string(),
                                                                fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                {
                                                                    let (ref expr, ref file, ref scope) = match *<::types::inputs::Arrow>::from_ddvalue_ref(&__v) {
                                                                        ::types::inputs::Arrow{expr_id: ref expr, file: ref file, body: ::types::ddlog_std::Option::Some{x: ::types::ddlog_std::tuple2(_, ref scope)}} => ((*expr).clone(), (*file).clone(), (*scope).clone()),
                                                                        _ => return None
                                                                    };
                                                                    Some(((::types::scopes::FunctionLevelScope{scope: (*scope).clone(), nearest: (*scope).clone(), file: (*file).clone(), id: (::types::ast::AnyId::AnyIdExpr{expr: (*expr).clone()})})).into_ddvalue())
                                                                }
                                                                __f},
                                                                next: Box::new(None)
                                                            })
                                            },
                                            /* scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=child, .nearest=scope, .file=file, .id=id}: scopes::FunctionLevelScope)] :- scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=(parent: ast::ScopeId), .nearest=(scope: ast::ScopeId), .file=(file: ast::FileId), .id=(id: ast::AnyId)}: scopes::FunctionLevelScope)], inputs::InputScope[(inputs::InputScope{.parent=(parent: ast::ScopeId), .child=(child: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)], var __group = (scope, id).group_by((child, file)), (((var scope: ast::ScopeId), (var id: ast::AnyId)) = ((group::arg_max: function(ddlog_std::Group<(ast::ScopeId, ast::FileId),(ast::ScopeId, ast::AnyId)>, function((ast::ScopeId, ast::AnyId)):ast::ScopeId):(ast::ScopeId, ast::AnyId))(__group, (function(scope: (ast::ScopeId, ast::AnyId)):ast::ScopeId{(scope.0)})))). */
                                            Rule::ArrangementRule {
                                                description: "scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=child, .nearest=scope, .file=file, .id=id}: scopes::FunctionLevelScope)] :- scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=(parent: ast::ScopeId), .nearest=(scope: ast::ScopeId), .file=(file: ast::FileId), .id=(id: ast::AnyId)}: scopes::FunctionLevelScope)], inputs::InputScope[(inputs::InputScope{.parent=(parent: ast::ScopeId), .child=(child: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)], var __group = (scope, id).group_by((child, file)), (((var scope: ast::ScopeId), (var id: ast::AnyId)) = ((group::arg_max: function(ddlog_std::Group<(ast::ScopeId, ast::FileId),(ast::ScopeId, ast::AnyId)>, function((ast::ScopeId, ast::AnyId)):ast::ScopeId):(ast::ScopeId, ast::AnyId))(__group, (function(scope: (ast::ScopeId, ast::AnyId)):ast::ScopeId{(scope.0)})))).".to_string(),
                                                arr: ( Relations::scopes_FunctionLevelScope as RelId, 0),
                                                xform: XFormArrangement::Join{
                                                           description: "scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=(parent: ast::ScopeId), .nearest=(scope: ast::ScopeId), .file=(file: ast::FileId), .id=(id: ast::AnyId)}: scopes::FunctionLevelScope)], inputs::InputScope[(inputs::InputScope{.parent=(parent: ast::ScopeId), .child=(child: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)]".to_string(),
                                                           ffun: None,
                                                           arrangement: (Relations::inputs_InputScope as RelId,1),
                                                           jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                           {
                                                               let (ref parent, ref scope, ref file, ref id) = match *<::types::scopes::FunctionLevelScope>::from_ddvalue_ref(__v1) {
                                                                   ::types::scopes::FunctionLevelScope{scope: ref parent, nearest: ref scope, file: ref file, id: ref id} => ((*parent).clone(), (*scope).clone(), (*file).clone(), (*id).clone()),
                                                                   _ => return None
                                                               };
                                                               let ref child = match *<::types::inputs::InputScope>::from_ddvalue_ref(__v2) {
                                                                   ::types::inputs::InputScope{parent: _, child: ref child, file: _} => (*child).clone(),
                                                                   _ => return None
                                                               };
                                                               Some((::types::ddlog_std::tuple5((*parent).clone(), (*scope).clone(), (*file).clone(), (*id).clone(), (*child).clone())).into_ddvalue())
                                                           }
                                                           __f},
                                                           next: Box::new(Some(XFormCollection::Arrange {
                                                                                   description: "arrange scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=(parent: ast::ScopeId), .nearest=(scope: ast::ScopeId), .file=(file: ast::FileId), .id=(id: ast::AnyId)}: scopes::FunctionLevelScope)], inputs::InputScope[(inputs::InputScope{.parent=(parent: ast::ScopeId), .child=(child: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)] by (child, file)" .to_string(),
                                                                                   afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                   {
                                                                                       let ::types::ddlog_std::tuple5(ref parent, ref scope, ref file, ref id, ref child) = *<::types::ddlog_std::tuple5<::types::ast::ScopeId, ::types::ast::ScopeId, ::types::ast::FileId, ::types::ast::AnyId, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                       Some(((::types::ddlog_std::tuple2((*child).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple5((*parent).clone(), (*scope).clone(), (*file).clone(), (*id).clone(), (*child).clone())).into_ddvalue()))
                                                                                   }
                                                                                   __f},
                                                                                   next: Box::new(XFormArrangement::Aggregate{
                                                                                                      description: "scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=(parent: ast::ScopeId), .nearest=(scope: ast::ScopeId), .file=(file: ast::FileId), .id=(id: ast::AnyId)}: scopes::FunctionLevelScope)], inputs::InputScope[(inputs::InputScope{.parent=(parent: ast::ScopeId), .child=(child: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)], var __group = (scope, id).group_by((child, file))".to_string(),
                                                                                                      ffun: None,
                                                                                                      aggfun: {fn __f(__key: &DDValue, __group__: &[(&DDValue, Weight)]) -> Option<DDValue>
                                                                                                  {
                                                                                                      let ::types::ddlog_std::tuple2(ref child, ref file) = *<::types::ddlog_std::tuple2<::types::ast::ScopeId, ::types::ast::FileId>>::from_ddvalue_ref( __key );
                                                                                                      let ref __group = unsafe{::types::ddlog_std::Group::new_by_ref(::types::ddlog_std::tuple2((*child).clone(), (*file).clone()), __group__, {fn __f(__v: &DDValue) ->  ::types::ddlog_std::tuple2<::types::ast::ScopeId, ::types::ast::AnyId>
                                                                                                                                                                                                                                               {
                                                                                                                                                                                                                                                   let ::types::ddlog_std::tuple5(ref parent, ref scope, ref file, ref id, ref child) = *<::types::ddlog_std::tuple5<::types::ast::ScopeId, ::types::ast::ScopeId, ::types::ast::FileId, ::types::ast::AnyId, ::types::ast::ScopeId>>::from_ddvalue_ref( __v );
                                                                                                                                                                                                                                                   ::types::ddlog_std::tuple2((*scope).clone(), (*id).clone())
                                                                                                                                                                                                                                               }
                                                                                                                                                                                                                                               ::std::sync::Arc::new(__f)})};
                                                                                                      let (ref scope, ref id): (::types::ast::ScopeId, ::types::ast::AnyId) = match ::types::group::arg_max::<::types::ddlog_std::tuple2<::types::ast::ScopeId, ::types::ast::FileId>, ::types::ddlog_std::tuple2<::types::ast::ScopeId, ::types::ast::AnyId>, ::types::ast::ScopeId>(__group, (&{
                                                                                                                                                                                                                                                                                                                                                                                                     (Box::new(closure::ClosureImpl{
                                                                                                                                                                                                                                                                                                                                                                                                         description: "(function(scope: (ast::ScopeId, ast::AnyId)):ast::ScopeId{(scope.0)})",
                                                                                                                                                                                                                                                                                                                                                                                                         captured: (),
                                                                                                                                                                                                                                                                                                                                                                                                         f: {
                                                                                                                                                                                                                                                                                                                                                                                                                fn __f(__args:*const ::types::ddlog_std::tuple2<::types::ast::ScopeId, ::types::ast::AnyId>, __captured: &()) -> ::types::ast::ScopeId
                                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                                    let scope = unsafe{&*__args};
                                                                                                                                                                                                                                                                                                                                                                                                                    (scope.0).clone()
                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                __f
                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                     }) as Box<dyn closure::Closure<(*const ::types::ddlog_std::tuple2<::types::ast::ScopeId, ::types::ast::AnyId>), ::types::ast::ScopeId>>)
                                                                                                                                                                                                                                                                                                                                                                                                 })) {
                                                                                                          ::types::ddlog_std::tuple2(scope, id) => (scope, id),
                                                                                                          _ => return None
                                                                                                      };
                                                                                                      Some((::types::ddlog_std::tuple4((*child).clone(), (*file).clone(), (*scope).clone(), (*id).clone())).into_ddvalue())
                                                                                                  }
                                                                                                  __f},
                                                                                                      next: Box::new(Some(XFormCollection::FilterMap{
                                                                                                                              description: "head of scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=child, .nearest=scope, .file=file, .id=id}: scopes::FunctionLevelScope)] :- scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=(parent: ast::ScopeId), .nearest=(scope: ast::ScopeId), .file=(file: ast::FileId), .id=(id: ast::AnyId)}: scopes::FunctionLevelScope)], inputs::InputScope[(inputs::InputScope{.parent=(parent: ast::ScopeId), .child=(child: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)], var __group = (scope, id).group_by((child, file)), (((var scope: ast::ScopeId), (var id: ast::AnyId)) = ((group::arg_max: function(ddlog_std::Group<(ast::ScopeId, ast::FileId),(ast::ScopeId, ast::AnyId)>, function((ast::ScopeId, ast::AnyId)):ast::ScopeId):(ast::ScopeId, ast::AnyId))(__group, (function(scope: (ast::ScopeId, ast::AnyId)):ast::ScopeId{(scope.0)}))))." .to_string(),
                                                                                                                              fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                                                                              {
                                                                                                                                  let ::types::ddlog_std::tuple4(ref child, ref file, ref scope, ref id) = *<::types::ddlog_std::tuple4<::types::ast::ScopeId, ::types::ast::FileId, ::types::ast::ScopeId, ::types::ast::AnyId>>::from_ddvalue_ref( &__v );
                                                                                                                                  Some(((::types::scopes::FunctionLevelScope{scope: (*child).clone(), nearest: (*scope).clone(), file: (*file).clone(), id: (*id).clone()})).into_ddvalue())
                                                                                                                              }
                                                                                                                              __f},
                                                                                                                              next: Box::new(None)
                                                                                                                          }))
                                                                                                  })
                                                                               }))
                                                       }
                                            }],
                                        arrangements: vec![
                                            Arrangement::Map{
                                               name: r###"(scopes::FunctionLevelScope{.scope=(_0: ast::ScopeId), .nearest=(_: ast::ScopeId), .file=(_1: ast::FileId), .id=(_: ast::AnyId)}: scopes::FunctionLevelScope) /*join*/"###.to_string(),
                                                afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                {
                                                    let __cloned = __v.clone();
                                                    match < ::types::scopes::FunctionLevelScope>::from_ddvalue(__v) {
                                                        ::types::scopes::FunctionLevelScope{scope: ref _0, nearest: _, file: ref _1, id: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                        _ => None
                                                    }.map(|x|(x,__cloned))
                                                }
                                                __f},
                                                queryable: false
                                            }],
                                        change_cb:    None
                                    };
    let scopes_ScopeOfId = Relation {
                               name:         "scopes::ScopeOfId".to_string(),
                               input:        false,
                               distinct:     false,
                               caching_mode: CachingMode::Set,
                               key_func:     None,
                               id:           Relations::scopes_ScopeOfId as RelId,
                               rules:        vec![
                                   /* scopes::ScopeOfId[(scopes::ScopeOfId{.id=(ast::AnyIdFile{.file=id}: ast::AnyId), .file=id, .scope=scope}: scopes::ScopeOfId)] :- inputs::File[(inputs::File{.id=(id: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(scope: ast::ScopeId), .config=(_: config::Config)}: inputs::File)]. */
                                   Rule::CollectionRule {
                                       description: "scopes::ScopeOfId[(scopes::ScopeOfId{.id=(ast::AnyIdFile{.file=id}: ast::AnyId), .file=id, .scope=scope}: scopes::ScopeOfId)] :- inputs::File[(inputs::File{.id=(id: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(scope: ast::ScopeId), .config=(_: config::Config)}: inputs::File)].".to_string(),
                                       rel: Relations::inputs_File as RelId,
                                       xform: Some(XFormCollection::FilterMap{
                                                       description: "head of scopes::ScopeOfId[(scopes::ScopeOfId{.id=(ast::AnyIdFile{.file=id}: ast::AnyId), .file=id, .scope=scope}: scopes::ScopeOfId)] :- inputs::File[(inputs::File{.id=(id: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(scope: ast::ScopeId), .config=(_: config::Config)}: inputs::File)]." .to_string(),
                                                       fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                       {
                                                           let (ref id, ref scope) = match *<::types::inputs::File>::from_ddvalue_ref(&__v) {
                                                               ::types::inputs::File{id: ref id, kind: _, top_level_scope: ref scope, config: _} => ((*id).clone(), (*scope).clone()),
                                                               _ => return None
                                                           };
                                                           Some(((::types::scopes::ScopeOfId{id: (::types::ast::AnyId::AnyIdFile{file: (*id).clone()}), file: (*id).clone(), scope: (*scope).clone()})).into_ddvalue())
                                                       }
                                                       __f},
                                                       next: Box::new(None)
                                                   })
                                   },
                                   /* scopes::ScopeOfId[(scopes::ScopeOfId{.id=(ast::AnyIdFunc{.func=id}: ast::AnyId), .file=file, .scope=scope}: scopes::ScopeOfId)] :- inputs::Function[(inputs::Function{.id=(id: ast::FuncId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(scope: ast::ScopeId), .body=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Function)]. */
                                   Rule::CollectionRule {
                                       description: "scopes::ScopeOfId[(scopes::ScopeOfId{.id=(ast::AnyIdFunc{.func=id}: ast::AnyId), .file=file, .scope=scope}: scopes::ScopeOfId)] :- inputs::Function[(inputs::Function{.id=(id: ast::FuncId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(scope: ast::ScopeId), .body=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Function)].".to_string(),
                                       rel: Relations::inputs_Function as RelId,
                                       xform: Some(XFormCollection::FilterMap{
                                                       description: "head of scopes::ScopeOfId[(scopes::ScopeOfId{.id=(ast::AnyIdFunc{.func=id}: ast::AnyId), .file=file, .scope=scope}: scopes::ScopeOfId)] :- inputs::Function[(inputs::Function{.id=(id: ast::FuncId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(scope: ast::ScopeId), .body=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Function)]." .to_string(),
                                                       fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                       {
                                                           let (ref id, ref file, ref scope) = match *<::types::inputs::Function>::from_ddvalue_ref(&__v) {
                                                               ::types::inputs::Function{id: ref id, file: ref file, name: _, scope: ref scope, body: _, exported: _} => ((*id).clone(), (*file).clone(), (*scope).clone()),
                                                               _ => return None
                                                           };
                                                           Some(((::types::scopes::ScopeOfId{id: (::types::ast::AnyId::AnyIdFunc{func: (*id).clone()}), file: (*file).clone(), scope: (*scope).clone()})).into_ddvalue())
                                                       }
                                                       __f},
                                                       next: Box::new(None)
                                                   })
                                   },
                                   /* scopes::ScopeOfId[(scopes::ScopeOfId{.id=(ast::AnyIdClass{.class=id}: ast::AnyId), .file=file, .scope=scope}: scopes::ScopeOfId)] :- inputs::Class[(inputs::Class{.id=(id: ast::ClassId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(scope: ast::ScopeId), .exported=(_: bool)}: inputs::Class)]. */
                                   Rule::CollectionRule {
                                       description: "scopes::ScopeOfId[(scopes::ScopeOfId{.id=(ast::AnyIdClass{.class=id}: ast::AnyId), .file=file, .scope=scope}: scopes::ScopeOfId)] :- inputs::Class[(inputs::Class{.id=(id: ast::ClassId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(scope: ast::ScopeId), .exported=(_: bool)}: inputs::Class)].".to_string(),
                                       rel: Relations::inputs_Class as RelId,
                                       xform: Some(XFormCollection::FilterMap{
                                                       description: "head of scopes::ScopeOfId[(scopes::ScopeOfId{.id=(ast::AnyIdClass{.class=id}: ast::AnyId), .file=file, .scope=scope}: scopes::ScopeOfId)] :- inputs::Class[(inputs::Class{.id=(id: ast::ClassId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(scope: ast::ScopeId), .exported=(_: bool)}: inputs::Class)]." .to_string(),
                                                       fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                       {
                                                           let (ref id, ref file, ref scope) = match *<::types::inputs::Class>::from_ddvalue_ref(&__v) {
                                                               ::types::inputs::Class{id: ref id, file: ref file, name: _, parent: _, elements: _, scope: ref scope, exported: _} => ((*id).clone(), (*file).clone(), (*scope).clone()),
                                                               _ => return None
                                                           };
                                                           Some(((::types::scopes::ScopeOfId{id: (::types::ast::AnyId::AnyIdClass{class: (*id).clone()}), file: (*file).clone(), scope: (*scope).clone()})).into_ddvalue())
                                                       }
                                                       __f},
                                                       next: Box::new(None)
                                                   })
                                   },
                                   /* scopes::ScopeOfId[(scopes::ScopeOfId{.id=(ast::AnyIdStmt{.stmt=id}: ast::AnyId), .file=file, .scope=scope}: scopes::ScopeOfId)] :- inputs::Statement[(inputs::Statement{.id=(id: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)]. */
                                   Rule::CollectionRule {
                                       description: "scopes::ScopeOfId[(scopes::ScopeOfId{.id=(ast::AnyIdStmt{.stmt=id}: ast::AnyId), .file=file, .scope=scope}: scopes::ScopeOfId)] :- inputs::Statement[(inputs::Statement{.id=(id: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)].".to_string(),
                                       rel: Relations::inputs_Statement as RelId,
                                       xform: Some(XFormCollection::FilterMap{
                                                       description: "head of scopes::ScopeOfId[(scopes::ScopeOfId{.id=(ast::AnyIdStmt{.stmt=id}: ast::AnyId), .file=file, .scope=scope}: scopes::ScopeOfId)] :- inputs::Statement[(inputs::Statement{.id=(id: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)]." .to_string(),
                                                       fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                       {
                                                           let (ref id, ref file, ref scope) = match *<::types::inputs::Statement>::from_ddvalue_ref(&__v) {
                                                               ::types::inputs::Statement{id: ref id, file: ref file, kind: _, scope: ref scope, span: _} => ((*id).clone(), (*file).clone(), (*scope).clone()),
                                                               _ => return None
                                                           };
                                                           Some(((::types::scopes::ScopeOfId{id: (::types::ast::AnyId::AnyIdStmt{stmt: (*id).clone()}), file: (*file).clone(), scope: (*scope).clone()})).into_ddvalue())
                                                       }
                                                       __f},
                                                       next: Box::new(None)
                                                   })
                                   },
                                   /* scopes::ScopeOfId[(scopes::ScopeOfId{.id=(ast::AnyIdExpr{.expr=id}: ast::AnyId), .file=file, .scope=scope}: scopes::ScopeOfId)] :- inputs::Expression[(inputs::Expression{.id=(id: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression)]. */
                                   Rule::CollectionRule {
                                       description: "scopes::ScopeOfId[(scopes::ScopeOfId{.id=(ast::AnyIdExpr{.expr=id}: ast::AnyId), .file=file, .scope=scope}: scopes::ScopeOfId)] :- inputs::Expression[(inputs::Expression{.id=(id: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression)].".to_string(),
                                       rel: Relations::inputs_Expression as RelId,
                                       xform: Some(XFormCollection::FilterMap{
                                                       description: "head of scopes::ScopeOfId[(scopes::ScopeOfId{.id=(ast::AnyIdExpr{.expr=id}: ast::AnyId), .file=file, .scope=scope}: scopes::ScopeOfId)] :- inputs::Expression[(inputs::Expression{.id=(id: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression)]." .to_string(),
                                                       fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                       {
                                                           let (ref id, ref file, ref scope) = match *<::types::inputs::Expression>::from_ddvalue_ref(&__v) {
                                                               ::types::inputs::Expression{id: ref id, file: ref file, kind: _, scope: ref scope, span: _} => ((*id).clone(), (*file).clone(), (*scope).clone()),
                                                               _ => return None
                                                           };
                                                           Some(((::types::scopes::ScopeOfId{id: (::types::ast::AnyId::AnyIdExpr{expr: (*id).clone()}), file: (*file).clone(), scope: (*scope).clone()})).into_ddvalue())
                                                       }
                                                       __f},
                                                       next: Box::new(None)
                                                   })
                                   },
                                   /* scopes::ScopeOfId[(scopes::ScopeOfId{.id=(ast::AnyIdImport{.import_=id}: ast::AnyId), .file=file, .scope=scope}: scopes::ScopeOfId)] :- inputs::ImportDecl[(inputs::ImportDecl{.id=(id: ast::ImportId), .file=(file: ast::FileId), .clause=(_: ast::ImportClause)}: inputs::ImportDecl)], inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(scope: ast::ScopeId), .config=(_: config::Config)}: inputs::File)]. */
                                   Rule::ArrangementRule {
                                       description: "scopes::ScopeOfId[(scopes::ScopeOfId{.id=(ast::AnyIdImport{.import_=id}: ast::AnyId), .file=file, .scope=scope}: scopes::ScopeOfId)] :- inputs::ImportDecl[(inputs::ImportDecl{.id=(id: ast::ImportId), .file=(file: ast::FileId), .clause=(_: ast::ImportClause)}: inputs::ImportDecl)], inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(scope: ast::ScopeId), .config=(_: config::Config)}: inputs::File)].".to_string(),
                                       arr: ( Relations::inputs_ImportDecl as RelId, 0),
                                       xform: XFormArrangement::Join{
                                                  description: "inputs::ImportDecl[(inputs::ImportDecl{.id=(id: ast::ImportId), .file=(file: ast::FileId), .clause=(_: ast::ImportClause)}: inputs::ImportDecl)], inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(scope: ast::ScopeId), .config=(_: config::Config)}: inputs::File)]".to_string(),
                                                  ffun: None,
                                                  arrangement: (Relations::inputs_File as RelId,0),
                                                  jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                  {
                                                      let (ref id, ref file) = match *<::types::inputs::ImportDecl>::from_ddvalue_ref(__v1) {
                                                          ::types::inputs::ImportDecl{id: ref id, file: ref file, clause: _} => ((*id).clone(), (*file).clone()),
                                                          _ => return None
                                                      };
                                                      let ref scope = match *<::types::inputs::File>::from_ddvalue_ref(__v2) {
                                                          ::types::inputs::File{id: _, kind: _, top_level_scope: ref scope, config: _} => (*scope).clone(),
                                                          _ => return None
                                                      };
                                                      Some(((::types::scopes::ScopeOfId{id: (::types::ast::AnyId::AnyIdImport{import_: (*id).clone()}), file: (*file).clone(), scope: (*scope).clone()})).into_ddvalue())
                                                  }
                                                  __f},
                                                  next: Box::new(None)
                                              }
                                   }],
                               arrangements: vec![
                                   ],
                               change_cb:    None
                           };
    let inputs_Switch = Relation {
                            name:         "inputs::Switch".to_string(),
                            input:        true,
                            distinct:     false,
                            caching_mode: CachingMode::Set,
                            key_func:     None,
                            id:           Relations::inputs_Switch as RelId,
                            rules:        vec![
                                ],
                            arrangements: vec![
                                ],
                            change_cb:    None
                        };
    let inputs_SwitchCase = Relation {
                                name:         "inputs::SwitchCase".to_string(),
                                input:        true,
                                distinct:     false,
                                caching_mode: CachingMode::Set,
                                key_func:     None,
                                id:           Relations::inputs_SwitchCase as RelId,
                                rules:        vec![
                                    ],
                                arrangements: vec![
                                    ],
                                change_cb:    None
                            };
    let inputs_Template = Relation {
                              name:         "inputs::Template".to_string(),
                              input:        true,
                              distinct:     false,
                              caching_mode: CachingMode::Set,
                              key_func:     None,
                              id:           Relations::inputs_Template as RelId,
                              rules:        vec![
                                  ],
                              arrangements: vec![
                                  ],
                              change_cb:    None
                          };
    let inputs_Ternary = Relation {
                             name:         "inputs::Ternary".to_string(),
                             input:        true,
                             distinct:     false,
                             caching_mode: CachingMode::Set,
                             key_func:     None,
                             id:           Relations::inputs_Ternary as RelId,
                             rules:        vec![
                                 ],
                             arrangements: vec![
                                 ],
                             change_cb:    None
                         };
    let inputs_Throw = Relation {
                           name:         "inputs::Throw".to_string(),
                           input:        true,
                           distinct:     false,
                           caching_mode: CachingMode::Set,
                           key_func:     None,
                           id:           Relations::inputs_Throw as RelId,
                           rules:        vec![
                               ],
                           arrangements: vec![
                               ],
                           change_cb:    None
                       };
    let inputs_Try = Relation {
                         name:         "inputs::Try".to_string(),
                         input:        true,
                         distinct:     false,
                         caching_mode: CachingMode::Set,
                         key_func:     None,
                         id:           Relations::inputs_Try as RelId,
                         rules:        vec![
                             ],
                         arrangements: vec![
                             Arrangement::Map{
                                name: r###"(inputs::Try{.stmt_id=(_: ast::StmtId), .file=(_1: ast::FileId), .body=(_: ddlog_std::Option<ast::StmtId>), .handler=(ast::TryHandler{.error=(ddlog_std::Some{.x=(_: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .body=(ddlog_std::Some{.x=(_0: ast::StmtId)}: ddlog_std::Option<ast::StmtId>)}: ast::TryHandler), .finalizer=(_: ddlog_std::Option<ast::StmtId>)}: inputs::Try) /*join*/"###.to_string(),
                                 afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                 {
                                     let __cloned = __v.clone();
                                     match < ::types::inputs::Try>::from_ddvalue(__v) {
                                         ::types::inputs::Try{stmt_id: _, file: ref _1, body: _, handler: ::types::ast::TryHandler{error: ::types::ddlog_std::Option::Some{x: _}, body: ::types::ddlog_std::Option::Some{x: ref _0}}, finalizer: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                         _ => None
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             }],
                         change_cb:    None
                     };
    let inputs_UnaryOp = Relation {
                             name:         "inputs::UnaryOp".to_string(),
                             input:        true,
                             distinct:     false,
                             caching_mode: CachingMode::Set,
                             key_func:     None,
                             id:           Relations::inputs_UnaryOp as RelId,
                             rules:        vec![
                                 ],
                             arrangements: vec![
                                 Arrangement::Map{
                                    name: r###"(inputs::UnaryOp{.expr_id=(_: ast::ExprId), .file=(_0: ast::FileId), .op=(ddlog_std::Some{.x=(ast::UnaryTypeof{}: ast::UnaryOperand)}: ddlog_std::Option<ast::UnaryOperand>), .expr=(ddlog_std::Some{.x=(_: ast::ExprId)}: ddlog_std::Option<ast::ExprId>)}: inputs::UnaryOp) /*join*/"###.to_string(),
                                     afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                     {
                                         let __cloned = __v.clone();
                                         match < ::types::inputs::UnaryOp>::from_ddvalue(__v) {
                                             ::types::inputs::UnaryOp{expr_id: _, file: ref _0, op: ::types::ddlog_std::Option::Some{x: ::types::ast::UnaryOperand::UnaryTypeof{}}, expr: ::types::ddlog_std::Option::Some{x: _}} => Some(((*_0).clone()).into_ddvalue()),
                                             _ => None
                                         }.map(|x|(x,__cloned))
                                     }
                                     __f},
                                     queryable: false
                                 }],
                             change_cb:    None
                         };
    let __Prefix_3 = Relation {
                         name:         "__Prefix_3".to_string(),
                         input:        false,
                         distinct:     false,
                         caching_mode: CachingMode::Set,
                         key_func:     None,
                         id:           Relations::__Prefix_3 as RelId,
                         rules:        vec![
                             /* __Prefix_3[((file: ast::FileId), (config: config::Config), (type_of: ast::ExprId), (expr: ast::ExprId))] :- __Prefix_9[((file: ast::FileId), (config: config::Config))], outputs::typeof_undef::WithinTypeofExpr[(outputs::typeof_undef::WithinTypeofExpr{.type_of=(type_of: ast::ExprId), .expr=(expr: ast::ExprId), .file=(file: ast::FileId)}: outputs::typeof_undef::WithinTypeofExpr)]. */
                             Rule::ArrangementRule {
                                 description: "__Prefix_3[((file: ast::FileId), (config: config::Config), (type_of: ast::ExprId), (expr: ast::ExprId))] :- __Prefix_9[((file: ast::FileId), (config: config::Config))], outputs::typeof_undef::WithinTypeofExpr[(outputs::typeof_undef::WithinTypeofExpr{.type_of=(type_of: ast::ExprId), .expr=(expr: ast::ExprId), .file=(file: ast::FileId)}: outputs::typeof_undef::WithinTypeofExpr)].".to_string(),
                                 arr: ( Relations::__Prefix_9 as RelId, 0),
                                 xform: XFormArrangement::Join{
                                            description: "__Prefix_9[((file: ast::FileId), (config: config::Config))], outputs::typeof_undef::WithinTypeofExpr[(outputs::typeof_undef::WithinTypeofExpr{.type_of=(type_of: ast::ExprId), .expr=(expr: ast::ExprId), .file=(file: ast::FileId)}: outputs::typeof_undef::WithinTypeofExpr)]".to_string(),
                                            ffun: None,
                                            arrangement: (Relations::outputs_typeof_undef_WithinTypeofExpr as RelId,0),
                                            jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                            {
                                                let (ref file, ref config) = match *<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue_ref(__v1) {
                                                    ::types::ddlog_std::tuple2(ref file, ref config) => ((*file).clone(), (*config).clone()),
                                                    _ => return None
                                                };
                                                let (ref type_of, ref expr) = match *<::types::outputs::typeof_undef::WithinTypeofExpr>::from_ddvalue_ref(__v2) {
                                                    ::types::outputs::typeof_undef::WithinTypeofExpr{type_of: ref type_of, expr: ref expr, file: _} => ((*type_of).clone(), (*expr).clone()),
                                                    _ => return None
                                                };
                                                Some((::types::ddlog_std::tuple4((*file).clone(), (*config).clone(), (*type_of).clone(), (*expr).clone())).into_ddvalue())
                                            }
                                            __f},
                                            next: Box::new(None)
                                        }
                             }],
                         arrangements: vec![
                             Arrangement::Map{
                                name: r###"((_1: ast::FileId), (_: config::Config), (_: ast::ExprId), (_0: ast::ExprId)) /*join*/"###.to_string(),
                                 afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                 {
                                     let __cloned = __v.clone();
                                     match < ::types::ddlog_std::tuple4<::types::ast::FileId, ::types::config::Config, ::types::ast::ExprId, ::types::ast::ExprId>>::from_ddvalue(__v) {
                                         ::types::ddlog_std::tuple4(ref _1, _, _, ref _0) => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                         _ => None
                                     }.map(|x|(x,__cloned))
                                 }
                                 __f},
                                 queryable: false
                             }],
                         change_cb:    None
                     };
    let outputs_typeof_undef_WithinTypeofExpr = Relation {
                                                    name:         "outputs::typeof_undef::WithinTypeofExpr".to_string(),
                                                    input:        false,
                                                    distinct:     false,
                                                    caching_mode: CachingMode::Set,
                                                    key_func:     None,
                                                    id:           Relations::outputs_typeof_undef_WithinTypeofExpr as RelId,
                                                    rules:        vec![
                                                        /* outputs::typeof_undef::WithinTypeofExpr[(outputs::typeof_undef::WithinTypeofExpr{.type_of=type_of, .expr=expr, .file=file}: outputs::typeof_undef::WithinTypeofExpr)] :- __Prefix_9[((file: ast::FileId), (config: config::Config))], inputs::UnaryOp[(inputs::UnaryOp{.expr_id=(type_of: ast::ExprId), .file=(file: ast::FileId), .op=(ddlog_std::Some{.x=(ast::UnaryTypeof{}: ast::UnaryOperand)}: ddlog_std::Option<ast::UnaryOperand>), .expr=(ddlog_std::Some{.x=(expr: ast::ExprId)}: ddlog_std::Option<ast::ExprId>)}: inputs::UnaryOp)]. */
                                                        Rule::ArrangementRule {
                                                            description: "outputs::typeof_undef::WithinTypeofExpr[(outputs::typeof_undef::WithinTypeofExpr{.type_of=type_of, .expr=expr, .file=file}: outputs::typeof_undef::WithinTypeofExpr)] :- __Prefix_9[((file: ast::FileId), (config: config::Config))], inputs::UnaryOp[(inputs::UnaryOp{.expr_id=(type_of: ast::ExprId), .file=(file: ast::FileId), .op=(ddlog_std::Some{.x=(ast::UnaryTypeof{}: ast::UnaryOperand)}: ddlog_std::Option<ast::UnaryOperand>), .expr=(ddlog_std::Some{.x=(expr: ast::ExprId)}: ddlog_std::Option<ast::ExprId>)}: inputs::UnaryOp)].".to_string(),
                                                            arr: ( Relations::__Prefix_9 as RelId, 0),
                                                            xform: XFormArrangement::Join{
                                                                       description: "__Prefix_9[((file: ast::FileId), (config: config::Config))], inputs::UnaryOp[(inputs::UnaryOp{.expr_id=(type_of: ast::ExprId), .file=(file: ast::FileId), .op=(ddlog_std::Some{.x=(ast::UnaryTypeof{}: ast::UnaryOperand)}: ddlog_std::Option<ast::UnaryOperand>), .expr=(ddlog_std::Some{.x=(expr: ast::ExprId)}: ddlog_std::Option<ast::ExprId>)}: inputs::UnaryOp)]".to_string(),
                                                                       ffun: None,
                                                                       arrangement: (Relations::inputs_UnaryOp as RelId,0),
                                                                       jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                       {
                                                                           let (ref file, ref config) = match *<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue_ref(__v1) {
                                                                               ::types::ddlog_std::tuple2(ref file, ref config) => ((*file).clone(), (*config).clone()),
                                                                               _ => return None
                                                                           };
                                                                           let (ref type_of, ref expr) = match *<::types::inputs::UnaryOp>::from_ddvalue_ref(__v2) {
                                                                               ::types::inputs::UnaryOp{expr_id: ref type_of, file: _, op: ::types::ddlog_std::Option::Some{x: ::types::ast::UnaryOperand::UnaryTypeof{}}, expr: ::types::ddlog_std::Option::Some{x: ref expr}} => ((*type_of).clone(), (*expr).clone()),
                                                                               _ => return None
                                                                           };
                                                                           Some(((::types::outputs::typeof_undef::WithinTypeofExpr{type_of: (*type_of).clone(), expr: (*expr).clone(), file: (*file).clone()})).into_ddvalue())
                                                                       }
                                                                       __f},
                                                                       next: Box::new(None)
                                                                   }
                                                        },
                                                        /* outputs::typeof_undef::WithinTypeofExpr[(outputs::typeof_undef::WithinTypeofExpr{.type_of=type_of, .expr=grouped, .file=file}: outputs::typeof_undef::WithinTypeofExpr)] :- __Prefix_3[((file: ast::FileId), (config: config::Config), (type_of: ast::ExprId), (expr: ast::ExprId))], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprGrouping{.inner=(ddlog_std::Some{.x=(grouped: ast::ExprId)}: ddlog_std::Option<ast::ExprId>)}: ast::ExprKind), .scope=(_: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression)]. */
                                                        Rule::ArrangementRule {
                                                            description: "outputs::typeof_undef::WithinTypeofExpr[(outputs::typeof_undef::WithinTypeofExpr{.type_of=type_of, .expr=grouped, .file=file}: outputs::typeof_undef::WithinTypeofExpr)] :- __Prefix_3[((file: ast::FileId), (config: config::Config), (type_of: ast::ExprId), (expr: ast::ExprId))], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprGrouping{.inner=(ddlog_std::Some{.x=(grouped: ast::ExprId)}: ddlog_std::Option<ast::ExprId>)}: ast::ExprKind), .scope=(_: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression)].".to_string(),
                                                            arr: ( Relations::__Prefix_3 as RelId, 0),
                                                            xform: XFormArrangement::Join{
                                                                       description: "__Prefix_3[((file: ast::FileId), (config: config::Config), (type_of: ast::ExprId), (expr: ast::ExprId))], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprGrouping{.inner=(ddlog_std::Some{.x=(grouped: ast::ExprId)}: ddlog_std::Option<ast::ExprId>)}: ast::ExprKind), .scope=(_: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression)]".to_string(),
                                                                       ffun: None,
                                                                       arrangement: (Relations::inputs_Expression as RelId,2),
                                                                       jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                       {
                                                                           let (ref file, ref config, ref type_of, ref expr) = match *<::types::ddlog_std::tuple4<::types::ast::FileId, ::types::config::Config, ::types::ast::ExprId, ::types::ast::ExprId>>::from_ddvalue_ref(__v1) {
                                                                               ::types::ddlog_std::tuple4(ref file, ref config, ref type_of, ref expr) => ((*file).clone(), (*config).clone(), (*type_of).clone(), (*expr).clone()),
                                                                               _ => return None
                                                                           };
                                                                           let ref grouped = match *<::types::inputs::Expression>::from_ddvalue_ref(__v2) {
                                                                               ::types::inputs::Expression{id: _, file: _, kind: ::types::ast::ExprKind::ExprGrouping{inner: ::types::ddlog_std::Option::Some{x: ref grouped}}, scope: _, span: _} => (*grouped).clone(),
                                                                               _ => return None
                                                                           };
                                                                           Some(((::types::outputs::typeof_undef::WithinTypeofExpr{type_of: (*type_of).clone(), expr: (*grouped).clone(), file: (*file).clone()})).into_ddvalue())
                                                                       }
                                                                       __f},
                                                                       next: Box::new(None)
                                                                   }
                                                        },
                                                        /* outputs::typeof_undef::WithinTypeofExpr[(outputs::typeof_undef::WithinTypeofExpr{.type_of=type_of, .expr=last, .file=file}: outputs::typeof_undef::WithinTypeofExpr)] :- __Prefix_3[((file: ast::FileId), (config: config::Config), (type_of: ast::ExprId), (expr: ast::ExprId))], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprSequence{.exprs=(sequence: ddlog_std::Vec<ast::ExprId>)}: ast::ExprKind), .scope=(_: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression)], ((ddlog_std::Some{.x=(var last: ast::ExprId)}: ddlog_std::Option<ast::ExprId>) = ((vec::last: function(ddlog_std::Vec<ast::ExprId>):ddlog_std::Option<ast::ExprId>)(sequence))). */
                                                        Rule::ArrangementRule {
                                                            description: "outputs::typeof_undef::WithinTypeofExpr[(outputs::typeof_undef::WithinTypeofExpr{.type_of=type_of, .expr=last, .file=file}: outputs::typeof_undef::WithinTypeofExpr)] :- __Prefix_3[((file: ast::FileId), (config: config::Config), (type_of: ast::ExprId), (expr: ast::ExprId))], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprSequence{.exprs=(sequence: ddlog_std::Vec<ast::ExprId>)}: ast::ExprKind), .scope=(_: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression)], ((ddlog_std::Some{.x=(var last: ast::ExprId)}: ddlog_std::Option<ast::ExprId>) = ((vec::last: function(ddlog_std::Vec<ast::ExprId>):ddlog_std::Option<ast::ExprId>)(sequence))).".to_string(),
                                                            arr: ( Relations::__Prefix_3 as RelId, 0),
                                                            xform: XFormArrangement::Join{
                                                                       description: "__Prefix_3[((file: ast::FileId), (config: config::Config), (type_of: ast::ExprId), (expr: ast::ExprId))], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprSequence{.exprs=(sequence: ddlog_std::Vec<ast::ExprId>)}: ast::ExprKind), .scope=(_: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression)]".to_string(),
                                                                       ffun: None,
                                                                       arrangement: (Relations::inputs_Expression as RelId,3),
                                                                       jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                       {
                                                                           let (ref file, ref config, ref type_of, ref expr) = match *<::types::ddlog_std::tuple4<::types::ast::FileId, ::types::config::Config, ::types::ast::ExprId, ::types::ast::ExprId>>::from_ddvalue_ref(__v1) {
                                                                               ::types::ddlog_std::tuple4(ref file, ref config, ref type_of, ref expr) => ((*file).clone(), (*config).clone(), (*type_of).clone(), (*expr).clone()),
                                                                               _ => return None
                                                                           };
                                                                           let ref sequence = match *<::types::inputs::Expression>::from_ddvalue_ref(__v2) {
                                                                               ::types::inputs::Expression{id: _, file: _, kind: ::types::ast::ExprKind::ExprSequence{exprs: ref sequence}, scope: _, span: _} => (*sequence).clone(),
                                                                               _ => return None
                                                                           };
                                                                           let ref last: ::types::ast::ExprId = match ::types::vec::last::<::types::ast::ExprId>(sequence) {
                                                                               ::types::ddlog_std::Option::Some{x: last} => last,
                                                                               _ => return None
                                                                           };
                                                                           Some(((::types::outputs::typeof_undef::WithinTypeofExpr{type_of: (*type_of).clone(), expr: (*last).clone(), file: (*file).clone()})).into_ddvalue())
                                                                       }
                                                                       __f},
                                                                       next: Box::new(None)
                                                                   }
                                                        }],
                                                    arrangements: vec![
                                                        Arrangement::Map{
                                                           name: r###"(outputs::typeof_undef::WithinTypeofExpr{.type_of=(_: ast::ExprId), .expr=(_: ast::ExprId), .file=(_0: ast::FileId)}: outputs::typeof_undef::WithinTypeofExpr) /*join*/"###.to_string(),
                                                            afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                            {
                                                                let __cloned = __v.clone();
                                                                match < ::types::outputs::typeof_undef::WithinTypeofExpr>::from_ddvalue(__v) {
                                                                    ::types::outputs::typeof_undef::WithinTypeofExpr{type_of: _, expr: _, file: ref _0} => Some(((*_0).clone()).into_ddvalue()),
                                                                    _ => None
                                                                }.map(|x|(x,__cloned))
                                                            }
                                                            __f},
                                                            queryable: false
                                                        },
                                                        Arrangement::Set{
                                                            name: r###"(outputs::typeof_undef::WithinTypeofExpr{.type_of=(_: ast::ExprId), .expr=(_0: ast::ExprId), .file=(_1: ast::FileId)}: outputs::typeof_undef::WithinTypeofExpr) /*antijoin*/"###.to_string(),
                                                            fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                            {
                                                                match < ::types::outputs::typeof_undef::WithinTypeofExpr>::from_ddvalue(__v) {
                                                                    ::types::outputs::typeof_undef::WithinTypeofExpr{type_of: _, expr: ref _0, file: ref _1} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                                    _ => None
                                                                }
                                                            }
                                                            __f},
                                                            distinct: true
                                                        },
                                                        Arrangement::Map{
                                                           name: r###"(outputs::typeof_undef::WithinTypeofExpr{.type_of=(_: ast::ExprId), .expr=(_0: ast::ExprId), .file=(_1: ast::FileId)}: outputs::typeof_undef::WithinTypeofExpr) /*join*/"###.to_string(),
                                                            afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                            {
                                                                let __cloned = __v.clone();
                                                                match < ::types::outputs::typeof_undef::WithinTypeofExpr>::from_ddvalue(__v) {
                                                                    ::types::outputs::typeof_undef::WithinTypeofExpr{type_of: _, expr: ref _0, file: ref _1} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                                    _ => None
                                                                }.map(|x|(x,__cloned))
                                                            }
                                                            __f},
                                                            queryable: false
                                                        }],
                                                    change_cb:    None
                                                };
    let inputs_UserGlobal = Relation {
                                name:         "inputs::UserGlobal".to_string(),
                                input:        true,
                                distinct:     false,
                                caching_mode: CachingMode::Set,
                                key_func:     None,
                                id:           Relations::inputs_UserGlobal as RelId,
                                rules:        vec![
                                    ],
                                arrangements: vec![
                                    Arrangement::Map{
                                       name: r###"(inputs::UserGlobal{.id=(_: ast::GlobalId), .file=(_0: ast::FileId), .name=(_: internment::Intern<string>), .privileges=(_: ast::GlobalPriv)}: inputs::UserGlobal) /*join*/"###.to_string(),
                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                        {
                                            let __cloned = __v.clone();
                                            match < ::types::inputs::UserGlobal>::from_ddvalue(__v) {
                                                ::types::inputs::UserGlobal{id: _, file: ref _0, name: _, privileges: _} => Some(((*_0).clone()).into_ddvalue()),
                                                _ => None
                                            }.map(|x|(x,__cloned))
                                        }
                                        __f},
                                        queryable: false
                                    }],
                                change_cb:    None
                            };
    let inputs_VarDecl = Relation {
                             name:         "inputs::VarDecl".to_string(),
                             input:        true,
                             distinct:     false,
                             caching_mode: CachingMode::Set,
                             key_func:     None,
                             id:           Relations::inputs_VarDecl as RelId,
                             rules:        vec![
                                 ],
                             arrangements: vec![
                                 Arrangement::Map{
                                    name: r###"(inputs::VarDecl{.stmt_id=(_0: ast::StmtId), .file=(_1: ast::FileId), .pattern=(ddlog_std::Some{.x=(_: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: inputs::VarDecl) /*join*/"###.to_string(),
                                     afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                     {
                                         let __cloned = __v.clone();
                                         match < ::types::inputs::VarDecl>::from_ddvalue(__v) {
                                             ::types::inputs::VarDecl{stmt_id: ref _0, file: ref _1, pattern: ::types::ddlog_std::Option::Some{x: _}, value: _, exported: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                             _ => None
                                         }.map(|x|(x,__cloned))
                                     }
                                     __f},
                                     queryable: false
                                 }],
                             change_cb:    None
                         };
    let var_decls_VariableDeclarations = Relation {
                                             name:         "var_decls::VariableDeclarations".to_string(),
                                             input:        false,
                                             distinct:     false,
                                             caching_mode: CachingMode::Set,
                                             key_func:     None,
                                             id:           Relations::var_decls_VariableDeclarations as RelId,
                                             rules:        vec![
                                                 /* var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(file_scope: ast::ScopeId), .config=(_: config::Config)}: inputs::File)], inputs::ImplicitGlobal[(inputs::ImplicitGlobal{.id=(global: ast::GlobalId), .name=(name: internment::Intern<string>), .privileges=(_: ast::GlobalPriv)}: inputs::ImplicitGlobal)], ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::None{}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdGlobal{.global=global}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=file_scope}: var_decls::DeclarationScope)). */
                                                 Rule::ArrangementRule {
                                                     description: "var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(file_scope: ast::ScopeId), .config=(_: config::Config)}: inputs::File)], inputs::ImplicitGlobal[(inputs::ImplicitGlobal{.id=(global: ast::GlobalId), .name=(name: internment::Intern<string>), .privileges=(_: ast::GlobalPriv)}: inputs::ImplicitGlobal)], ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::None{}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdGlobal{.global=global}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=file_scope}: var_decls::DeclarationScope)).".to_string(),
                                                     arr: ( Relations::inputs_File as RelId, 1),
                                                     xform: XFormArrangement::Join{
                                                                description: "inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(file_scope: ast::ScopeId), .config=(_: config::Config)}: inputs::File)], inputs::ImplicitGlobal[(inputs::ImplicitGlobal{.id=(global: ast::GlobalId), .name=(name: internment::Intern<string>), .privileges=(_: ast::GlobalPriv)}: inputs::ImplicitGlobal)]".to_string(),
                                                                ffun: None,
                                                                arrangement: (Relations::inputs_ImplicitGlobal as RelId,0),
                                                                jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                {
                                                                    let (ref file, ref file_scope) = match *<::types::inputs::File>::from_ddvalue_ref(__v1) {
                                                                        ::types::inputs::File{id: ref file, kind: _, top_level_scope: ref file_scope, config: _} => ((*file).clone(), (*file_scope).clone()),
                                                                        _ => return None
                                                                    };
                                                                    let (ref global, ref name) = match *<::types::inputs::ImplicitGlobal>::from_ddvalue_ref(__v2) {
                                                                        ::types::inputs::ImplicitGlobal{id: ref global, name: ref name, privileges: _} => ((*global).clone(), (*name).clone()),
                                                                        _ => return None
                                                                    };
                                                                    let ref meta: ::types::ddlog_std::Ref<::types::var_decls::VariableMeta> = match (*(&*::types::__STATIC_2)).clone() {
                                                                        meta => meta,
                                                                        _ => return None
                                                                    };
                                                                    let ref id: ::types::ast::AnyId = match (::types::ast::AnyId::AnyIdGlobal{global: (*global).clone()}) {
                                                                        id => id,
                                                                        _ => return None
                                                                    };
                                                                    let ref scope: ::types::var_decls::DeclarationScope = match (::types::var_decls::DeclarationScope::Unhoistable{scope: (*file_scope).clone()}) {
                                                                        scope => scope,
                                                                        _ => return None
                                                                    };
                                                                    Some(((::types::var_decls::VariableDeclarations{file: (*file).clone(), name: (*name).clone(), scope: (*scope).clone(), declared_in: (*id).clone(), meta: (*meta).clone()})).into_ddvalue())
                                                                }
                                                                __f},
                                                                next: Box::new(None)
                                                            }
                                                 },
                                                 /* var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::UserGlobal[(inputs::UserGlobal{.id=(global: ast::GlobalId), .file=(file: ast::FileId), .name=(name: internment::Intern<string>), .privileges=(_: ast::GlobalPriv)}: inputs::UserGlobal)], inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(file_scope: ast::ScopeId), .config=(_: config::Config)}: inputs::File)], ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=false, .declaration_span=(ddlog_std::None{}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdGlobal{.global=global}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=file_scope}: var_decls::DeclarationScope)). */
                                                 Rule::ArrangementRule {
                                                     description: "var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::UserGlobal[(inputs::UserGlobal{.id=(global: ast::GlobalId), .file=(file: ast::FileId), .name=(name: internment::Intern<string>), .privileges=(_: ast::GlobalPriv)}: inputs::UserGlobal)], inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(file_scope: ast::ScopeId), .config=(_: config::Config)}: inputs::File)], ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=false, .declaration_span=(ddlog_std::None{}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdGlobal{.global=global}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=file_scope}: var_decls::DeclarationScope)).".to_string(),
                                                     arr: ( Relations::inputs_UserGlobal as RelId, 0),
                                                     xform: XFormArrangement::Join{
                                                                description: "inputs::UserGlobal[(inputs::UserGlobal{.id=(global: ast::GlobalId), .file=(file: ast::FileId), .name=(name: internment::Intern<string>), .privileges=(_: ast::GlobalPriv)}: inputs::UserGlobal)], inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(file_scope: ast::ScopeId), .config=(_: config::Config)}: inputs::File)]".to_string(),
                                                                ffun: None,
                                                                arrangement: (Relations::inputs_File as RelId,0),
                                                                jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                {
                                                                    let (ref global, ref file, ref name) = match *<::types::inputs::UserGlobal>::from_ddvalue_ref(__v1) {
                                                                        ::types::inputs::UserGlobal{id: ref global, file: ref file, name: ref name, privileges: _} => ((*global).clone(), (*file).clone(), (*name).clone()),
                                                                        _ => return None
                                                                    };
                                                                    let ref file_scope = match *<::types::inputs::File>::from_ddvalue_ref(__v2) {
                                                                        ::types::inputs::File{id: _, kind: _, top_level_scope: ref file_scope, config: _} => (*file_scope).clone(),
                                                                        _ => return None
                                                                    };
                                                                    let ref meta: ::types::ddlog_std::Ref<::types::var_decls::VariableMeta> = match (*(&*::types::__STATIC_3)).clone() {
                                                                        meta => meta,
                                                                        _ => return None
                                                                    };
                                                                    let ref id: ::types::ast::AnyId = match (::types::ast::AnyId::AnyIdGlobal{global: (*global).clone()}) {
                                                                        id => id,
                                                                        _ => return None
                                                                    };
                                                                    let ref scope: ::types::var_decls::DeclarationScope = match (::types::var_decls::DeclarationScope::Unhoistable{scope: (*file_scope).clone()}) {
                                                                        scope => scope,
                                                                        _ => return None
                                                                    };
                                                                    Some(((::types::var_decls::VariableDeclarations{file: (*file).clone(), name: (*name).clone(), scope: (*scope).clone(), declared_in: (*id).clone(), meta: (*meta).clone()})).into_ddvalue())
                                                                }
                                                                __f},
                                                                next: Box::new(None)
                                                            }
                                                 },
                                                 /* var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::ImportDecl[(inputs::ImportDecl{.id=(import_id: ast::ImportId), .file=(file: ast::FileId), .clause=(clause: ast::ImportClause)}: inputs::ImportDecl)], inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(file_scope: ast::ScopeId), .config=(_: config::Config)}: inputs::File)], var imported = FlatMap((ast::free_variables(clause))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = imported), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdImport{.import_=import_id}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=file_scope}: var_decls::DeclarationScope)). */
                                                 Rule::ArrangementRule {
                                                     description: "var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::ImportDecl[(inputs::ImportDecl{.id=(import_id: ast::ImportId), .file=(file: ast::FileId), .clause=(clause: ast::ImportClause)}: inputs::ImportDecl)], inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(file_scope: ast::ScopeId), .config=(_: config::Config)}: inputs::File)], var imported = FlatMap((ast::free_variables(clause))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = imported), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdImport{.import_=import_id}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=file_scope}: var_decls::DeclarationScope)).".to_string(),
                                                     arr: ( Relations::inputs_ImportDecl as RelId, 0),
                                                     xform: XFormArrangement::Join{
                                                                description: "inputs::ImportDecl[(inputs::ImportDecl{.id=(import_id: ast::ImportId), .file=(file: ast::FileId), .clause=(clause: ast::ImportClause)}: inputs::ImportDecl)], inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(file_scope: ast::ScopeId), .config=(_: config::Config)}: inputs::File)]".to_string(),
                                                                ffun: None,
                                                                arrangement: (Relations::inputs_File as RelId,0),
                                                                jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                {
                                                                    let (ref import_id, ref file, ref clause) = match *<::types::inputs::ImportDecl>::from_ddvalue_ref(__v1) {
                                                                        ::types::inputs::ImportDecl{id: ref import_id, file: ref file, clause: ref clause} => ((*import_id).clone(), (*file).clone(), (*clause).clone()),
                                                                        _ => return None
                                                                    };
                                                                    let ref file_scope = match *<::types::inputs::File>::from_ddvalue_ref(__v2) {
                                                                        ::types::inputs::File{id: _, kind: _, top_level_scope: ref file_scope, config: _} => (*file_scope).clone(),
                                                                        _ => return None
                                                                    };
                                                                    Some((::types::ddlog_std::tuple4((*import_id).clone(), (*file).clone(), (*clause).clone(), (*file_scope).clone())).into_ddvalue())
                                                                }
                                                                __f},
                                                                next: Box::new(Some(XFormCollection::FlatMap{
                                                                                        description: "inputs::ImportDecl[(inputs::ImportDecl{.id=(import_id: ast::ImportId), .file=(file: ast::FileId), .clause=(clause: ast::ImportClause)}: inputs::ImportDecl)], inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(file_scope: ast::ScopeId), .config=(_: config::Config)}: inputs::File)], var imported = FlatMap((ast::free_variables(clause)))" .to_string(),
                                                                                        fmfun: {fn __f(__v: DDValue) -> Option<Box<dyn Iterator<Item=DDValue>>>
                                                                                        {
                                                                                            let ::types::ddlog_std::tuple4(ref import_id, ref file, ref clause, ref file_scope) = *<::types::ddlog_std::tuple4<::types::ast::ImportId, ::types::ast::FileId, ::types::ast::ImportClause, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                            let __flattened = ::types::ast::free_variables(clause);
                                                                                            let import_id = (*import_id).clone();
                                                                                            let file = (*file).clone();
                                                                                            let file_scope = (*file_scope).clone();
                                                                                            Some(Box::new(__flattened.into_iter().map(move |imported|(::types::ddlog_std::tuple4(imported.clone(), import_id.clone(), file.clone(), file_scope.clone())).into_ddvalue())))
                                                                                        }
                                                                                        __f},
                                                                                        next: Box::new(Some(XFormCollection::FilterMap{
                                                                                                                description: "head of var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::ImportDecl[(inputs::ImportDecl{.id=(import_id: ast::ImportId), .file=(file: ast::FileId), .clause=(clause: ast::ImportClause)}: inputs::ImportDecl)], inputs::File[(inputs::File{.id=(file: ast::FileId), .kind=(_: ast::FileKind), .top_level_scope=(file_scope: ast::ScopeId), .config=(_: config::Config)}: inputs::File)], var imported = FlatMap((ast::free_variables(clause))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = imported), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdImport{.import_=import_id}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=file_scope}: var_decls::DeclarationScope))." .to_string(),
                                                                                                                fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                                                                {
                                                                                                                    let ::types::ddlog_std::tuple4(ref imported, ref import_id, ref file, ref file_scope) = *<::types::ddlog_std::tuple4<::types::ast::Spanned<::types::internment::Intern<String>>, ::types::ast::ImportId, ::types::ast::FileId, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                                                    let (ref name, ref span): (::types::internment::Intern<String>, ::types::ast::Span) = match (*imported).clone() {
                                                                                                                        ::types::ast::Spanned{data: name, span: span} => (name, span),
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    let ref meta: ::types::ddlog_std::Ref<::types::var_decls::VariableMeta> = match ::types::ddlog_std::ref_new((&(::types::var_decls::VariableMeta{is_function_argument: false, implicitly_declared: false, declaration_span: (::types::ddlog_std::Option::Some{x: (*span).clone()})}))) {
                                                                                                                        meta => meta,
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    let ref id: ::types::ast::AnyId = match (::types::ast::AnyId::AnyIdImport{import_: (*import_id).clone()}) {
                                                                                                                        id => id,
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    let ref scope: ::types::var_decls::DeclarationScope = match (::types::var_decls::DeclarationScope::Unhoistable{scope: (*file_scope).clone()}) {
                                                                                                                        scope => scope,
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    Some(((::types::var_decls::VariableDeclarations{file: (*file).clone(), name: (*name).clone(), scope: (*scope).clone(), declared_in: (*id).clone(), meta: (*meta).clone()})).into_ddvalue())
                                                                                                                }
                                                                                                                __f},
                                                                                                                next: Box::new(None)
                                                                                                            }))
                                                                                    }))
                                                            }
                                                 },
                                                 /* var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::Class[(inputs::Class{.id=(class: ast::ClassId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(span: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(class_scope: ast::ScopeId), .exported=(_: bool)}: inputs::Class)], ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdClass{.class=class}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=class_scope}: var_decls::DeclarationScope)). */
                                                 Rule::CollectionRule {
                                                     description: "var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::Class[(inputs::Class{.id=(class: ast::ClassId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(span: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(class_scope: ast::ScopeId), .exported=(_: bool)}: inputs::Class)], ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdClass{.class=class}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=class_scope}: var_decls::DeclarationScope)).".to_string(),
                                                     rel: Relations::inputs_Class as RelId,
                                                     xform: Some(XFormCollection::FilterMap{
                                                                     description: "head of var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::Class[(inputs::Class{.id=(class: ast::ClassId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(span: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(class_scope: ast::ScopeId), .exported=(_: bool)}: inputs::Class)], ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdClass{.class=class}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=class_scope}: var_decls::DeclarationScope))." .to_string(),
                                                                     fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                     {
                                                                         let (ref class, ref file, ref name, ref span, ref class_scope) = match *<::types::inputs::Class>::from_ddvalue_ref(&__v) {
                                                                             ::types::inputs::Class{id: ref class, file: ref file, name: ::types::ddlog_std::Option::Some{x: ::types::ast::Spanned{data: ref name, span: ref span}}, parent: _, elements: _, scope: ref class_scope, exported: _} => ((*class).clone(), (*file).clone(), (*name).clone(), (*span).clone(), (*class_scope).clone()),
                                                                             _ => return None
                                                                         };
                                                                         let ref meta: ::types::ddlog_std::Ref<::types::var_decls::VariableMeta> = match ::types::ddlog_std::ref_new((&(::types::var_decls::VariableMeta{is_function_argument: false, implicitly_declared: false, declaration_span: (::types::ddlog_std::Option::Some{x: (*span).clone()})}))) {
                                                                             meta => meta,
                                                                             _ => return None
                                                                         };
                                                                         let ref id: ::types::ast::AnyId = match (::types::ast::AnyId::AnyIdClass{class: (*class).clone()}) {
                                                                             id => id,
                                                                             _ => return None
                                                                         };
                                                                         let ref scope: ::types::var_decls::DeclarationScope = match (::types::var_decls::DeclarationScope::Unhoistable{scope: (*class_scope).clone()}) {
                                                                             scope => scope,
                                                                             _ => return None
                                                                         };
                                                                         Some(((::types::var_decls::VariableDeclarations{file: (*file).clone(), name: (*name).clone(), scope: (*scope).clone(), declared_in: (*id).clone(), meta: (*meta).clone()})).into_ddvalue())
                                                                     }
                                                                     __f},
                                                                     next: Box::new(None)
                                                                 })
                                                 },
                                                 /* var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::LetDecl[(inputs::LetDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(ddlog_std::Some{.x=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: inputs::LetDecl)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdStmt{.stmt=stmt}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=stmt_scope}: var_decls::DeclarationScope)). */
                                                 Rule::ArrangementRule {
                                                     description: "var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::LetDecl[(inputs::LetDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(ddlog_std::Some{.x=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: inputs::LetDecl)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdStmt{.stmt=stmt}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=stmt_scope}: var_decls::DeclarationScope)).".to_string(),
                                                     arr: ( Relations::inputs_LetDecl as RelId, 0),
                                                     xform: XFormArrangement::Join{
                                                                description: "inputs::LetDecl[(inputs::LetDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(ddlog_std::Some{.x=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: inputs::LetDecl)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)]".to_string(),
                                                                ffun: None,
                                                                arrangement: (Relations::inputs_Statement as RelId,0),
                                                                jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                {
                                                                    let (ref stmt, ref file, ref pat) = match *<::types::inputs::LetDecl>::from_ddvalue_ref(__v1) {
                                                                        ::types::inputs::LetDecl{stmt_id: ref stmt, file: ref file, pattern: ::types::ddlog_std::Option::Some{x: ref pat}, value: _, exported: _} => ((*stmt).clone(), (*file).clone(), (*pat).clone()),
                                                                        _ => return None
                                                                    };
                                                                    let ref stmt_scope = match *<::types::inputs::Statement>::from_ddvalue_ref(__v2) {
                                                                        ::types::inputs::Statement{id: _, file: _, kind: _, scope: ref stmt_scope, span: _} => (*stmt_scope).clone(),
                                                                        _ => return None
                                                                    };
                                                                    Some((::types::ddlog_std::tuple4((*stmt).clone(), (*file).clone(), (*pat).clone(), (*stmt_scope).clone())).into_ddvalue())
                                                                }
                                                                __f},
                                                                next: Box::new(Some(XFormCollection::FlatMap{
                                                                                        description: "inputs::LetDecl[(inputs::LetDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(ddlog_std::Some{.x=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: inputs::LetDecl)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat)))" .to_string(),
                                                                                        fmfun: {fn __f(__v: DDValue) -> Option<Box<dyn Iterator<Item=DDValue>>>
                                                                                        {
                                                                                            let ::types::ddlog_std::tuple4(ref stmt, ref file, ref pat, ref stmt_scope) = *<::types::ddlog_std::tuple4<::types::ast::StmtId, ::types::ast::FileId, ::types::internment::Intern<::types::ast::Pattern>, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                            let __flattened = ::types::ast::bound_vars_internment_Intern__ast_Pattern_ddlog_std_Vec__ast_Spanned__internment_Intern____Stringval(pat);
                                                                                            let stmt = (*stmt).clone();
                                                                                            let file = (*file).clone();
                                                                                            let stmt_scope = (*stmt_scope).clone();
                                                                                            Some(Box::new(__flattened.into_iter().map(move |bound|(::types::ddlog_std::tuple4(bound.clone(), stmt.clone(), file.clone(), stmt_scope.clone())).into_ddvalue())))
                                                                                        }
                                                                                        __f},
                                                                                        next: Box::new(Some(XFormCollection::FilterMap{
                                                                                                                description: "head of var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::LetDecl[(inputs::LetDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(ddlog_std::Some{.x=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: inputs::LetDecl)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdStmt{.stmt=stmt}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=stmt_scope}: var_decls::DeclarationScope))." .to_string(),
                                                                                                                fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                                                                {
                                                                                                                    let ::types::ddlog_std::tuple4(ref bound, ref stmt, ref file, ref stmt_scope) = *<::types::ddlog_std::tuple4<::types::ast::Spanned<::types::internment::Intern<String>>, ::types::ast::StmtId, ::types::ast::FileId, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                                                    let (ref name, ref span): (::types::internment::Intern<String>, ::types::ast::Span) = match (*bound).clone() {
                                                                                                                        ::types::ast::Spanned{data: name, span: span} => (name, span),
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    let ref meta: ::types::ddlog_std::Ref<::types::var_decls::VariableMeta> = match ::types::ddlog_std::ref_new((&(::types::var_decls::VariableMeta{is_function_argument: false, implicitly_declared: false, declaration_span: (::types::ddlog_std::Option::Some{x: (*span).clone()})}))) {
                                                                                                                        meta => meta,
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    let ref id: ::types::ast::AnyId = match (::types::ast::AnyId::AnyIdStmt{stmt: (*stmt).clone()}) {
                                                                                                                        id => id,
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    let ref scope: ::types::var_decls::DeclarationScope = match (::types::var_decls::DeclarationScope::Unhoistable{scope: (*stmt_scope).clone()}) {
                                                                                                                        scope => scope,
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    Some(((::types::var_decls::VariableDeclarations{file: (*file).clone(), name: (*name).clone(), scope: (*scope).clone(), declared_in: (*id).clone(), meta: (*meta).clone()})).into_ddvalue())
                                                                                                                }
                                                                                                                __f},
                                                                                                                next: Box::new(None)
                                                                                                            }))
                                                                                    }))
                                                            }
                                                 },
                                                 /* var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::ConstDecl[(inputs::ConstDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(ddlog_std::Some{.x=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: inputs::ConstDecl)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdStmt{.stmt=stmt}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=stmt_scope}: var_decls::DeclarationScope)). */
                                                 Rule::ArrangementRule {
                                                     description: "var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::ConstDecl[(inputs::ConstDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(ddlog_std::Some{.x=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: inputs::ConstDecl)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdStmt{.stmt=stmt}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=stmt_scope}: var_decls::DeclarationScope)).".to_string(),
                                                     arr: ( Relations::inputs_ConstDecl as RelId, 0),
                                                     xform: XFormArrangement::Join{
                                                                description: "inputs::ConstDecl[(inputs::ConstDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(ddlog_std::Some{.x=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: inputs::ConstDecl)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)]".to_string(),
                                                                ffun: None,
                                                                arrangement: (Relations::inputs_Statement as RelId,0),
                                                                jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                {
                                                                    let (ref stmt, ref file, ref pat) = match *<::types::inputs::ConstDecl>::from_ddvalue_ref(__v1) {
                                                                        ::types::inputs::ConstDecl{stmt_id: ref stmt, file: ref file, pattern: ::types::ddlog_std::Option::Some{x: ref pat}, value: _, exported: _} => ((*stmt).clone(), (*file).clone(), (*pat).clone()),
                                                                        _ => return None
                                                                    };
                                                                    let ref stmt_scope = match *<::types::inputs::Statement>::from_ddvalue_ref(__v2) {
                                                                        ::types::inputs::Statement{id: _, file: _, kind: _, scope: ref stmt_scope, span: _} => (*stmt_scope).clone(),
                                                                        _ => return None
                                                                    };
                                                                    Some((::types::ddlog_std::tuple4((*stmt).clone(), (*file).clone(), (*pat).clone(), (*stmt_scope).clone())).into_ddvalue())
                                                                }
                                                                __f},
                                                                next: Box::new(Some(XFormCollection::FlatMap{
                                                                                        description: "inputs::ConstDecl[(inputs::ConstDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(ddlog_std::Some{.x=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: inputs::ConstDecl)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat)))" .to_string(),
                                                                                        fmfun: {fn __f(__v: DDValue) -> Option<Box<dyn Iterator<Item=DDValue>>>
                                                                                        {
                                                                                            let ::types::ddlog_std::tuple4(ref stmt, ref file, ref pat, ref stmt_scope) = *<::types::ddlog_std::tuple4<::types::ast::StmtId, ::types::ast::FileId, ::types::internment::Intern<::types::ast::Pattern>, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                            let __flattened = ::types::ast::bound_vars_internment_Intern__ast_Pattern_ddlog_std_Vec__ast_Spanned__internment_Intern____Stringval(pat);
                                                                                            let stmt = (*stmt).clone();
                                                                                            let file = (*file).clone();
                                                                                            let stmt_scope = (*stmt_scope).clone();
                                                                                            Some(Box::new(__flattened.into_iter().map(move |bound|(::types::ddlog_std::tuple4(bound.clone(), stmt.clone(), file.clone(), stmt_scope.clone())).into_ddvalue())))
                                                                                        }
                                                                                        __f},
                                                                                        next: Box::new(Some(XFormCollection::FilterMap{
                                                                                                                description: "head of var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::ConstDecl[(inputs::ConstDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(ddlog_std::Some{.x=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: inputs::ConstDecl)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdStmt{.stmt=stmt}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=stmt_scope}: var_decls::DeclarationScope))." .to_string(),
                                                                                                                fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                                                                {
                                                                                                                    let ::types::ddlog_std::tuple4(ref bound, ref stmt, ref file, ref stmt_scope) = *<::types::ddlog_std::tuple4<::types::ast::Spanned<::types::internment::Intern<String>>, ::types::ast::StmtId, ::types::ast::FileId, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                                                    let (ref name, ref span): (::types::internment::Intern<String>, ::types::ast::Span) = match (*bound).clone() {
                                                                                                                        ::types::ast::Spanned{data: name, span: span} => (name, span),
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    let ref meta: ::types::ddlog_std::Ref<::types::var_decls::VariableMeta> = match ::types::ddlog_std::ref_new((&(::types::var_decls::VariableMeta{is_function_argument: false, implicitly_declared: false, declaration_span: (::types::ddlog_std::Option::Some{x: (*span).clone()})}))) {
                                                                                                                        meta => meta,
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    let ref id: ::types::ast::AnyId = match (::types::ast::AnyId::AnyIdStmt{stmt: (*stmt).clone()}) {
                                                                                                                        id => id,
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    let ref scope: ::types::var_decls::DeclarationScope = match (::types::var_decls::DeclarationScope::Unhoistable{scope: (*stmt_scope).clone()}) {
                                                                                                                        scope => scope,
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    Some(((::types::var_decls::VariableDeclarations{file: (*file).clone(), name: (*name).clone(), scope: (*scope).clone(), declared_in: (*id).clone(), meta: (*meta).clone()})).into_ddvalue())
                                                                                                                }
                                                                                                                __f},
                                                                                                                next: Box::new(None)
                                                                                                            }))
                                                                                    }))
                                                            }
                                                 },
                                                 /* var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::VarDecl[(inputs::VarDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(ddlog_std::Some{.x=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: inputs::VarDecl)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=(stmt_scope: ast::ScopeId), .nearest=(nearest_scope: ast::ScopeId), .file=(file: ast::FileId), .id=(_: ast::AnyId)}: scopes::FunctionLevelScope)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdStmt{.stmt=stmt}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Hoistable{.hoisted=nearest_scope, .unhoisted=stmt_scope}: var_decls::DeclarationScope)). */
                                                 Rule::ArrangementRule {
                                                     description: "var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::VarDecl[(inputs::VarDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(ddlog_std::Some{.x=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: inputs::VarDecl)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=(stmt_scope: ast::ScopeId), .nearest=(nearest_scope: ast::ScopeId), .file=(file: ast::FileId), .id=(_: ast::AnyId)}: scopes::FunctionLevelScope)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdStmt{.stmt=stmt}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Hoistable{.hoisted=nearest_scope, .unhoisted=stmt_scope}: var_decls::DeclarationScope)).".to_string(),
                                                     arr: ( Relations::inputs_VarDecl as RelId, 0),
                                                     xform: XFormArrangement::Join{
                                                                description: "inputs::VarDecl[(inputs::VarDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(ddlog_std::Some{.x=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: inputs::VarDecl)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)]".to_string(),
                                                                ffun: None,
                                                                arrangement: (Relations::inputs_Statement as RelId,0),
                                                                jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                {
                                                                    let (ref stmt, ref file, ref pat) = match *<::types::inputs::VarDecl>::from_ddvalue_ref(__v1) {
                                                                        ::types::inputs::VarDecl{stmt_id: ref stmt, file: ref file, pattern: ::types::ddlog_std::Option::Some{x: ref pat}, value: _, exported: _} => ((*stmt).clone(), (*file).clone(), (*pat).clone()),
                                                                        _ => return None
                                                                    };
                                                                    let ref stmt_scope = match *<::types::inputs::Statement>::from_ddvalue_ref(__v2) {
                                                                        ::types::inputs::Statement{id: _, file: _, kind: _, scope: ref stmt_scope, span: _} => (*stmt_scope).clone(),
                                                                        _ => return None
                                                                    };
                                                                    Some((::types::ddlog_std::tuple4((*stmt).clone(), (*file).clone(), (*pat).clone(), (*stmt_scope).clone())).into_ddvalue())
                                                                }
                                                                __f},
                                                                next: Box::new(Some(XFormCollection::Arrange {
                                                                                        description: "arrange inputs::VarDecl[(inputs::VarDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(ddlog_std::Some{.x=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: inputs::VarDecl)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)] by (stmt_scope, file)" .to_string(),
                                                                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                        {
                                                                                            let ::types::ddlog_std::tuple4(ref stmt, ref file, ref pat, ref stmt_scope) = *<::types::ddlog_std::tuple4<::types::ast::StmtId, ::types::ast::FileId, ::types::internment::Intern<::types::ast::Pattern>, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                            Some(((::types::ddlog_std::tuple2((*stmt_scope).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple4((*stmt).clone(), (*file).clone(), (*pat).clone(), (*stmt_scope).clone())).into_ddvalue()))
                                                                                        }
                                                                                        __f},
                                                                                        next: Box::new(XFormArrangement::Join{
                                                                                                           description: "inputs::VarDecl[(inputs::VarDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(ddlog_std::Some{.x=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: inputs::VarDecl)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=(stmt_scope: ast::ScopeId), .nearest=(nearest_scope: ast::ScopeId), .file=(file: ast::FileId), .id=(_: ast::AnyId)}: scopes::FunctionLevelScope)]".to_string(),
                                                                                                           ffun: None,
                                                                                                           arrangement: (Relations::scopes_FunctionLevelScope as RelId,0),
                                                                                                           jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                           {
                                                                                                               let ::types::ddlog_std::tuple4(ref stmt, ref file, ref pat, ref stmt_scope) = *<::types::ddlog_std::tuple4<::types::ast::StmtId, ::types::ast::FileId, ::types::internment::Intern<::types::ast::Pattern>, ::types::ast::ScopeId>>::from_ddvalue_ref( __v1 );
                                                                                                               let ref nearest_scope = match *<::types::scopes::FunctionLevelScope>::from_ddvalue_ref(__v2) {
                                                                                                                   ::types::scopes::FunctionLevelScope{scope: _, nearest: ref nearest_scope, file: _, id: _} => (*nearest_scope).clone(),
                                                                                                                   _ => return None
                                                                                                               };
                                                                                                               Some((::types::ddlog_std::tuple5((*stmt).clone(), (*file).clone(), (*pat).clone(), (*stmt_scope).clone(), (*nearest_scope).clone())).into_ddvalue())
                                                                                                           }
                                                                                                           __f},
                                                                                                           next: Box::new(Some(XFormCollection::FlatMap{
                                                                                                                                   description: "inputs::VarDecl[(inputs::VarDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(ddlog_std::Some{.x=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: inputs::VarDecl)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=(stmt_scope: ast::ScopeId), .nearest=(nearest_scope: ast::ScopeId), .file=(file: ast::FileId), .id=(_: ast::AnyId)}: scopes::FunctionLevelScope)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat)))" .to_string(),
                                                                                                                                   fmfun: {fn __f(__v: DDValue) -> Option<Box<dyn Iterator<Item=DDValue>>>
                                                                                                                                   {
                                                                                                                                       let ::types::ddlog_std::tuple5(ref stmt, ref file, ref pat, ref stmt_scope, ref nearest_scope) = *<::types::ddlog_std::tuple5<::types::ast::StmtId, ::types::ast::FileId, ::types::internment::Intern<::types::ast::Pattern>, ::types::ast::ScopeId, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                                                                       let __flattened = ::types::ast::bound_vars_internment_Intern__ast_Pattern_ddlog_std_Vec__ast_Spanned__internment_Intern____Stringval(pat);
                                                                                                                                       let stmt = (*stmt).clone();
                                                                                                                                       let file = (*file).clone();
                                                                                                                                       let stmt_scope = (*stmt_scope).clone();
                                                                                                                                       let nearest_scope = (*nearest_scope).clone();
                                                                                                                                       Some(Box::new(__flattened.into_iter().map(move |bound|(::types::ddlog_std::tuple5(bound.clone(), stmt.clone(), file.clone(), stmt_scope.clone(), nearest_scope.clone())).into_ddvalue())))
                                                                                                                                   }
                                                                                                                                   __f},
                                                                                                                                   next: Box::new(Some(XFormCollection::FilterMap{
                                                                                                                                                           description: "head of var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::VarDecl[(inputs::VarDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(ddlog_std::Some{.x=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: inputs::VarDecl)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=(stmt_scope: ast::ScopeId), .nearest=(nearest_scope: ast::ScopeId), .file=(file: ast::FileId), .id=(_: ast::AnyId)}: scopes::FunctionLevelScope)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdStmt{.stmt=stmt}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Hoistable{.hoisted=nearest_scope, .unhoisted=stmt_scope}: var_decls::DeclarationScope))." .to_string(),
                                                                                                                                                           fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                                                                                                           {
                                                                                                                                                               let ::types::ddlog_std::tuple5(ref bound, ref stmt, ref file, ref stmt_scope, ref nearest_scope) = *<::types::ddlog_std::tuple5<::types::ast::Spanned<::types::internment::Intern<String>>, ::types::ast::StmtId, ::types::ast::FileId, ::types::ast::ScopeId, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                                                                                               let (ref name, ref span): (::types::internment::Intern<String>, ::types::ast::Span) = match (*bound).clone() {
                                                                                                                                                                   ::types::ast::Spanned{data: name, span: span} => (name, span),
                                                                                                                                                                   _ => return None
                                                                                                                                                               };
                                                                                                                                                               let ref meta: ::types::ddlog_std::Ref<::types::var_decls::VariableMeta> = match ::types::ddlog_std::ref_new((&(::types::var_decls::VariableMeta{is_function_argument: false, implicitly_declared: false, declaration_span: (::types::ddlog_std::Option::Some{x: (*span).clone()})}))) {
                                                                                                                                                                   meta => meta,
                                                                                                                                                                   _ => return None
                                                                                                                                                               };
                                                                                                                                                               let ref id: ::types::ast::AnyId = match (::types::ast::AnyId::AnyIdStmt{stmt: (*stmt).clone()}) {
                                                                                                                                                                   id => id,
                                                                                                                                                                   _ => return None
                                                                                                                                                               };
                                                                                                                                                               let ref scope: ::types::var_decls::DeclarationScope = match (::types::var_decls::DeclarationScope::Hoistable{hoisted: (*nearest_scope).clone(), unhoisted: (*stmt_scope).clone()}) {
                                                                                                                                                                   scope => scope,
                                                                                                                                                                   _ => return None
                                                                                                                                                               };
                                                                                                                                                               Some(((::types::var_decls::VariableDeclarations{file: (*file).clone(), name: (*name).clone(), scope: (*scope).clone(), declared_in: (*id).clone(), meta: (*meta).clone()})).into_ddvalue())
                                                                                                                                                           }
                                                                                                                                                           __f},
                                                                                                                                                           next: Box::new(None)
                                                                                                                                                       }))
                                                                                                                               }))
                                                                                                       })
                                                                                    }))
                                                            }
                                                 },
                                                 /* var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::Function[(inputs::Function{.id=(func: ast::FuncId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(span: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(func_scope: ast::ScopeId), .body=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Function)], scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=(func_scope: ast::ScopeId), .nearest=(nearest_scope: ast::ScopeId), .file=(file: ast::FileId), .id=(_: ast::AnyId)}: scopes::FunctionLevelScope)], ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdFunc{.func=func}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Hoistable{.hoisted=nearest_scope, .unhoisted=func_scope}: var_decls::DeclarationScope)). */
                                                 Rule::ArrangementRule {
                                                     description: "var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::Function[(inputs::Function{.id=(func: ast::FuncId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(span: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(func_scope: ast::ScopeId), .body=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Function)], scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=(func_scope: ast::ScopeId), .nearest=(nearest_scope: ast::ScopeId), .file=(file: ast::FileId), .id=(_: ast::AnyId)}: scopes::FunctionLevelScope)], ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdFunc{.func=func}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Hoistable{.hoisted=nearest_scope, .unhoisted=func_scope}: var_decls::DeclarationScope)).".to_string(),
                                                     arr: ( Relations::inputs_Function as RelId, 1),
                                                     xform: XFormArrangement::Join{
                                                                description: "inputs::Function[(inputs::Function{.id=(func: ast::FuncId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(span: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(func_scope: ast::ScopeId), .body=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Function)], scopes::FunctionLevelScope[(scopes::FunctionLevelScope{.scope=(func_scope: ast::ScopeId), .nearest=(nearest_scope: ast::ScopeId), .file=(file: ast::FileId), .id=(_: ast::AnyId)}: scopes::FunctionLevelScope)]".to_string(),
                                                                ffun: None,
                                                                arrangement: (Relations::scopes_FunctionLevelScope as RelId,0),
                                                                jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                {
                                                                    let (ref func, ref file, ref name, ref span, ref func_scope) = match *<::types::inputs::Function>::from_ddvalue_ref(__v1) {
                                                                        ::types::inputs::Function{id: ref func, file: ref file, name: ::types::ddlog_std::Option::Some{x: ::types::ast::Spanned{data: ref name, span: ref span}}, scope: ref func_scope, body: _, exported: _} => ((*func).clone(), (*file).clone(), (*name).clone(), (*span).clone(), (*func_scope).clone()),
                                                                        _ => return None
                                                                    };
                                                                    let ref nearest_scope = match *<::types::scopes::FunctionLevelScope>::from_ddvalue_ref(__v2) {
                                                                        ::types::scopes::FunctionLevelScope{scope: _, nearest: ref nearest_scope, file: _, id: _} => (*nearest_scope).clone(),
                                                                        _ => return None
                                                                    };
                                                                    let ref meta: ::types::ddlog_std::Ref<::types::var_decls::VariableMeta> = match ::types::ddlog_std::ref_new((&(::types::var_decls::VariableMeta{is_function_argument: false, implicitly_declared: false, declaration_span: (::types::ddlog_std::Option::Some{x: (*span).clone()})}))) {
                                                                        meta => meta,
                                                                        _ => return None
                                                                    };
                                                                    let ref id: ::types::ast::AnyId = match (::types::ast::AnyId::AnyIdFunc{func: (*func).clone()}) {
                                                                        id => id,
                                                                        _ => return None
                                                                    };
                                                                    let ref scope: ::types::var_decls::DeclarationScope = match (::types::var_decls::DeclarationScope::Hoistable{hoisted: (*nearest_scope).clone(), unhoisted: (*func_scope).clone()}) {
                                                                        scope => scope,
                                                                        _ => return None
                                                                    };
                                                                    Some(((::types::var_decls::VariableDeclarations{file: (*file).clone(), name: (*name).clone(), scope: (*scope).clone(), declared_in: (*id).clone(), meta: (*meta).clone()})).into_ddvalue())
                                                                }
                                                                __f},
                                                                next: Box::new(None)
                                                            }
                                                 },
                                                 /* var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::FunctionArg[(inputs::FunctionArg{.parent_func=(func: ast::FuncId), .file=(file: ast::FileId), .pattern=(pat: internment::Intern<ast::Pattern>), .implicit=(implicit: bool)}: inputs::FunctionArg)], inputs::Function[(inputs::Function{.id=(func: ast::FuncId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(_: ast::ScopeId), .body=(body: ast::ScopeId), .exported=(_: bool)}: inputs::Function)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=implicit, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdFunc{.func=func}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=body}: var_decls::DeclarationScope)). */
                                                 Rule::ArrangementRule {
                                                     description: "var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::FunctionArg[(inputs::FunctionArg{.parent_func=(func: ast::FuncId), .file=(file: ast::FileId), .pattern=(pat: internment::Intern<ast::Pattern>), .implicit=(implicit: bool)}: inputs::FunctionArg)], inputs::Function[(inputs::Function{.id=(func: ast::FuncId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(_: ast::ScopeId), .body=(body: ast::ScopeId), .exported=(_: bool)}: inputs::Function)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=implicit, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdFunc{.func=func}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=body}: var_decls::DeclarationScope)).".to_string(),
                                                     arr: ( Relations::inputs_FunctionArg as RelId, 0),
                                                     xform: XFormArrangement::Join{
                                                                description: "inputs::FunctionArg[(inputs::FunctionArg{.parent_func=(func: ast::FuncId), .file=(file: ast::FileId), .pattern=(pat: internment::Intern<ast::Pattern>), .implicit=(implicit: bool)}: inputs::FunctionArg)], inputs::Function[(inputs::Function{.id=(func: ast::FuncId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(_: ast::ScopeId), .body=(body: ast::ScopeId), .exported=(_: bool)}: inputs::Function)]".to_string(),
                                                                ffun: None,
                                                                arrangement: (Relations::inputs_Function as RelId,2),
                                                                jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                {
                                                                    let (ref func, ref file, ref pat, ref implicit) = match *<::types::inputs::FunctionArg>::from_ddvalue_ref(__v1) {
                                                                        ::types::inputs::FunctionArg{parent_func: ref func, file: ref file, pattern: ref pat, implicit: ref implicit} => ((*func).clone(), (*file).clone(), (*pat).clone(), (*implicit).clone()),
                                                                        _ => return None
                                                                    };
                                                                    let ref body = match *<::types::inputs::Function>::from_ddvalue_ref(__v2) {
                                                                        ::types::inputs::Function{id: _, file: _, name: _, scope: _, body: ref body, exported: _} => (*body).clone(),
                                                                        _ => return None
                                                                    };
                                                                    Some((::types::ddlog_std::tuple5((*func).clone(), (*file).clone(), (*pat).clone(), (*implicit).clone(), (*body).clone())).into_ddvalue())
                                                                }
                                                                __f},
                                                                next: Box::new(Some(XFormCollection::FlatMap{
                                                                                        description: "inputs::FunctionArg[(inputs::FunctionArg{.parent_func=(func: ast::FuncId), .file=(file: ast::FileId), .pattern=(pat: internment::Intern<ast::Pattern>), .implicit=(implicit: bool)}: inputs::FunctionArg)], inputs::Function[(inputs::Function{.id=(func: ast::FuncId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(_: ast::ScopeId), .body=(body: ast::ScopeId), .exported=(_: bool)}: inputs::Function)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat)))" .to_string(),
                                                                                        fmfun: {fn __f(__v: DDValue) -> Option<Box<dyn Iterator<Item=DDValue>>>
                                                                                        {
                                                                                            let ::types::ddlog_std::tuple5(ref func, ref file, ref pat, ref implicit, ref body) = *<::types::ddlog_std::tuple5<::types::ast::FuncId, ::types::ast::FileId, ::types::internment::Intern<::types::ast::Pattern>, bool, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                            let __flattened = ::types::ast::bound_vars_internment_Intern__ast_Pattern_ddlog_std_Vec__ast_Spanned__internment_Intern____Stringval(pat);
                                                                                            let func = (*func).clone();
                                                                                            let file = (*file).clone();
                                                                                            let implicit = (*implicit).clone();
                                                                                            let body = (*body).clone();
                                                                                            Some(Box::new(__flattened.into_iter().map(move |bound|(::types::ddlog_std::tuple5(bound.clone(), func.clone(), file.clone(), implicit.clone(), body.clone())).into_ddvalue())))
                                                                                        }
                                                                                        __f},
                                                                                        next: Box::new(Some(XFormCollection::FilterMap{
                                                                                                                description: "head of var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::FunctionArg[(inputs::FunctionArg{.parent_func=(func: ast::FuncId), .file=(file: ast::FileId), .pattern=(pat: internment::Intern<ast::Pattern>), .implicit=(implicit: bool)}: inputs::FunctionArg)], inputs::Function[(inputs::Function{.id=(func: ast::FuncId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(_: ast::ScopeId), .body=(body: ast::ScopeId), .exported=(_: bool)}: inputs::Function)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=implicit, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdFunc{.func=func}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=body}: var_decls::DeclarationScope))." .to_string(),
                                                                                                                fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                                                                {
                                                                                                                    let ::types::ddlog_std::tuple5(ref bound, ref func, ref file, ref implicit, ref body) = *<::types::ddlog_std::tuple5<::types::ast::Spanned<::types::internment::Intern<String>>, ::types::ast::FuncId, ::types::ast::FileId, bool, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                                                    let (ref name, ref span): (::types::internment::Intern<String>, ::types::ast::Span) = match (*bound).clone() {
                                                                                                                        ::types::ast::Spanned{data: name, span: span} => (name, span),
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    let ref meta: ::types::ddlog_std::Ref<::types::var_decls::VariableMeta> = match ::types::ddlog_std::ref_new((&(::types::var_decls::VariableMeta{is_function_argument: true, implicitly_declared: (*implicit).clone(), declaration_span: (::types::ddlog_std::Option::Some{x: (*span).clone()})}))) {
                                                                                                                        meta => meta,
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    let ref id: ::types::ast::AnyId = match (::types::ast::AnyId::AnyIdFunc{func: (*func).clone()}) {
                                                                                                                        id => id,
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    let ref scope: ::types::var_decls::DeclarationScope = match (::types::var_decls::DeclarationScope::Unhoistable{scope: (*body).clone()}) {
                                                                                                                        scope => scope,
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    Some(((::types::var_decls::VariableDeclarations{file: (*file).clone(), name: (*name).clone(), scope: (*scope).clone(), declared_in: (*id).clone(), meta: (*meta).clone()})).into_ddvalue())
                                                                                                                }
                                                                                                                __f},
                                                                                                                next: Box::new(None)
                                                                                                            }))
                                                                                    }))
                                                            }
                                                 },
                                                 /* var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::ArrowParam[(inputs::ArrowParam{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .param=(pat: internment::Intern<ast::Pattern>)}: inputs::ArrowParam)], inputs::Arrow[(inputs::Arrow{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .body=(ddlog_std::Some{.x=((_: ddlog_std::Either<ast::ExprId,ast::StmtId>), (body_scope: ast::ScopeId))}: ddlog_std::Option<(ddlog_std::Either<ast::ExprId,ast::StmtId>, ast::ScopeId)>)}: inputs::Arrow)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdExpr{.expr=expr}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=body_scope}: var_decls::DeclarationScope)). */
                                                 Rule::ArrangementRule {
                                                     description: "var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::ArrowParam[(inputs::ArrowParam{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .param=(pat: internment::Intern<ast::Pattern>)}: inputs::ArrowParam)], inputs::Arrow[(inputs::Arrow{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .body=(ddlog_std::Some{.x=((_: ddlog_std::Either<ast::ExprId,ast::StmtId>), (body_scope: ast::ScopeId))}: ddlog_std::Option<(ddlog_std::Either<ast::ExprId,ast::StmtId>, ast::ScopeId)>)}: inputs::Arrow)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdExpr{.expr=expr}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=body_scope}: var_decls::DeclarationScope)).".to_string(),
                                                     arr: ( Relations::inputs_ArrowParam as RelId, 0),
                                                     xform: XFormArrangement::Join{
                                                                description: "inputs::ArrowParam[(inputs::ArrowParam{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .param=(pat: internment::Intern<ast::Pattern>)}: inputs::ArrowParam)], inputs::Arrow[(inputs::Arrow{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .body=(ddlog_std::Some{.x=((_: ddlog_std::Either<ast::ExprId,ast::StmtId>), (body_scope: ast::ScopeId))}: ddlog_std::Option<(ddlog_std::Either<ast::ExprId,ast::StmtId>, ast::ScopeId)>)}: inputs::Arrow)]".to_string(),
                                                                ffun: None,
                                                                arrangement: (Relations::inputs_Arrow as RelId,0),
                                                                jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                {
                                                                    let (ref expr, ref file, ref pat) = match *<::types::inputs::ArrowParam>::from_ddvalue_ref(__v1) {
                                                                        ::types::inputs::ArrowParam{expr_id: ref expr, file: ref file, param: ref pat} => ((*expr).clone(), (*file).clone(), (*pat).clone()),
                                                                        _ => return None
                                                                    };
                                                                    let ref body_scope = match *<::types::inputs::Arrow>::from_ddvalue_ref(__v2) {
                                                                        ::types::inputs::Arrow{expr_id: _, file: _, body: ::types::ddlog_std::Option::Some{x: ::types::ddlog_std::tuple2(_, ref body_scope)}} => (*body_scope).clone(),
                                                                        _ => return None
                                                                    };
                                                                    Some((::types::ddlog_std::tuple4((*expr).clone(), (*file).clone(), (*pat).clone(), (*body_scope).clone())).into_ddvalue())
                                                                }
                                                                __f},
                                                                next: Box::new(Some(XFormCollection::FlatMap{
                                                                                        description: "inputs::ArrowParam[(inputs::ArrowParam{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .param=(pat: internment::Intern<ast::Pattern>)}: inputs::ArrowParam)], inputs::Arrow[(inputs::Arrow{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .body=(ddlog_std::Some{.x=((_: ddlog_std::Either<ast::ExprId,ast::StmtId>), (body_scope: ast::ScopeId))}: ddlog_std::Option<(ddlog_std::Either<ast::ExprId,ast::StmtId>, ast::ScopeId)>)}: inputs::Arrow)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat)))" .to_string(),
                                                                                        fmfun: {fn __f(__v: DDValue) -> Option<Box<dyn Iterator<Item=DDValue>>>
                                                                                        {
                                                                                            let ::types::ddlog_std::tuple4(ref expr, ref file, ref pat, ref body_scope) = *<::types::ddlog_std::tuple4<::types::ast::ExprId, ::types::ast::FileId, ::types::internment::Intern<::types::ast::Pattern>, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                            let __flattened = ::types::ast::bound_vars_internment_Intern__ast_Pattern_ddlog_std_Vec__ast_Spanned__internment_Intern____Stringval(pat);
                                                                                            let expr = (*expr).clone();
                                                                                            let file = (*file).clone();
                                                                                            let body_scope = (*body_scope).clone();
                                                                                            Some(Box::new(__flattened.into_iter().map(move |bound|(::types::ddlog_std::tuple4(bound.clone(), expr.clone(), file.clone(), body_scope.clone())).into_ddvalue())))
                                                                                        }
                                                                                        __f},
                                                                                        next: Box::new(Some(XFormCollection::FilterMap{
                                                                                                                description: "head of var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::ArrowParam[(inputs::ArrowParam{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .param=(pat: internment::Intern<ast::Pattern>)}: inputs::ArrowParam)], inputs::Arrow[(inputs::Arrow{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .body=(ddlog_std::Some{.x=((_: ddlog_std::Either<ast::ExprId,ast::StmtId>), (body_scope: ast::ScopeId))}: ddlog_std::Option<(ddlog_std::Either<ast::ExprId,ast::StmtId>, ast::ScopeId)>)}: inputs::Arrow)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdExpr{.expr=expr}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=body_scope}: var_decls::DeclarationScope))." .to_string(),
                                                                                                                fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                                                                {
                                                                                                                    let ::types::ddlog_std::tuple4(ref bound, ref expr, ref file, ref body_scope) = *<::types::ddlog_std::tuple4<::types::ast::Spanned<::types::internment::Intern<String>>, ::types::ast::ExprId, ::types::ast::FileId, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                                                    let (ref name, ref span): (::types::internment::Intern<String>, ::types::ast::Span) = match (*bound).clone() {
                                                                                                                        ::types::ast::Spanned{data: name, span: span} => (name, span),
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    let ref meta: ::types::ddlog_std::Ref<::types::var_decls::VariableMeta> = match ::types::ddlog_std::ref_new((&(::types::var_decls::VariableMeta{is_function_argument: true, implicitly_declared: false, declaration_span: (::types::ddlog_std::Option::Some{x: (*span).clone()})}))) {
                                                                                                                        meta => meta,
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    let ref id: ::types::ast::AnyId = match (::types::ast::AnyId::AnyIdExpr{expr: (*expr).clone()}) {
                                                                                                                        id => id,
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    let ref scope: ::types::var_decls::DeclarationScope = match (::types::var_decls::DeclarationScope::Unhoistable{scope: (*body_scope).clone()}) {
                                                                                                                        scope => scope,
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    Some(((::types::var_decls::VariableDeclarations{file: (*file).clone(), name: (*name).clone(), scope: (*scope).clone(), declared_in: (*id).clone(), meta: (*meta).clone()})).into_ddvalue())
                                                                                                                }
                                                                                                                __f},
                                                                                                                next: Box::new(None)
                                                                                                            }))
                                                                                    }))
                                                            }
                                                 },
                                                 /* var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::InlineFunc[(inputs::InlineFunc{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(span: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(ddlog_std::Some{.x=(body: ast::StmtId)}: ddlog_std::Option<ast::StmtId>)}: inputs::InlineFunc)], inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(body_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=true, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdExpr{.expr=expr}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=body_scope}: var_decls::DeclarationScope)). */
                                                 Rule::ArrangementRule {
                                                     description: "var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::InlineFunc[(inputs::InlineFunc{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(span: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(ddlog_std::Some{.x=(body: ast::StmtId)}: ddlog_std::Option<ast::StmtId>)}: inputs::InlineFunc)], inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(body_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=true, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdExpr{.expr=expr}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=body_scope}: var_decls::DeclarationScope)).".to_string(),
                                                     arr: ( Relations::inputs_InlineFunc as RelId, 1),
                                                     xform: XFormArrangement::Join{
                                                                description: "inputs::InlineFunc[(inputs::InlineFunc{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(span: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(ddlog_std::Some{.x=(body: ast::StmtId)}: ddlog_std::Option<ast::StmtId>)}: inputs::InlineFunc)], inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(body_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)]".to_string(),
                                                                ffun: None,
                                                                arrangement: (Relations::inputs_Statement as RelId,0),
                                                                jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                {
                                                                    let (ref expr, ref file, ref name, ref span, ref body) = match *<::types::inputs::InlineFunc>::from_ddvalue_ref(__v1) {
                                                                        ::types::inputs::InlineFunc{expr_id: ref expr, file: ref file, name: ::types::ddlog_std::Option::Some{x: ::types::ast::Spanned{data: ref name, span: ref span}}, body: ::types::ddlog_std::Option::Some{x: ref body}} => ((*expr).clone(), (*file).clone(), (*name).clone(), (*span).clone(), (*body).clone()),
                                                                        _ => return None
                                                                    };
                                                                    let ref body_scope = match *<::types::inputs::Statement>::from_ddvalue_ref(__v2) {
                                                                        ::types::inputs::Statement{id: _, file: _, kind: _, scope: ref body_scope, span: _} => (*body_scope).clone(),
                                                                        _ => return None
                                                                    };
                                                                    let ref meta: ::types::ddlog_std::Ref<::types::var_decls::VariableMeta> = match ::types::ddlog_std::ref_new((&(::types::var_decls::VariableMeta{is_function_argument: false, implicitly_declared: true, declaration_span: (::types::ddlog_std::Option::Some{x: (*span).clone()})}))) {
                                                                        meta => meta,
                                                                        _ => return None
                                                                    };
                                                                    let ref id: ::types::ast::AnyId = match (::types::ast::AnyId::AnyIdExpr{expr: (*expr).clone()}) {
                                                                        id => id,
                                                                        _ => return None
                                                                    };
                                                                    let ref scope: ::types::var_decls::DeclarationScope = match (::types::var_decls::DeclarationScope::Unhoistable{scope: (*body_scope).clone()}) {
                                                                        scope => scope,
                                                                        _ => return None
                                                                    };
                                                                    Some(((::types::var_decls::VariableDeclarations{file: (*file).clone(), name: (*name).clone(), scope: (*scope).clone(), declared_in: (*id).clone(), meta: (*meta).clone()})).into_ddvalue())
                                                                }
                                                                __f},
                                                                next: Box::new(None)
                                                            }
                                                 },
                                                 /* var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::InlineFuncParam[(inputs::InlineFuncParam{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .param=(pat: internment::Intern<ast::Pattern>)}: inputs::InlineFuncParam)], inputs::InlineFunc[(inputs::InlineFunc{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(ddlog_std::Some{.x=(body: ast::StmtId)}: ddlog_std::Option<ast::StmtId>)}: inputs::InlineFunc)], inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(body_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdExpr{.expr=expr}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=body_scope}: var_decls::DeclarationScope)). */
                                                 Rule::ArrangementRule {
                                                     description: "var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::InlineFuncParam[(inputs::InlineFuncParam{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .param=(pat: internment::Intern<ast::Pattern>)}: inputs::InlineFuncParam)], inputs::InlineFunc[(inputs::InlineFunc{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(ddlog_std::Some{.x=(body: ast::StmtId)}: ddlog_std::Option<ast::StmtId>)}: inputs::InlineFunc)], inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(body_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdExpr{.expr=expr}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=body_scope}: var_decls::DeclarationScope)).".to_string(),
                                                     arr: ( Relations::inputs_InlineFuncParam as RelId, 0),
                                                     xform: XFormArrangement::Join{
                                                                description: "inputs::InlineFuncParam[(inputs::InlineFuncParam{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .param=(pat: internment::Intern<ast::Pattern>)}: inputs::InlineFuncParam)], inputs::InlineFunc[(inputs::InlineFunc{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(ddlog_std::Some{.x=(body: ast::StmtId)}: ddlog_std::Option<ast::StmtId>)}: inputs::InlineFunc)]".to_string(),
                                                                ffun: None,
                                                                arrangement: (Relations::inputs_InlineFunc as RelId,2),
                                                                jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                {
                                                                    let (ref expr, ref file, ref pat) = match *<::types::inputs::InlineFuncParam>::from_ddvalue_ref(__v1) {
                                                                        ::types::inputs::InlineFuncParam{expr_id: ref expr, file: ref file, param: ref pat} => ((*expr).clone(), (*file).clone(), (*pat).clone()),
                                                                        _ => return None
                                                                    };
                                                                    let ref body = match *<::types::inputs::InlineFunc>::from_ddvalue_ref(__v2) {
                                                                        ::types::inputs::InlineFunc{expr_id: _, file: _, name: _, body: ::types::ddlog_std::Option::Some{x: ref body}} => (*body).clone(),
                                                                        _ => return None
                                                                    };
                                                                    Some((::types::ddlog_std::tuple4((*expr).clone(), (*file).clone(), (*pat).clone(), (*body).clone())).into_ddvalue())
                                                                }
                                                                __f},
                                                                next: Box::new(Some(XFormCollection::Arrange {
                                                                                        description: "arrange inputs::InlineFuncParam[(inputs::InlineFuncParam{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .param=(pat: internment::Intern<ast::Pattern>)}: inputs::InlineFuncParam)], inputs::InlineFunc[(inputs::InlineFunc{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(ddlog_std::Some{.x=(body: ast::StmtId)}: ddlog_std::Option<ast::StmtId>)}: inputs::InlineFunc)] by (body, file)" .to_string(),
                                                                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                        {
                                                                                            let ::types::ddlog_std::tuple4(ref expr, ref file, ref pat, ref body) = *<::types::ddlog_std::tuple4<::types::ast::ExprId, ::types::ast::FileId, ::types::internment::Intern<::types::ast::Pattern>, ::types::ast::StmtId>>::from_ddvalue_ref( &__v );
                                                                                            Some(((::types::ddlog_std::tuple2((*body).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple3((*expr).clone(), (*file).clone(), (*pat).clone())).into_ddvalue()))
                                                                                        }
                                                                                        __f},
                                                                                        next: Box::new(XFormArrangement::Join{
                                                                                                           description: "inputs::InlineFuncParam[(inputs::InlineFuncParam{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .param=(pat: internment::Intern<ast::Pattern>)}: inputs::InlineFuncParam)], inputs::InlineFunc[(inputs::InlineFunc{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(ddlog_std::Some{.x=(body: ast::StmtId)}: ddlog_std::Option<ast::StmtId>)}: inputs::InlineFunc)], inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(body_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)]".to_string(),
                                                                                                           ffun: None,
                                                                                                           arrangement: (Relations::inputs_Statement as RelId,0),
                                                                                                           jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                           {
                                                                                                               let ::types::ddlog_std::tuple3(ref expr, ref file, ref pat) = *<::types::ddlog_std::tuple3<::types::ast::ExprId, ::types::ast::FileId, ::types::internment::Intern<::types::ast::Pattern>>>::from_ddvalue_ref( __v1 );
                                                                                                               let ref body_scope = match *<::types::inputs::Statement>::from_ddvalue_ref(__v2) {
                                                                                                                   ::types::inputs::Statement{id: _, file: _, kind: _, scope: ref body_scope, span: _} => (*body_scope).clone(),
                                                                                                                   _ => return None
                                                                                                               };
                                                                                                               Some((::types::ddlog_std::tuple4((*expr).clone(), (*file).clone(), (*pat).clone(), (*body_scope).clone())).into_ddvalue())
                                                                                                           }
                                                                                                           __f},
                                                                                                           next: Box::new(Some(XFormCollection::FlatMap{
                                                                                                                                   description: "inputs::InlineFuncParam[(inputs::InlineFuncParam{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .param=(pat: internment::Intern<ast::Pattern>)}: inputs::InlineFuncParam)], inputs::InlineFunc[(inputs::InlineFunc{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(ddlog_std::Some{.x=(body: ast::StmtId)}: ddlog_std::Option<ast::StmtId>)}: inputs::InlineFunc)], inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(body_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat)))" .to_string(),
                                                                                                                                   fmfun: {fn __f(__v: DDValue) -> Option<Box<dyn Iterator<Item=DDValue>>>
                                                                                                                                   {
                                                                                                                                       let ::types::ddlog_std::tuple4(ref expr, ref file, ref pat, ref body_scope) = *<::types::ddlog_std::tuple4<::types::ast::ExprId, ::types::ast::FileId, ::types::internment::Intern<::types::ast::Pattern>, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                                                                       let __flattened = ::types::ast::bound_vars_internment_Intern__ast_Pattern_ddlog_std_Vec__ast_Spanned__internment_Intern____Stringval(pat);
                                                                                                                                       let expr = (*expr).clone();
                                                                                                                                       let file = (*file).clone();
                                                                                                                                       let body_scope = (*body_scope).clone();
                                                                                                                                       Some(Box::new(__flattened.into_iter().map(move |bound|(::types::ddlog_std::tuple4(bound.clone(), expr.clone(), file.clone(), body_scope.clone())).into_ddvalue())))
                                                                                                                                   }
                                                                                                                                   __f},
                                                                                                                                   next: Box::new(Some(XFormCollection::FilterMap{
                                                                                                                                                           description: "head of var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::InlineFuncParam[(inputs::InlineFuncParam{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .param=(pat: internment::Intern<ast::Pattern>)}: inputs::InlineFuncParam)], inputs::InlineFunc[(inputs::InlineFunc{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(ddlog_std::Some{.x=(body: ast::StmtId)}: ddlog_std::Option<ast::StmtId>)}: inputs::InlineFunc)], inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(body_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdExpr{.expr=expr}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=body_scope}: var_decls::DeclarationScope))." .to_string(),
                                                                                                                                                           fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                                                                                                           {
                                                                                                                                                               let ::types::ddlog_std::tuple4(ref bound, ref expr, ref file, ref body_scope) = *<::types::ddlog_std::tuple4<::types::ast::Spanned<::types::internment::Intern<String>>, ::types::ast::ExprId, ::types::ast::FileId, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                                                                                               let (ref name, ref span): (::types::internment::Intern<String>, ::types::ast::Span) = match (*bound).clone() {
                                                                                                                                                                   ::types::ast::Spanned{data: name, span: span} => (name, span),
                                                                                                                                                                   _ => return None
                                                                                                                                                               };
                                                                                                                                                               let ref meta: ::types::ddlog_std::Ref<::types::var_decls::VariableMeta> = match ::types::ddlog_std::ref_new((&(::types::var_decls::VariableMeta{is_function_argument: true, implicitly_declared: false, declaration_span: (::types::ddlog_std::Option::Some{x: (*span).clone()})}))) {
                                                                                                                                                                   meta => meta,
                                                                                                                                                                   _ => return None
                                                                                                                                                               };
                                                                                                                                                               let ref id: ::types::ast::AnyId = match (::types::ast::AnyId::AnyIdExpr{expr: (*expr).clone()}) {
                                                                                                                                                                   id => id,
                                                                                                                                                                   _ => return None
                                                                                                                                                               };
                                                                                                                                                               let ref scope: ::types::var_decls::DeclarationScope = match (::types::var_decls::DeclarationScope::Unhoistable{scope: (*body_scope).clone()}) {
                                                                                                                                                                   scope => scope,
                                                                                                                                                                   _ => return None
                                                                                                                                                               };
                                                                                                                                                               Some(((::types::var_decls::VariableDeclarations{file: (*file).clone(), name: (*name).clone(), scope: (*scope).clone(), declared_in: (*id).clone(), meta: (*meta).clone()})).into_ddvalue())
                                                                                                                                                           }
                                                                                                                                                           __f},
                                                                                                                                                           next: Box::new(None)
                                                                                                                                                       }))
                                                                                                                               }))
                                                                                                       })
                                                                                    }))
                                                            }
                                                 },
                                                 /* var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::Try[(inputs::Try{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .body=(_: ddlog_std::Option<ast::StmtId>), .handler=(ast::TryHandler{.error=(ddlog_std::Some{.x=(error: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .body=(ddlog_std::Some{.x=(body: ast::StmtId)}: ddlog_std::Option<ast::StmtId>)}: ast::TryHandler), .finalizer=(_: ddlog_std::Option<ast::StmtId>)}: inputs::Try)], inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(error))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdStmt{.stmt=stmt}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=stmt_scope}: var_decls::DeclarationScope)). */
                                                 Rule::ArrangementRule {
                                                     description: "var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::Try[(inputs::Try{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .body=(_: ddlog_std::Option<ast::StmtId>), .handler=(ast::TryHandler{.error=(ddlog_std::Some{.x=(error: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .body=(ddlog_std::Some{.x=(body: ast::StmtId)}: ddlog_std::Option<ast::StmtId>)}: ast::TryHandler), .finalizer=(_: ddlog_std::Option<ast::StmtId>)}: inputs::Try)], inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(error))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdStmt{.stmt=stmt}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=stmt_scope}: var_decls::DeclarationScope)).".to_string(),
                                                     arr: ( Relations::inputs_Try as RelId, 0),
                                                     xform: XFormArrangement::Join{
                                                                description: "inputs::Try[(inputs::Try{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .body=(_: ddlog_std::Option<ast::StmtId>), .handler=(ast::TryHandler{.error=(ddlog_std::Some{.x=(error: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .body=(ddlog_std::Some{.x=(body: ast::StmtId)}: ddlog_std::Option<ast::StmtId>)}: ast::TryHandler), .finalizer=(_: ddlog_std::Option<ast::StmtId>)}: inputs::Try)], inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)]".to_string(),
                                                                ffun: None,
                                                                arrangement: (Relations::inputs_Statement as RelId,0),
                                                                jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                {
                                                                    let (ref stmt, ref file, ref error, ref body) = match *<::types::inputs::Try>::from_ddvalue_ref(__v1) {
                                                                        ::types::inputs::Try{stmt_id: ref stmt, file: ref file, body: _, handler: ::types::ast::TryHandler{error: ::types::ddlog_std::Option::Some{x: ref error}, body: ::types::ddlog_std::Option::Some{x: ref body}}, finalizer: _} => ((*stmt).clone(), (*file).clone(), (*error).clone(), (*body).clone()),
                                                                        _ => return None
                                                                    };
                                                                    let ref stmt_scope = match *<::types::inputs::Statement>::from_ddvalue_ref(__v2) {
                                                                        ::types::inputs::Statement{id: _, file: _, kind: _, scope: ref stmt_scope, span: _} => (*stmt_scope).clone(),
                                                                        _ => return None
                                                                    };
                                                                    Some((::types::ddlog_std::tuple4((*stmt).clone(), (*file).clone(), (*error).clone(), (*stmt_scope).clone())).into_ddvalue())
                                                                }
                                                                __f},
                                                                next: Box::new(Some(XFormCollection::FlatMap{
                                                                                        description: "inputs::Try[(inputs::Try{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .body=(_: ddlog_std::Option<ast::StmtId>), .handler=(ast::TryHandler{.error=(ddlog_std::Some{.x=(error: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .body=(ddlog_std::Some{.x=(body: ast::StmtId)}: ddlog_std::Option<ast::StmtId>)}: ast::TryHandler), .finalizer=(_: ddlog_std::Option<ast::StmtId>)}: inputs::Try)], inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(error)))" .to_string(),
                                                                                        fmfun: {fn __f(__v: DDValue) -> Option<Box<dyn Iterator<Item=DDValue>>>
                                                                                        {
                                                                                            let ::types::ddlog_std::tuple4(ref stmt, ref file, ref error, ref stmt_scope) = *<::types::ddlog_std::tuple4<::types::ast::StmtId, ::types::ast::FileId, ::types::internment::Intern<::types::ast::Pattern>, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                            let __flattened = ::types::ast::bound_vars_internment_Intern__ast_Pattern_ddlog_std_Vec__ast_Spanned__internment_Intern____Stringval(error);
                                                                                            let stmt = (*stmt).clone();
                                                                                            let file = (*file).clone();
                                                                                            let stmt_scope = (*stmt_scope).clone();
                                                                                            Some(Box::new(__flattened.into_iter().map(move |bound|(::types::ddlog_std::tuple4(bound.clone(), stmt.clone(), file.clone(), stmt_scope.clone())).into_ddvalue())))
                                                                                        }
                                                                                        __f},
                                                                                        next: Box::new(Some(XFormCollection::FilterMap{
                                                                                                                description: "head of var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::Try[(inputs::Try{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .body=(_: ddlog_std::Option<ast::StmtId>), .handler=(ast::TryHandler{.error=(ddlog_std::Some{.x=(error: internment::Intern<ast::Pattern>)}: ddlog_std::Option<ast::IPattern>), .body=(ddlog_std::Some{.x=(body: ast::StmtId)}: ddlog_std::Option<ast::StmtId>)}: ast::TryHandler), .finalizer=(_: ddlog_std::Option<ast::StmtId>)}: inputs::Try)], inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], var bound = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(error))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdStmt{.stmt=stmt}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=stmt_scope}: var_decls::DeclarationScope))." .to_string(),
                                                                                                                fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                                                                {
                                                                                                                    let ::types::ddlog_std::tuple4(ref bound, ref stmt, ref file, ref stmt_scope) = *<::types::ddlog_std::tuple4<::types::ast::Spanned<::types::internment::Intern<String>>, ::types::ast::StmtId, ::types::ast::FileId, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                                                    let (ref name, ref span): (::types::internment::Intern<String>, ::types::ast::Span) = match (*bound).clone() {
                                                                                                                        ::types::ast::Spanned{data: name, span: span} => (name, span),
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    let ref meta: ::types::ddlog_std::Ref<::types::var_decls::VariableMeta> = match ::types::ddlog_std::ref_new((&(::types::var_decls::VariableMeta{is_function_argument: false, implicitly_declared: false, declaration_span: (::types::ddlog_std::Option::Some{x: (*span).clone()})}))) {
                                                                                                                        meta => meta,
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    let ref id: ::types::ast::AnyId = match (::types::ast::AnyId::AnyIdStmt{stmt: (*stmt).clone()}) {
                                                                                                                        id => id,
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    let ref scope: ::types::var_decls::DeclarationScope = match (::types::var_decls::DeclarationScope::Unhoistable{scope: (*stmt_scope).clone()}) {
                                                                                                                        scope => scope,
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    Some(((::types::var_decls::VariableDeclarations{file: (*file).clone(), name: (*name).clone(), scope: (*scope).clone(), declared_in: (*id).clone(), meta: (*meta).clone()})).into_ddvalue())
                                                                                                                }
                                                                                                                __f},
                                                                                                                next: Box::new(None)
                                                                                                            }))
                                                                                    }))
                                                            }
                                                 },
                                                 /* var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::Class[(inputs::Class{.id=(class: ast::ClassId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(ddlog_std::Some{.x=(elements: ddlog_std::Vec<ast::IClassElement>)}: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Class)], var elem = FlatMap(elements), ((ddlog_std::Some{.x=((var params: ddlog_std::Vec<ast::FuncParam>), (var body: ast::StmtId))}: ddlog_std::Option<(ddlog_std::Vec<ast::FuncParam>, ast::StmtId)>) = ((ast::method_comps: function(ast::ClassElement):ddlog_std::Option<(ddlog_std::Vec<ast::FuncParam>, ast::StmtId)>)(((internment::ival: function(internment::Intern<ast::ClassElement>):ast::ClassElement)(elem))))), inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], var bound = FlatMap(((vec::flatmap: function(ddlog_std::Vec<ast::FuncParam>, function(ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>)(params, (function(param: ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>{((ast::bound_vars: function(ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>)(param))})))), (((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>), (var implicit: bool)) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=implicit, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdClass{.class=class}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=stmt_scope}: var_decls::DeclarationScope)). */
                                                 Rule::CollectionRule {
                                                     description: "var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::Class[(inputs::Class{.id=(class: ast::ClassId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(ddlog_std::Some{.x=(elements: ddlog_std::Vec<ast::IClassElement>)}: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Class)], var elem = FlatMap(elements), ((ddlog_std::Some{.x=((var params: ddlog_std::Vec<ast::FuncParam>), (var body: ast::StmtId))}: ddlog_std::Option<(ddlog_std::Vec<ast::FuncParam>, ast::StmtId)>) = ((ast::method_comps: function(ast::ClassElement):ddlog_std::Option<(ddlog_std::Vec<ast::FuncParam>, ast::StmtId)>)(((internment::ival: function(internment::Intern<ast::ClassElement>):ast::ClassElement)(elem))))), inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], var bound = FlatMap(((vec::flatmap: function(ddlog_std::Vec<ast::FuncParam>, function(ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>)(params, (function(param: ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>{((ast::bound_vars: function(ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>)(param))})))), (((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>), (var implicit: bool)) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=implicit, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdClass{.class=class}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=stmt_scope}: var_decls::DeclarationScope)).".to_string(),
                                                     rel: Relations::inputs_Class as RelId,
                                                     xform: Some(XFormCollection::FlatMap{
                                                                     description: "inputs::Class[(inputs::Class{.id=(class: ast::ClassId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(ddlog_std::Some{.x=(elements: ddlog_std::Vec<ast::IClassElement>)}: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Class)], var elem = FlatMap(elements)" .to_string(),
                                                                     fmfun: {fn __f(__v: DDValue) -> Option<Box<dyn Iterator<Item=DDValue>>>
                                                                     {
                                                                         let (ref class, ref file, ref elements) = match *<::types::inputs::Class>::from_ddvalue_ref(&__v) {
                                                                             ::types::inputs::Class{id: ref class, file: ref file, name: _, parent: _, elements: ::types::ddlog_std::Option::Some{x: ref elements}, scope: _, exported: _} => ((*class).clone(), (*file).clone(), (*elements).clone()),
                                                                             _ => return None
                                                                         };
                                                                         let __flattened = (*elements).clone();
                                                                         let class = (*class).clone();
                                                                         let file = (*file).clone();
                                                                         Some(Box::new(__flattened.into_iter().map(move |elem|(::types::ddlog_std::tuple3(elem.clone(), class.clone(), file.clone())).into_ddvalue())))
                                                                     }
                                                                     __f},
                                                                     next: Box::new(Some(XFormCollection::Arrange {
                                                                                             description: "arrange inputs::Class[(inputs::Class{.id=(class: ast::ClassId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(ddlog_std::Some{.x=(elements: ddlog_std::Vec<ast::IClassElement>)}: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Class)], var elem = FlatMap(elements) by (body, file)" .to_string(),
                                                                                             afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                             {
                                                                                                 let ::types::ddlog_std::tuple3(ref elem, ref class, ref file) = *<::types::ddlog_std::tuple3<::types::internment::Intern<::types::ast::ClassElement>, ::types::ast::ClassId, ::types::ast::FileId>>::from_ddvalue_ref( &__v );
                                                                                                 let (ref params, ref body): (::types::ddlog_std::Vec<::types::ast::FuncParam>, ::types::ast::StmtId) = match ::types::ast::method_comps_ast_ClassElement_ddlog_std_Option____Tuple2__ddlog_std_Vec__ast_FuncParam_ast_StmtId(::types::internment::ival(elem)) {
                                                                                                     ::types::ddlog_std::Option::Some{x: ::types::ddlog_std::tuple2(params, body)} => (params, body),
                                                                                                     _ => return None
                                                                                                 };
                                                                                                 Some(((::types::ddlog_std::tuple2((*body).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple3((*class).clone(), (*file).clone(), (*params).clone())).into_ddvalue()))
                                                                                             }
                                                                                             __f},
                                                                                             next: Box::new(XFormArrangement::Join{
                                                                                                                description: "inputs::Class[(inputs::Class{.id=(class: ast::ClassId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(ddlog_std::Some{.x=(elements: ddlog_std::Vec<ast::IClassElement>)}: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Class)], var elem = FlatMap(elements), ((ddlog_std::Some{.x=((var params: ddlog_std::Vec<ast::FuncParam>), (var body: ast::StmtId))}: ddlog_std::Option<(ddlog_std::Vec<ast::FuncParam>, ast::StmtId)>) = ((ast::method_comps: function(ast::ClassElement):ddlog_std::Option<(ddlog_std::Vec<ast::FuncParam>, ast::StmtId)>)(((internment::ival: function(internment::Intern<ast::ClassElement>):ast::ClassElement)(elem))))), inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)]".to_string(),
                                                                                                                ffun: None,
                                                                                                                arrangement: (Relations::inputs_Statement as RelId,0),
                                                                                                                jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                {
                                                                                                                    let ::types::ddlog_std::tuple3(ref class, ref file, ref params) = *<::types::ddlog_std::tuple3<::types::ast::ClassId, ::types::ast::FileId, ::types::ddlog_std::Vec<::types::ast::FuncParam>>>::from_ddvalue_ref( __v1 );
                                                                                                                    let ref stmt_scope = match *<::types::inputs::Statement>::from_ddvalue_ref(__v2) {
                                                                                                                        ::types::inputs::Statement{id: _, file: _, kind: _, scope: ref stmt_scope, span: _} => (*stmt_scope).clone(),
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    Some((::types::ddlog_std::tuple4((*class).clone(), (*file).clone(), (*params).clone(), (*stmt_scope).clone())).into_ddvalue())
                                                                                                                }
                                                                                                                __f},
                                                                                                                next: Box::new(Some(XFormCollection::FlatMap{
                                                                                                                                        description: "inputs::Class[(inputs::Class{.id=(class: ast::ClassId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(ddlog_std::Some{.x=(elements: ddlog_std::Vec<ast::IClassElement>)}: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Class)], var elem = FlatMap(elements), ((ddlog_std::Some{.x=((var params: ddlog_std::Vec<ast::FuncParam>), (var body: ast::StmtId))}: ddlog_std::Option<(ddlog_std::Vec<ast::FuncParam>, ast::StmtId)>) = ((ast::method_comps: function(ast::ClassElement):ddlog_std::Option<(ddlog_std::Vec<ast::FuncParam>, ast::StmtId)>)(((internment::ival: function(internment::Intern<ast::ClassElement>):ast::ClassElement)(elem))))), inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], var bound = FlatMap(((vec::flatmap: function(ddlog_std::Vec<ast::FuncParam>, function(ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>)(params, (function(param: ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>{((ast::bound_vars: function(ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>)(param))}))))" .to_string(),
                                                                                                                                        fmfun: {fn __f(__v: DDValue) -> Option<Box<dyn Iterator<Item=DDValue>>>
                                                                                                                                        {
                                                                                                                                            let ::types::ddlog_std::tuple4(ref class, ref file, ref params, ref stmt_scope) = *<::types::ddlog_std::tuple4<::types::ast::ClassId, ::types::ast::FileId, ::types::ddlog_std::Vec<::types::ast::FuncParam>, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                                                                            let __flattened = ::types::vec::flatmap::<::types::ast::FuncParam, ::types::ddlog_std::tuple2<::types::ast::Spanned<::types::internment::Intern<String>>, bool>>(params, (&{
                                                                                                                                                                                                                                                                                                                           (Box::new(closure::ClosureImpl{
                                                                                                                                                                                                                                                                                                                               description: "(function(param: ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>{(ast::bound_vars(param))})",
                                                                                                                                                                                                                                                                                                                               captured: (),
                                                                                                                                                                                                                                                                                                                               f: {
                                                                                                                                                                                                                                                                                                                                      fn __f(__args:*const ::types::ast::FuncParam, __captured: &()) -> ::types::ddlog_std::Vec<::types::ddlog_std::tuple2<::types::ast::Spanned<::types::internment::Intern<String>>, bool>>
                                                                                                                                                                                                                                                                                                                                      {
                                                                                                                                                                                                                                                                                                                                          let param = unsafe{&*__args};
                                                                                                                                                                                                                                                                                                                                          ::types::ast::bound_vars_ast_FuncParam_ddlog_std_Vec____Tuple2__ast_Spanned__internment_Intern____Stringval___Boolval(param)
                                                                                                                                                                                                                                                                                                                                      }
                                                                                                                                                                                                                                                                                                                                      __f
                                                                                                                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                                                                                                           }) as Box<dyn closure::Closure<(*const ::types::ast::FuncParam), ::types::ddlog_std::Vec<::types::ddlog_std::tuple2<::types::ast::Spanned<::types::internment::Intern<String>>, bool>>>>)
                                                                                                                                                                                                                                                                                                                       }));
                                                                                                                                            let class = (*class).clone();
                                                                                                                                            let file = (*file).clone();
                                                                                                                                            let stmt_scope = (*stmt_scope).clone();
                                                                                                                                            Some(Box::new(__flattened.into_iter().map(move |bound|(::types::ddlog_std::tuple4(bound.clone(), class.clone(), file.clone(), stmt_scope.clone())).into_ddvalue())))
                                                                                                                                        }
                                                                                                                                        __f},
                                                                                                                                        next: Box::new(Some(XFormCollection::FilterMap{
                                                                                                                                                                description: "head of var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::Class[(inputs::Class{.id=(class: ast::ClassId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(ddlog_std::Some{.x=(elements: ddlog_std::Vec<ast::IClassElement>)}: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Class)], var elem = FlatMap(elements), ((ddlog_std::Some{.x=((var params: ddlog_std::Vec<ast::FuncParam>), (var body: ast::StmtId))}: ddlog_std::Option<(ddlog_std::Vec<ast::FuncParam>, ast::StmtId)>) = ((ast::method_comps: function(ast::ClassElement):ddlog_std::Option<(ddlog_std::Vec<ast::FuncParam>, ast::StmtId)>)(((internment::ival: function(internment::Intern<ast::ClassElement>):ast::ClassElement)(elem))))), inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], var bound = FlatMap(((vec::flatmap: function(ddlog_std::Vec<ast::FuncParam>, function(ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>)(params, (function(param: ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>{((ast::bound_vars: function(ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>)(param))})))), (((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>), (var implicit: bool)) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=implicit, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdClass{.class=class}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=stmt_scope}: var_decls::DeclarationScope))." .to_string(),
                                                                                                                                                                fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                                                                                                                {
                                                                                                                                                                    let ::types::ddlog_std::tuple4(ref bound, ref class, ref file, ref stmt_scope) = *<::types::ddlog_std::tuple4<::types::ddlog_std::tuple2<::types::ast::Spanned<::types::internment::Intern<String>>, bool>, ::types::ast::ClassId, ::types::ast::FileId, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                                                                                                    let (ref name, ref span, ref implicit): (::types::internment::Intern<String>, ::types::ast::Span, bool) = match (*bound).clone() {
                                                                                                                                                                        ::types::ddlog_std::tuple2(::types::ast::Spanned{data: name, span: span}, implicit) => (name, span, implicit),
                                                                                                                                                                        _ => return None
                                                                                                                                                                    };
                                                                                                                                                                    let ref meta: ::types::ddlog_std::Ref<::types::var_decls::VariableMeta> = match ::types::ddlog_std::ref_new((&(::types::var_decls::VariableMeta{is_function_argument: true, implicitly_declared: (*implicit).clone(), declaration_span: (::types::ddlog_std::Option::Some{x: (*span).clone()})}))) {
                                                                                                                                                                        meta => meta,
                                                                                                                                                                        _ => return None
                                                                                                                                                                    };
                                                                                                                                                                    let ref id: ::types::ast::AnyId = match (::types::ast::AnyId::AnyIdClass{class: (*class).clone()}) {
                                                                                                                                                                        id => id,
                                                                                                                                                                        _ => return None
                                                                                                                                                                    };
                                                                                                                                                                    let ref scope: ::types::var_decls::DeclarationScope = match (::types::var_decls::DeclarationScope::Unhoistable{scope: (*stmt_scope).clone()}) {
                                                                                                                                                                        scope => scope,
                                                                                                                                                                        _ => return None
                                                                                                                                                                    };
                                                                                                                                                                    Some(((::types::var_decls::VariableDeclarations{file: (*file).clone(), name: (*name).clone(), scope: (*scope).clone(), declared_in: (*id).clone(), meta: (*meta).clone()})).into_ddvalue())
                                                                                                                                                                }
                                                                                                                                                                __f},
                                                                                                                                                                next: Box::new(None)
                                                                                                                                                            }))
                                                                                                                                    }))
                                                                                                            })
                                                                                         }))
                                                                 })
                                                 },
                                                 /* var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::Property[(inputs::Property{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .key=(_: ddlog_std::Option<ast::PropertyKey>), .val=(ddlog_std::Some{.x=(val: ast::PropertyVal)}: ddlog_std::Option<ast::PropertyVal>)}: inputs::Property)], ((ddlog_std::Some{.x=((var params: ddlog_std::Vec<ast::FuncParam>), (var body: ast::StmtId))}: ddlog_std::Option<(ddlog_std::Vec<ast::FuncParam>, ast::StmtId)>) = ((ast::method_comps: function(ast::PropertyVal):ddlog_std::Option<(ddlog_std::Vec<ast::FuncParam>, ast::StmtId)>)(val))), inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], var bound = FlatMap(((vec::flatmap: function(ddlog_std::Vec<ast::FuncParam>, function(ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>)(params, (function(param: ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>{((ast::bound_vars: function(ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>)(param))})))), (((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>), (var implicit: bool)) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=implicit, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdExpr{.expr=expr}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=stmt_scope}: var_decls::DeclarationScope)). */
                                                 Rule::CollectionRule {
                                                     description: "var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::Property[(inputs::Property{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .key=(_: ddlog_std::Option<ast::PropertyKey>), .val=(ddlog_std::Some{.x=(val: ast::PropertyVal)}: ddlog_std::Option<ast::PropertyVal>)}: inputs::Property)], ((ddlog_std::Some{.x=((var params: ddlog_std::Vec<ast::FuncParam>), (var body: ast::StmtId))}: ddlog_std::Option<(ddlog_std::Vec<ast::FuncParam>, ast::StmtId)>) = ((ast::method_comps: function(ast::PropertyVal):ddlog_std::Option<(ddlog_std::Vec<ast::FuncParam>, ast::StmtId)>)(val))), inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], var bound = FlatMap(((vec::flatmap: function(ddlog_std::Vec<ast::FuncParam>, function(ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>)(params, (function(param: ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>{((ast::bound_vars: function(ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>)(param))})))), (((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>), (var implicit: bool)) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=implicit, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdExpr{.expr=expr}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=stmt_scope}: var_decls::DeclarationScope)).".to_string(),
                                                     rel: Relations::inputs_Property as RelId,
                                                     xform: Some(XFormCollection::Arrange {
                                                                     description: "arrange inputs::Property[(inputs::Property{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .key=(_: ddlog_std::Option<ast::PropertyKey>), .val=(ddlog_std::Some{.x=(val: ast::PropertyVal)}: ddlog_std::Option<ast::PropertyVal>)}: inputs::Property)] by (body, file)" .to_string(),
                                                                     afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                     {
                                                                         let (ref expr, ref file, ref val) = match *<::types::inputs::Property>::from_ddvalue_ref(&__v) {
                                                                             ::types::inputs::Property{expr_id: ref expr, file: ref file, key: _, val: ::types::ddlog_std::Option::Some{x: ref val}} => ((*expr).clone(), (*file).clone(), (*val).clone()),
                                                                             _ => return None
                                                                         };
                                                                         let (ref params, ref body): (::types::ddlog_std::Vec<::types::ast::FuncParam>, ::types::ast::StmtId) = match ::types::ast::method_comps_ast_PropertyVal_ddlog_std_Option____Tuple2__ddlog_std_Vec__ast_FuncParam_ast_StmtId(val) {
                                                                             ::types::ddlog_std::Option::Some{x: ::types::ddlog_std::tuple2(params, body)} => (params, body),
                                                                             _ => return None
                                                                         };
                                                                         Some(((::types::ddlog_std::tuple2((*body).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple3((*expr).clone(), (*file).clone(), (*params).clone())).into_ddvalue()))
                                                                     }
                                                                     __f},
                                                                     next: Box::new(XFormArrangement::Join{
                                                                                        description: "inputs::Property[(inputs::Property{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .key=(_: ddlog_std::Option<ast::PropertyKey>), .val=(ddlog_std::Some{.x=(val: ast::PropertyVal)}: ddlog_std::Option<ast::PropertyVal>)}: inputs::Property)], ((ddlog_std::Some{.x=((var params: ddlog_std::Vec<ast::FuncParam>), (var body: ast::StmtId))}: ddlog_std::Option<(ddlog_std::Vec<ast::FuncParam>, ast::StmtId)>) = ((ast::method_comps: function(ast::PropertyVal):ddlog_std::Option<(ddlog_std::Vec<ast::FuncParam>, ast::StmtId)>)(val))), inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)]".to_string(),
                                                                                        ffun: None,
                                                                                        arrangement: (Relations::inputs_Statement as RelId,0),
                                                                                        jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                        {
                                                                                            let ::types::ddlog_std::tuple3(ref expr, ref file, ref params) = *<::types::ddlog_std::tuple3<::types::ast::ExprId, ::types::ast::FileId, ::types::ddlog_std::Vec<::types::ast::FuncParam>>>::from_ddvalue_ref( __v1 );
                                                                                            let ref stmt_scope = match *<::types::inputs::Statement>::from_ddvalue_ref(__v2) {
                                                                                                ::types::inputs::Statement{id: _, file: _, kind: _, scope: ref stmt_scope, span: _} => (*stmt_scope).clone(),
                                                                                                _ => return None
                                                                                            };
                                                                                            Some((::types::ddlog_std::tuple4((*expr).clone(), (*file).clone(), (*params).clone(), (*stmt_scope).clone())).into_ddvalue())
                                                                                        }
                                                                                        __f},
                                                                                        next: Box::new(Some(XFormCollection::FlatMap{
                                                                                                                description: "inputs::Property[(inputs::Property{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .key=(_: ddlog_std::Option<ast::PropertyKey>), .val=(ddlog_std::Some{.x=(val: ast::PropertyVal)}: ddlog_std::Option<ast::PropertyVal>)}: inputs::Property)], ((ddlog_std::Some{.x=((var params: ddlog_std::Vec<ast::FuncParam>), (var body: ast::StmtId))}: ddlog_std::Option<(ddlog_std::Vec<ast::FuncParam>, ast::StmtId)>) = ((ast::method_comps: function(ast::PropertyVal):ddlog_std::Option<(ddlog_std::Vec<ast::FuncParam>, ast::StmtId)>)(val))), inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], var bound = FlatMap(((vec::flatmap: function(ddlog_std::Vec<ast::FuncParam>, function(ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>)(params, (function(param: ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>{((ast::bound_vars: function(ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>)(param))}))))" .to_string(),
                                                                                                                fmfun: {fn __f(__v: DDValue) -> Option<Box<dyn Iterator<Item=DDValue>>>
                                                                                                                {
                                                                                                                    let ::types::ddlog_std::tuple4(ref expr, ref file, ref params, ref stmt_scope) = *<::types::ddlog_std::tuple4<::types::ast::ExprId, ::types::ast::FileId, ::types::ddlog_std::Vec<::types::ast::FuncParam>, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                                                    let __flattened = ::types::vec::flatmap::<::types::ast::FuncParam, ::types::ddlog_std::tuple2<::types::ast::Spanned<::types::internment::Intern<String>>, bool>>(params, (&{
                                                                                                                                                                                                                                                                                                   (Box::new(closure::ClosureImpl{
                                                                                                                                                                                                                                                                                                       description: "(function(param: ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>{(ast::bound_vars(param))})",
                                                                                                                                                                                                                                                                                                       captured: (),
                                                                                                                                                                                                                                                                                                       f: {
                                                                                                                                                                                                                                                                                                              fn __f(__args:*const ::types::ast::FuncParam, __captured: &()) -> ::types::ddlog_std::Vec<::types::ddlog_std::tuple2<::types::ast::Spanned<::types::internment::Intern<String>>, bool>>
                                                                                                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                                                                                                  let param = unsafe{&*__args};
                                                                                                                                                                                                                                                                                                                  ::types::ast::bound_vars_ast_FuncParam_ddlog_std_Vec____Tuple2__ast_Spanned__internment_Intern____Stringval___Boolval(param)
                                                                                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                                                                                              __f
                                                                                                                                                                                                                                                                                                          }
                                                                                                                                                                                                                                                                                                   }) as Box<dyn closure::Closure<(*const ::types::ast::FuncParam), ::types::ddlog_std::Vec<::types::ddlog_std::tuple2<::types::ast::Spanned<::types::internment::Intern<String>>, bool>>>>)
                                                                                                                                                                                                                                                                                               }));
                                                                                                                    let expr = (*expr).clone();
                                                                                                                    let file = (*file).clone();
                                                                                                                    let stmt_scope = (*stmt_scope).clone();
                                                                                                                    Some(Box::new(__flattened.into_iter().map(move |bound|(::types::ddlog_std::tuple4(bound.clone(), expr.clone(), file.clone(), stmt_scope.clone())).into_ddvalue())))
                                                                                                                }
                                                                                                                __f},
                                                                                                                next: Box::new(Some(XFormCollection::FilterMap{
                                                                                                                                        description: "head of var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=file, .name=name, .scope=scope, .declared_in=id, .meta=meta}: var_decls::VariableDeclarations)] :- inputs::Property[(inputs::Property{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .key=(_: ddlog_std::Option<ast::PropertyKey>), .val=(ddlog_std::Some{.x=(val: ast::PropertyVal)}: ddlog_std::Option<ast::PropertyVal>)}: inputs::Property)], ((ddlog_std::Some{.x=((var params: ddlog_std::Vec<ast::FuncParam>), (var body: ast::StmtId))}: ddlog_std::Option<(ddlog_std::Vec<ast::FuncParam>, ast::StmtId)>) = ((ast::method_comps: function(ast::PropertyVal):ddlog_std::Option<(ddlog_std::Vec<ast::FuncParam>, ast::StmtId)>)(val))), inputs::Statement[(inputs::Statement{.id=(body: ast::StmtId), .file=(file: ast::FileId), .kind=(_: ast::StmtKind), .scope=(stmt_scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)], var bound = FlatMap(((vec::flatmap: function(ddlog_std::Vec<ast::FuncParam>, function(ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>)(params, (function(param: ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>{((ast::bound_vars: function(ast::FuncParam):ddlog_std::Vec<(ast::Spanned<internment::Intern<string>>, bool)>)(param))})))), (((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>), (var implicit: bool)) = bound), ((var meta: ddlog_std::Ref<var_decls::VariableMeta>) = ((ddlog_std::ref_new: function(var_decls::VariableMeta):ddlog_std::Ref<var_decls::VariableMeta>)((var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=implicit, .declaration_span=(ddlog_std::Some{.x=span}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)))), ((var id: ast::AnyId) = (ast::AnyIdExpr{.expr=expr}: ast::AnyId)), ((var scope: var_decls::DeclarationScope) = (var_decls::Unhoistable{.scope=stmt_scope}: var_decls::DeclarationScope))." .to_string(),
                                                                                                                                        fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                                                                                        {
                                                                                                                                            let ::types::ddlog_std::tuple4(ref bound, ref expr, ref file, ref stmt_scope) = *<::types::ddlog_std::tuple4<::types::ddlog_std::tuple2<::types::ast::Spanned<::types::internment::Intern<String>>, bool>, ::types::ast::ExprId, ::types::ast::FileId, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                                                                            let (ref name, ref span, ref implicit): (::types::internment::Intern<String>, ::types::ast::Span, bool) = match (*bound).clone() {
                                                                                                                                                ::types::ddlog_std::tuple2(::types::ast::Spanned{data: name, span: span}, implicit) => (name, span, implicit),
                                                                                                                                                _ => return None
                                                                                                                                            };
                                                                                                                                            let ref meta: ::types::ddlog_std::Ref<::types::var_decls::VariableMeta> = match ::types::ddlog_std::ref_new((&(::types::var_decls::VariableMeta{is_function_argument: false, implicitly_declared: (*implicit).clone(), declaration_span: (::types::ddlog_std::Option::Some{x: (*span).clone()})}))) {
                                                                                                                                                meta => meta,
                                                                                                                                                _ => return None
                                                                                                                                            };
                                                                                                                                            let ref id: ::types::ast::AnyId = match (::types::ast::AnyId::AnyIdExpr{expr: (*expr).clone()}) {
                                                                                                                                                id => id,
                                                                                                                                                _ => return None
                                                                                                                                            };
                                                                                                                                            let ref scope: ::types::var_decls::DeclarationScope = match (::types::var_decls::DeclarationScope::Unhoistable{scope: (*stmt_scope).clone()}) {
                                                                                                                                                scope => scope,
                                                                                                                                                _ => return None
                                                                                                                                            };
                                                                                                                                            Some(((::types::var_decls::VariableDeclarations{file: (*file).clone(), name: (*name).clone(), scope: (*scope).clone(), declared_in: (*id).clone(), meta: (*meta).clone()})).into_ddvalue())
                                                                                                                                        }
                                                                                                                                        __f},
                                                                                                                                        next: Box::new(None)
                                                                                                                                    }))
                                                                                                            }))
                                                                                    })
                                                                 })
                                                 }],
                                             arrangements: vec![
                                                 Arrangement::Map{
                                                    name: r###"(var_decls::VariableDeclarations{.file=(_0: ast::FileId), .name=(_1: internment::Intern<string>), .scope=(_: var_decls::DeclarationScope), .declared_in=(_2: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations) /*join*/"###.to_string(),
                                                     afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                     {
                                                         let __cloned = __v.clone();
                                                         match < ::types::var_decls::VariableDeclarations>::from_ddvalue(__v) {
                                                             ::types::var_decls::VariableDeclarations{file: ref _0, name: ref _1, scope: _, declared_in: ref _2, meta: _} => Some((::types::ddlog_std::tuple3((*_0).clone(), (*_1).clone(), (*_2).clone())).into_ddvalue()),
                                                             _ => None
                                                         }.map(|x|(x,__cloned))
                                                     }
                                                     __f},
                                                     queryable: false
                                                 },
                                                 Arrangement::Set{
                                                     name: r###"(var_decls::VariableDeclarations{.file=(_0: ast::FileId), .name=(_1: internment::Intern<string>), .scope=(var_decls::Unhoistable{.scope=(_2: ast::ScopeId)}: var_decls::DeclarationScope), .declared_in=(_: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations) /*antijoin*/"###.to_string(),
                                                     fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                     {
                                                         match < ::types::var_decls::VariableDeclarations>::from_ddvalue(__v) {
                                                             ::types::var_decls::VariableDeclarations{file: ref _0, name: ref _1, scope: ::types::var_decls::DeclarationScope::Unhoistable{scope: ref _2}, declared_in: _, meta: _} => Some((::types::ddlog_std::tuple3((*_0).clone(), (*_1).clone(), (*_2).clone())).into_ddvalue()),
                                                             _ => None
                                                         }
                                                     }
                                                     __f},
                                                     distinct: true
                                                 },
                                                 Arrangement::Set{
                                                     name: r###"(var_decls::VariableDeclarations{.file=(_0: ast::FileId), .name=(_1: internment::Intern<string>), .scope=(var_decls::Hoistable{.hoisted=(_2: ast::ScopeId), .unhoisted=(_: ast::ScopeId)}: var_decls::DeclarationScope), .declared_in=(_: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations) /*antijoin*/"###.to_string(),
                                                     fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                     {
                                                         match < ::types::var_decls::VariableDeclarations>::from_ddvalue(__v) {
                                                             ::types::var_decls::VariableDeclarations{file: ref _0, name: ref _1, scope: ::types::var_decls::DeclarationScope::Hoistable{hoisted: ref _2, unhoisted: _}, declared_in: _, meta: _} => Some((::types::ddlog_std::tuple3((*_0).clone(), (*_1).clone(), (*_2).clone())).into_ddvalue()),
                                                             _ => None
                                                         }
                                                     }
                                                     __f},
                                                     distinct: true
                                                 },
                                                 Arrangement::Map{
                                                    name: r###"(var_decls::VariableDeclarations{.file=(_0: ast::FileId), .name=(_: internment::Intern<string>), .scope=(_: var_decls::DeclarationScope), .declared_in=(_: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=(_: bool), .implicitly_declared=false, .declaration_span=(_: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations) /*join*/"###.to_string(),
                                                     afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                     {
                                                         let __cloned = __v.clone();
                                                         match < ::types::var_decls::VariableDeclarations>::from_ddvalue(__v) {
                                                             ::types::var_decls::VariableDeclarations{file: ref _0, name: _, scope: _, declared_in: _, meta: ref _0_} => match ((*_0_)).deref() {
                                                                                                                                                                             ::types::var_decls::VariableMeta{is_function_argument: _, implicitly_declared: false, declaration_span: _} => Some(((*_0).clone()).into_ddvalue()),
                                                                                                                                                                             _ => None
                                                                                                                                                                         },
                                                             _ => None
                                                         }.map(|x|(x,__cloned))
                                                     }
                                                     __f},
                                                     queryable: false
                                                 },
                                                 Arrangement::Map{
                                                    name: r###"(var_decls::VariableDeclarations{.file=(_0: ast::FileId), .name=(_: internment::Intern<string>), .scope=(_: var_decls::DeclarationScope), .declared_in=(_: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=(_: bool), .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(_: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations) /*join*/"###.to_string(),
                                                     afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                     {
                                                         let __cloned = __v.clone();
                                                         match < ::types::var_decls::VariableDeclarations>::from_ddvalue(__v) {
                                                             ::types::var_decls::VariableDeclarations{file: ref _0, name: _, scope: _, declared_in: _, meta: ref _0_} => match ((*_0_)).deref() {
                                                                                                                                                                             ::types::var_decls::VariableMeta{is_function_argument: _, implicitly_declared: false, declaration_span: ::types::ddlog_std::Option::Some{x: _}} => Some(((*_0).clone()).into_ddvalue()),
                                                                                                                                                                             _ => None
                                                                                                                                                                         },
                                                             _ => None
                                                         }.map(|x|(x,__cloned))
                                                     }
                                                     __f},
                                                     queryable: false
                                                 },
                                                 Arrangement::Map{
                                                    name: r###"(var_decls::VariableDeclarations{.file=(_0: ast::FileId), .name=(_1: internment::Intern<string>), .scope=(_: var_decls::DeclarationScope), .declared_in=(_2: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=(_: bool), .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(_: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations) /*join*/"###.to_string(),
                                                     afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                     {
                                                         let __cloned = __v.clone();
                                                         match < ::types::var_decls::VariableDeclarations>::from_ddvalue(__v) {
                                                             ::types::var_decls::VariableDeclarations{file: ref _0, name: ref _1, scope: _, declared_in: ref _2, meta: ref _0_} => match ((*_0_)).deref() {
                                                                                                                                                                                       ::types::var_decls::VariableMeta{is_function_argument: _, implicitly_declared: false, declaration_span: ::types::ddlog_std::Option::Some{x: _}} => Some((::types::ddlog_std::tuple3((*_0).clone(), (*_1).clone(), (*_2).clone())).into_ddvalue()),
                                                                                                                                                                                       _ => None
                                                                                                                                                                                   },
                                                             _ => None
                                                         }.map(|x|(x,__cloned))
                                                     }
                                                     __f},
                                                     queryable: false
                                                 },
                                                 Arrangement::Map{
                                                    name: r###"(var_decls::VariableDeclarations{.file=(_0: ast::FileId), .name=(_: internment::Intern<string>), .scope=(_: var_decls::DeclarationScope), .declared_in=(_: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(_: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations) /*join*/"###.to_string(),
                                                     afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                     {
                                                         let __cloned = __v.clone();
                                                         match < ::types::var_decls::VariableDeclarations>::from_ddvalue(__v) {
                                                             ::types::var_decls::VariableDeclarations{file: ref _0, name: _, scope: _, declared_in: _, meta: ref _0_} => match ((*_0_)).deref() {
                                                                                                                                                                             ::types::var_decls::VariableMeta{is_function_argument: false, implicitly_declared: false, declaration_span: ::types::ddlog_std::Option::Some{x: _}} => Some(((*_0).clone()).into_ddvalue()),
                                                                                                                                                                             _ => None
                                                                                                                                                                         },
                                                             _ => None
                                                         }.map(|x|(x,__cloned))
                                                     }
                                                     __f},
                                                     queryable: false
                                                 },
                                                 Arrangement::Map{
                                                    name: r###"(var_decls::VariableDeclarations{.file=(_0: ast::FileId), .name=(_: internment::Intern<string>), .scope=(_: var_decls::DeclarationScope), .declared_in=(_: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(_: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations) /*join*/"###.to_string(),
                                                     afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                     {
                                                         let __cloned = __v.clone();
                                                         match < ::types::var_decls::VariableDeclarations>::from_ddvalue(__v) {
                                                             ::types::var_decls::VariableDeclarations{file: ref _0, name: _, scope: _, declared_in: _, meta: ref _0_} => match ((*_0_)).deref() {
                                                                                                                                                                             ::types::var_decls::VariableMeta{is_function_argument: true, implicitly_declared: false, declaration_span: ::types::ddlog_std::Option::Some{x: _}} => Some(((*_0).clone()).into_ddvalue()),
                                                                                                                                                                             _ => None
                                                                                                                                                                         },
                                                             _ => None
                                                         }.map(|x|(x,__cloned))
                                                     }
                                                     __f},
                                                     queryable: false
                                                 },
                                                 Arrangement::Map{
                                                    name: r###"(var_decls::VariableDeclarations{.file=(_0: ast::FileId), .name=(_: internment::Intern<string>), .scope=(_: var_decls::DeclarationScope), .declared_in=(ast::AnyIdGlobal{.global=(_: ast::GlobalId)}: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(_: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations) /*join*/"###.to_string(),
                                                     afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                     {
                                                         let __cloned = __v.clone();
                                                         match < ::types::var_decls::VariableDeclarations>::from_ddvalue(__v) {
                                                             ::types::var_decls::VariableDeclarations{file: ref _0, name: _, scope: _, declared_in: ::types::ast::AnyId::AnyIdGlobal{global: _}, meta: ref _0_} => match ((*_0_)).deref() {
                                                                                                                                                                                                                       ::types::var_decls::VariableMeta{is_function_argument: false, implicitly_declared: false, declaration_span: ::types::ddlog_std::Option::Some{x: _}} => Some(((*_0).clone()).into_ddvalue()),
                                                                                                                                                                                                                       _ => None
                                                                                                                                                                                                                   },
                                                             _ => None
                                                         }.map(|x|(x,__cloned))
                                                     }
                                                     __f},
                                                     queryable: false
                                                 }],
                                             change_cb:    None
                                         };
    let outputs_no_shadow_DeclarationVisibleWithin = Relation {
                                                         name:         "outputs::no_shadow::DeclarationVisibleWithin".to_string(),
                                                         input:        false,
                                                         distinct:     false,
                                                         caching_mode: CachingMode::Set,
                                                         key_func:     None,
                                                         id:           Relations::outputs_no_shadow_DeclarationVisibleWithin as RelId,
                                                         rules:        vec![
                                                             /* outputs::no_shadow::DeclarationVisibleWithin[(outputs::no_shadow::DeclarationVisibleWithin{.file=file, .scope=scope, .declaration=declaration}: outputs::no_shadow::DeclarationVisibleWithin)] :- __Prefix_5[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(_: internment::Intern<string>), .scope=(decl_scope: var_decls::DeclarationScope), .declared_in=(declaration: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=(_: bool), .implicitly_declared=false, .declaration_span=(_: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], (not (ast::is_global(declaration))), ((var scope: ast::ScopeId) = if (config::no_shadow_hoisting(config)) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (var_decls::hoisted_scope(decl_scope))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  (var_decls::unhoisted_scope(decl_scope))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              }). */
                                                             Rule::ArrangementRule {
                                                                 description: "outputs::no_shadow::DeclarationVisibleWithin[(outputs::no_shadow::DeclarationVisibleWithin{.file=file, .scope=scope, .declaration=declaration}: outputs::no_shadow::DeclarationVisibleWithin)] :- __Prefix_5[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(_: internment::Intern<string>), .scope=(decl_scope: var_decls::DeclarationScope), .declared_in=(declaration: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=(_: bool), .implicitly_declared=false, .declaration_span=(_: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], (not (ast::is_global(declaration))), ((var scope: ast::ScopeId) = if (config::no_shadow_hoisting(config)) {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (var_decls::hoisted_scope(decl_scope))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            } else {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  (var_decls::unhoisted_scope(decl_scope))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              }).".to_string(),
                                                                 arr: ( Relations::__Prefix_5 as RelId, 0),
                                                                 xform: XFormArrangement::Join{
                                                                            description: "__Prefix_5[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(_: internment::Intern<string>), .scope=(decl_scope: var_decls::DeclarationScope), .declared_in=(declaration: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=(_: bool), .implicitly_declared=false, .declaration_span=(_: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)]".to_string(),
                                                                            ffun: None,
                                                                            arrangement: (Relations::var_decls_VariableDeclarations as RelId,3),
                                                                            jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                            {
                                                                                let (ref file, ref config) = match *<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue_ref(__v1) {
                                                                                    ::types::ddlog_std::tuple2(ref file, ref config) => ((*file).clone(), (*config).clone()),
                                                                                    _ => return None
                                                                                };
                                                                                let (ref decl_scope, ref declaration) = match *<::types::var_decls::VariableDeclarations>::from_ddvalue_ref(__v2) {
                                                                                    ::types::var_decls::VariableDeclarations{file: _, name: _, scope: ref decl_scope, declared_in: ref declaration, meta: ref _0_} => match ((*_0_)).deref() {
                                                                                                                                                                                                                          ::types::var_decls::VariableMeta{is_function_argument: _, implicitly_declared: _, declaration_span: _} => ((*decl_scope).clone(), (*declaration).clone()),
                                                                                                                                                                                                                          _ => return None
                                                                                                                                                                                                                      },
                                                                                    _ => return None
                                                                                };
                                                                                if !(!::types::ast::is_global(declaration)) {return None;};
                                                                                let ref scope: ::types::ast::ScopeId = match if ::types::config::no_shadow_hoisting(config) {
                                                                                                                                 ::types::var_decls::hoisted_scope(decl_scope)
                                                                                                                             } else {
                                                                                                                                 ::types::var_decls::unhoisted_scope(decl_scope)
                                                                                                                             } {
                                                                                    scope => scope,
                                                                                    _ => return None
                                                                                };
                                                                                Some(((::types::outputs::no_shadow::DeclarationVisibleWithin{file: (*file).clone(), scope: (*scope).clone(), declaration: (*declaration).clone()})).into_ddvalue())
                                                                            }
                                                                            __f},
                                                                            next: Box::new(None)
                                                                        }
                                                             },
                                                             /* outputs::no_shadow::DeclarationVisibleWithin[(outputs::no_shadow::DeclarationVisibleWithin{.file=file, .scope=child, .declaration=declaration}: outputs::no_shadow::DeclarationVisibleWithin)] :- outputs::no_shadow::DeclarationVisibleWithin[(outputs::no_shadow::DeclarationVisibleWithin{.file=(file: ast::FileId), .scope=(scope: ast::ScopeId), .declaration=(declaration: ast::AnyId)}: outputs::no_shadow::DeclarationVisibleWithin)], inputs::InputScope[(inputs::InputScope{.parent=(scope: ast::ScopeId), .child=(child: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)]. */
                                                             Rule::ArrangementRule {
                                                                 description: "outputs::no_shadow::DeclarationVisibleWithin[(outputs::no_shadow::DeclarationVisibleWithin{.file=file, .scope=child, .declaration=declaration}: outputs::no_shadow::DeclarationVisibleWithin)] :- outputs::no_shadow::DeclarationVisibleWithin[(outputs::no_shadow::DeclarationVisibleWithin{.file=(file: ast::FileId), .scope=(scope: ast::ScopeId), .declaration=(declaration: ast::AnyId)}: outputs::no_shadow::DeclarationVisibleWithin)], inputs::InputScope[(inputs::InputScope{.parent=(scope: ast::ScopeId), .child=(child: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)].".to_string(),
                                                                 arr: ( Relations::outputs_no_shadow_DeclarationVisibleWithin as RelId, 0),
                                                                 xform: XFormArrangement::Join{
                                                                            description: "outputs::no_shadow::DeclarationVisibleWithin[(outputs::no_shadow::DeclarationVisibleWithin{.file=(file: ast::FileId), .scope=(scope: ast::ScopeId), .declaration=(declaration: ast::AnyId)}: outputs::no_shadow::DeclarationVisibleWithin)], inputs::InputScope[(inputs::InputScope{.parent=(scope: ast::ScopeId), .child=(child: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)]".to_string(),
                                                                            ffun: None,
                                                                            arrangement: (Relations::inputs_InputScope as RelId,1),
                                                                            jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                            {
                                                                                let (ref file, ref scope, ref declaration) = match *<::types::outputs::no_shadow::DeclarationVisibleWithin>::from_ddvalue_ref(__v1) {
                                                                                    ::types::outputs::no_shadow::DeclarationVisibleWithin{file: ref file, scope: ref scope, declaration: ref declaration} => ((*file).clone(), (*scope).clone(), (*declaration).clone()),
                                                                                    _ => return None
                                                                                };
                                                                                let ref child = match *<::types::inputs::InputScope>::from_ddvalue_ref(__v2) {
                                                                                    ::types::inputs::InputScope{parent: _, child: ref child, file: _} => (*child).clone(),
                                                                                    _ => return None
                                                                                };
                                                                                Some(((::types::outputs::no_shadow::DeclarationVisibleWithin{file: (*file).clone(), scope: (*child).clone(), declaration: (*declaration).clone()})).into_ddvalue())
                                                                            }
                                                                            __f},
                                                                            next: Box::new(None)
                                                                        }
                                                             }],
                                                         arrangements: vec![
                                                             Arrangement::Map{
                                                                name: r###"(outputs::no_shadow::DeclarationVisibleWithin{.file=(_1: ast::FileId), .scope=(_0: ast::ScopeId), .declaration=(_: ast::AnyId)}: outputs::no_shadow::DeclarationVisibleWithin) /*join*/"###.to_string(),
                                                                 afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                 {
                                                                     let __cloned = __v.clone();
                                                                     match < ::types::outputs::no_shadow::DeclarationVisibleWithin>::from_ddvalue(__v) {
                                                                         ::types::outputs::no_shadow::DeclarationVisibleWithin{file: ref _1, scope: ref _0, declaration: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                                         _ => None
                                                                     }.map(|x|(x,__cloned))
                                                                 }
                                                                 __f},
                                                                 queryable: false
                                                             },
                                                             Arrangement::Map{
                                                                name: r###"(outputs::no_shadow::DeclarationVisibleWithin{.file=(_0: ast::FileId), .scope=(_1: ast::ScopeId), .declaration=(_: ast::AnyId)}: outputs::no_shadow::DeclarationVisibleWithin) /*join*/"###.to_string(),
                                                                 afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                 {
                                                                     let __cloned = __v.clone();
                                                                     match < ::types::outputs::no_shadow::DeclarationVisibleWithin>::from_ddvalue(__v) {
                                                                         ::types::outputs::no_shadow::DeclarationVisibleWithin{file: ref _0, scope: ref _1, declaration: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                                         _ => None
                                                                     }.map(|x|(x,__cloned))
                                                                 }
                                                                 __f},
                                                                 queryable: false
                                                             }],
                                                         change_cb:    None
                                                     };
    let outputs_no_shadow_NoShadow = Relation {
                                         name:         "outputs::no_shadow::NoShadow".to_string(),
                                         input:        false,
                                         distinct:     true,
                                         caching_mode: CachingMode::Set,
                                         key_func:     None,
                                         id:           Relations::outputs_no_shadow_NoShadow as RelId,
                                         rules:        vec![
                                             /* outputs::no_shadow::NoShadow[(outputs::no_shadow::NoShadow{.variable=name, .original=(initial_id, initial_span), .shadower=(shadower_id, shadower_span), .implicit=false, .file=file}: outputs::no_shadow::NoShadow)] :- __Prefix_5[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(initial_id: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=(_: bool), .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(initial_span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], ((var initial_scope: ast::ScopeId) = if (config::no_shadow_hoisting(config)) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   (var_decls::hoisted_scope(scope))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               } else {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (var_decls::unhoisted_scope(scope))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }), outputs::no_shadow::DeclarationVisibleWithin[(outputs::no_shadow::DeclarationVisibleWithin{.file=(file: ast::FileId), .scope=(initial_scope: ast::ScopeId), .declaration=(shadower_id: ast::AnyId)}: outputs::no_shadow::DeclarationVisibleWithin)], (shadower_id != initial_id), var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(shadower_scope: var_decls::DeclarationScope), .declared_in=(shadower_id: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=(_: bool), .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(shadower_span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], if ((var_decls::is_hoistable(shadower_scope)) and (config::no_shadow_hoisting(config))) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (initial_span > shadower_span)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      } else {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (initial_span < shadower_span)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }. */
                                             Rule::ArrangementRule {
                                                 description: "outputs::no_shadow::NoShadow[(outputs::no_shadow::NoShadow{.variable=name, .original=(initial_id, initial_span), .shadower=(shadower_id, shadower_span), .implicit=false, .file=file}: outputs::no_shadow::NoShadow)] :- __Prefix_5[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(initial_id: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=(_: bool), .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(initial_span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], ((var initial_scope: ast::ScopeId) = if (config::no_shadow_hoisting(config)) {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   (var_decls::hoisted_scope(scope))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               } else {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     (var_decls::unhoisted_scope(scope))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }), outputs::no_shadow::DeclarationVisibleWithin[(outputs::no_shadow::DeclarationVisibleWithin{.file=(file: ast::FileId), .scope=(initial_scope: ast::ScopeId), .declaration=(shadower_id: ast::AnyId)}: outputs::no_shadow::DeclarationVisibleWithin)], (shadower_id != initial_id), var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(shadower_scope: var_decls::DeclarationScope), .declared_in=(shadower_id: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=(_: bool), .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(shadower_span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], if ((var_decls::is_hoistable(shadower_scope)) and (config::no_shadow_hoisting(config))) {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (initial_span > shadower_span)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      } else {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (initial_span < shadower_span)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }.".to_string(),
                                                 arr: ( Relations::__Prefix_5 as RelId, 0),
                                                 xform: XFormArrangement::Join{
                                                            description: "__Prefix_5[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(initial_id: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=(_: bool), .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(initial_span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)]".to_string(),
                                                            ffun: None,
                                                            arrangement: (Relations::var_decls_VariableDeclarations as RelId,4),
                                                            jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                            {
                                                                let (ref file, ref config) = match *<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue_ref(__v1) {
                                                                    ::types::ddlog_std::tuple2(ref file, ref config) => ((*file).clone(), (*config).clone()),
                                                                    _ => return None
                                                                };
                                                                let (ref name, ref scope, ref initial_id, ref initial_span) = match *<::types::var_decls::VariableDeclarations>::from_ddvalue_ref(__v2) {
                                                                    ::types::var_decls::VariableDeclarations{file: _, name: ref name, scope: ref scope, declared_in: ref initial_id, meta: ref _0_} => match ((*_0_)).deref() {
                                                                                                                                                                                                           ::types::var_decls::VariableMeta{is_function_argument: _, implicitly_declared: _, declaration_span: ::types::ddlog_std::Option::Some{x: initial_span}} => ((*name).clone(), (*scope).clone(), (*initial_id).clone(), (*initial_span).clone()),
                                                                                                                                                                                                           _ => return None
                                                                                                                                                                                                       },
                                                                    _ => return None
                                                                };
                                                                let ref initial_scope: ::types::ast::ScopeId = match if ::types::config::no_shadow_hoisting(config) {
                                                                                                                         ::types::var_decls::hoisted_scope(scope)
                                                                                                                     } else {
                                                                                                                         ::types::var_decls::unhoisted_scope(scope)
                                                                                                                     } {
                                                                    initial_scope => initial_scope,
                                                                    _ => return None
                                                                };
                                                                Some((::types::ddlog_std::tuple6((*file).clone(), (*config).clone(), (*name).clone(), (*initial_id).clone(), (*initial_span).clone(), (*initial_scope).clone())).into_ddvalue())
                                                            }
                                                            __f},
                                                            next: Box::new(Some(XFormCollection::Arrange {
                                                                                    description: "arrange __Prefix_5[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(initial_id: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=(_: bool), .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(initial_span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], ((var initial_scope: ast::ScopeId) = if (config::no_shadow_hoisting(config)) {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  (var_decls::hoisted_scope(scope))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              } else {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (var_decls::unhoisted_scope(scope))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }) by (file, initial_scope)" .to_string(),
                                                                                    afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                    {
                                                                                        let ::types::ddlog_std::tuple6(ref file, ref config, ref name, ref initial_id, ref initial_span, ref initial_scope) = *<::types::ddlog_std::tuple6<::types::ast::FileId, ::types::config::Config, ::types::internment::Intern<String>, ::types::ast::AnyId, ::types::ast::Span, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                        Some(((::types::ddlog_std::tuple2((*file).clone(), (*initial_scope).clone())).into_ddvalue(), (::types::ddlog_std::tuple5((*file).clone(), (*config).clone(), (*name).clone(), (*initial_id).clone(), (*initial_span).clone())).into_ddvalue()))
                                                                                    }
                                                                                    __f},
                                                                                    next: Box::new(XFormArrangement::Join{
                                                                                                       description: "__Prefix_5[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(initial_id: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=(_: bool), .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(initial_span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], ((var initial_scope: ast::ScopeId) = if (config::no_shadow_hoisting(config)) {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (var_decls::hoisted_scope(scope))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      } else {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (var_decls::unhoisted_scope(scope))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }), outputs::no_shadow::DeclarationVisibleWithin[(outputs::no_shadow::DeclarationVisibleWithin{.file=(file: ast::FileId), .scope=(initial_scope: ast::ScopeId), .declaration=(shadower_id: ast::AnyId)}: outputs::no_shadow::DeclarationVisibleWithin)]".to_string(),
                                                                                                       ffun: None,
                                                                                                       arrangement: (Relations::outputs_no_shadow_DeclarationVisibleWithin as RelId,1),
                                                                                                       jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                       {
                                                                                                           let ::types::ddlog_std::tuple5(ref file, ref config, ref name, ref initial_id, ref initial_span) = *<::types::ddlog_std::tuple5<::types::ast::FileId, ::types::config::Config, ::types::internment::Intern<String>, ::types::ast::AnyId, ::types::ast::Span>>::from_ddvalue_ref( __v1 );
                                                                                                           let ref shadower_id = match *<::types::outputs::no_shadow::DeclarationVisibleWithin>::from_ddvalue_ref(__v2) {
                                                                                                               ::types::outputs::no_shadow::DeclarationVisibleWithin{file: _, scope: _, declaration: ref shadower_id} => (*shadower_id).clone(),
                                                                                                               _ => return None
                                                                                                           };
                                                                                                           if !((&*shadower_id) != (&*initial_id)) {return None;};
                                                                                                           Some((::types::ddlog_std::tuple6((*file).clone(), (*config).clone(), (*name).clone(), (*initial_id).clone(), (*initial_span).clone(), (*shadower_id).clone())).into_ddvalue())
                                                                                                       }
                                                                                                       __f},
                                                                                                       next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                               description: "arrange __Prefix_5[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(initial_id: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=(_: bool), .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(initial_span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], ((var initial_scope: ast::ScopeId) = if (config::no_shadow_hoisting(config)) {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  (var_decls::hoisted_scope(scope))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              } else {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (var_decls::unhoisted_scope(scope))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }), outputs::no_shadow::DeclarationVisibleWithin[(outputs::no_shadow::DeclarationVisibleWithin{.file=(file: ast::FileId), .scope=(initial_scope: ast::ScopeId), .declaration=(shadower_id: ast::AnyId)}: outputs::no_shadow::DeclarationVisibleWithin)], (shadower_id != initial_id) by (file, name, shadower_id)" .to_string(),
                                                                                                                               afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                               {
                                                                                                                                   let ::types::ddlog_std::tuple6(ref file, ref config, ref name, ref initial_id, ref initial_span, ref shadower_id) = *<::types::ddlog_std::tuple6<::types::ast::FileId, ::types::config::Config, ::types::internment::Intern<String>, ::types::ast::AnyId, ::types::ast::Span, ::types::ast::AnyId>>::from_ddvalue_ref( &__v );
                                                                                                                                   Some(((::types::ddlog_std::tuple3((*file).clone(), (*name).clone(), (*shadower_id).clone())).into_ddvalue(), (::types::ddlog_std::tuple6((*file).clone(), (*config).clone(), (*name).clone(), (*initial_id).clone(), (*initial_span).clone(), (*shadower_id).clone())).into_ddvalue()))
                                                                                                                               }
                                                                                                                               __f},
                                                                                                                               next: Box::new(XFormArrangement::Join{
                                                                                                                                                  description: "__Prefix_5[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(initial_id: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=(_: bool), .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(initial_span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], ((var initial_scope: ast::ScopeId) = if (config::no_shadow_hoisting(config)) {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (var_decls::hoisted_scope(scope))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      } else {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (var_decls::unhoisted_scope(scope))\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }), outputs::no_shadow::DeclarationVisibleWithin[(outputs::no_shadow::DeclarationVisibleWithin{.file=(file: ast::FileId), .scope=(initial_scope: ast::ScopeId), .declaration=(shadower_id: ast::AnyId)}: outputs::no_shadow::DeclarationVisibleWithin)], (shadower_id != initial_id), var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(shadower_scope: var_decls::DeclarationScope), .declared_in=(shadower_id: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=(_: bool), .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(shadower_span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)]".to_string(),
                                                                                                                                                  ffun: None,
                                                                                                                                                  arrangement: (Relations::var_decls_VariableDeclarations as RelId,5),
                                                                                                                                                  jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                  {
                                                                                                                                                      let ::types::ddlog_std::tuple6(ref file, ref config, ref name, ref initial_id, ref initial_span, ref shadower_id) = *<::types::ddlog_std::tuple6<::types::ast::FileId, ::types::config::Config, ::types::internment::Intern<String>, ::types::ast::AnyId, ::types::ast::Span, ::types::ast::AnyId>>::from_ddvalue_ref( __v1 );
                                                                                                                                                      let (ref shadower_scope, ref shadower_span) = match *<::types::var_decls::VariableDeclarations>::from_ddvalue_ref(__v2) {
                                                                                                                                                          ::types::var_decls::VariableDeclarations{file: _, name: _, scope: ref shadower_scope, declared_in: _, meta: ref _0_} => match ((*_0_)).deref() {
                                                                                                                                                                                                                                                                                      ::types::var_decls::VariableMeta{is_function_argument: _, implicitly_declared: _, declaration_span: ::types::ddlog_std::Option::Some{x: shadower_span}} => ((*shadower_scope).clone(), (*shadower_span).clone()),
                                                                                                                                                                                                                                                                                      _ => return None
                                                                                                                                                                                                                                                                                  },
                                                                                                                                                          _ => return None
                                                                                                                                                      };
                                                                                                                                                      if !if (::types::var_decls::is_hoistable(shadower_scope) && ::types::config::no_shadow_hoisting(config)) {
                                                                                                                                                              ((&*initial_span) > (&*shadower_span))
                                                                                                                                                          } else {
                                                                                                                                                              ((&*initial_span) < (&*shadower_span))
                                                                                                                                                          } {return None;};
                                                                                                                                                      Some(((::types::outputs::no_shadow::NoShadow{variable: (*name).clone(), original: ::types::ddlog_std::tuple2((*initial_id).clone(), (*initial_span).clone()), shadower: ::types::ddlog_std::tuple2((*shadower_id).clone(), (*shadower_span).clone()), implicit: false, file: (*file).clone()})).into_ddvalue())
                                                                                                                                                  }
                                                                                                                                                  __f},
                                                                                                                                                  next: Box::new(None)
                                                                                                                                              })
                                                                                                                           }))
                                                                                                   })
                                                                                }))
                                                        }
                                             }],
                                         arrangements: vec![
                                             ],
                                         change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
                                     };
    let name_in_scope_NameInScope = Relation {
                                        name:         "name_in_scope::NameInScope".to_string(),
                                        input:        false,
                                        distinct:     false,
                                        caching_mode: CachingMode::Set,
                                        key_func:     None,
                                        id:           Relations::name_in_scope_NameInScope as RelId,
                                        rules:        vec![
                                            /* name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=file, .name=name, .scope=variable_scope, .declared=declared}: name_in_scope::NameInScope)] :- var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], ((var variable_scope: ast::ScopeId) = (var_decls::hoisted_scope(scope))), name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=(name: internment::Intern<string>), .scope=(variable_scope: ast::ScopeId), .file=(file: ast::FileId)}: name_in_scope::NameOccursInScope)]. */
                                            Rule::CollectionRule {
                                                description: "name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=file, .name=name, .scope=variable_scope, .declared=declared}: name_in_scope::NameInScope)] :- var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], ((var variable_scope: ast::ScopeId) = (var_decls::hoisted_scope(scope))), name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=(name: internment::Intern<string>), .scope=(variable_scope: ast::ScopeId), .file=(file: ast::FileId)}: name_in_scope::NameOccursInScope)].".to_string(),
                                                rel: Relations::var_decls_VariableDeclarations as RelId,
                                                xform: Some(XFormCollection::Arrange {
                                                                description: "arrange var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)] by (name, variable_scope, file)" .to_string(),
                                                                afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                {
                                                                    let (ref file, ref name, ref scope, ref declared) = match *<::types::var_decls::VariableDeclarations>::from_ddvalue_ref(&__v) {
                                                                        ::types::var_decls::VariableDeclarations{file: ref file, name: ref name, scope: ref scope, declared_in: ref declared, meta: _} => ((*file).clone(), (*name).clone(), (*scope).clone(), (*declared).clone()),
                                                                        _ => return None
                                                                    };
                                                                    let ref variable_scope: ::types::ast::ScopeId = match ::types::var_decls::hoisted_scope(scope) {
                                                                        variable_scope => variable_scope,
                                                                        _ => return None
                                                                    };
                                                                    Some(((::types::ddlog_std::tuple3((*name).clone(), (*variable_scope).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple4((*file).clone(), (*name).clone(), (*declared).clone(), (*variable_scope).clone())).into_ddvalue()))
                                                                }
                                                                __f},
                                                                next: Box::new(XFormArrangement::Semijoin{
                                                                                   description: "var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], ((var variable_scope: ast::ScopeId) = (var_decls::hoisted_scope(scope))), name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=(name: internment::Intern<string>), .scope=(variable_scope: ast::ScopeId), .file=(file: ast::FileId)}: name_in_scope::NameOccursInScope)]".to_string(),
                                                                                   ffun: None,
                                                                                   arrangement: (Relations::name_in_scope_NameOccursInScope as RelId,0),
                                                                                   jfun: {fn __f(_: &DDValue ,__v1: &DDValue,___v2: &()) -> Option<DDValue>
                                                                                   {
                                                                                       let ::types::ddlog_std::tuple4(ref file, ref name, ref declared, ref variable_scope) = *<::types::ddlog_std::tuple4<::types::ast::FileId, ::types::internment::Intern<String>, ::types::ast::AnyId, ::types::ast::ScopeId>>::from_ddvalue_ref( __v1 );
                                                                                       Some(((::types::name_in_scope::NameInScope{file: (*file).clone(), name: (*name).clone(), scope: (*variable_scope).clone(), declared: (*declared).clone()})).into_ddvalue())
                                                                                   }
                                                                                   __f},
                                                                                   next: Box::new(None)
                                                                               })
                                                            })
                                            },
                                            /* name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=file, .name=name, .scope=to, .declared=declared}: name_in_scope::NameInScope)] :- name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=(name: internment::Intern<string>), .scope=(to: ast::ScopeId), .file=(file: ast::FileId)}: name_in_scope::NameOccursInScope)], not var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::Unhoistable{.scope=(to: ast::ScopeId)}: var_decls::DeclarationScope), .declared_in=(_: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], inputs::InputScope[(inputs::InputScope{.parent=(from: ast::ScopeId), .child=(to: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(from: ast::ScopeId), .declared=(declared: ast::AnyId)}: name_in_scope::NameInScope)]. */
                                            Rule::ArrangementRule {
                                                description: "name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=file, .name=name, .scope=to, .declared=declared}: name_in_scope::NameInScope)] :- name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=(name: internment::Intern<string>), .scope=(to: ast::ScopeId), .file=(file: ast::FileId)}: name_in_scope::NameOccursInScope)], not var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::Unhoistable{.scope=(to: ast::ScopeId)}: var_decls::DeclarationScope), .declared_in=(_: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], inputs::InputScope[(inputs::InputScope{.parent=(from: ast::ScopeId), .child=(to: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(from: ast::ScopeId), .declared=(declared: ast::AnyId)}: name_in_scope::NameInScope)].".to_string(),
                                                arr: ( Relations::name_in_scope_NameOccursInScope as RelId, 1),
                                                xform: XFormArrangement::Antijoin {
                                                           description: "name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=(name: internment::Intern<string>), .scope=(to: ast::ScopeId), .file=(file: ast::FileId)}: name_in_scope::NameOccursInScope)], not var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::Unhoistable{.scope=(to: ast::ScopeId)}: var_decls::DeclarationScope), .declared_in=(_: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)]".to_string(),
                                                           ffun: None,
                                                           arrangement: (Relations::var_decls_VariableDeclarations as RelId,1),
                                                           next: Box::new(Some(XFormCollection::Arrange {
                                                                                   description: "arrange name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=(name: internment::Intern<string>), .scope=(to: ast::ScopeId), .file=(file: ast::FileId)}: name_in_scope::NameOccursInScope)], not var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::Unhoistable{.scope=(to: ast::ScopeId)}: var_decls::DeclarationScope), .declared_in=(_: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)] by (to, file)" .to_string(),
                                                                                   afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                   {
                                                                                       let (ref name, ref to, ref file) = match *<::types::name_in_scope::NameOccursInScope>::from_ddvalue_ref(&__v) {
                                                                                           ::types::name_in_scope::NameOccursInScope{name: ref name, scope: ref to, file: ref file} => ((*name).clone(), (*to).clone(), (*file).clone()),
                                                                                           _ => return None
                                                                                       };
                                                                                       Some(((::types::ddlog_std::tuple2((*to).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple3((*name).clone(), (*to).clone(), (*file).clone())).into_ddvalue()))
                                                                                   }
                                                                                   __f},
                                                                                   next: Box::new(XFormArrangement::Join{
                                                                                                      description: "name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=(name: internment::Intern<string>), .scope=(to: ast::ScopeId), .file=(file: ast::FileId)}: name_in_scope::NameOccursInScope)], not var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::Unhoistable{.scope=(to: ast::ScopeId)}: var_decls::DeclarationScope), .declared_in=(_: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], inputs::InputScope[(inputs::InputScope{.parent=(from: ast::ScopeId), .child=(to: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)]".to_string(),
                                                                                                      ffun: None,
                                                                                                      arrangement: (Relations::inputs_InputScope as RelId,0),
                                                                                                      jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                      {
                                                                                                          let ::types::ddlog_std::tuple3(ref name, ref to, ref file) = *<::types::ddlog_std::tuple3<::types::internment::Intern<String>, ::types::ast::ScopeId, ::types::ast::FileId>>::from_ddvalue_ref( __v1 );
                                                                                                          let ref from = match *<::types::inputs::InputScope>::from_ddvalue_ref(__v2) {
                                                                                                              ::types::inputs::InputScope{parent: ref from, child: _, file: _} => (*from).clone(),
                                                                                                              _ => return None
                                                                                                          };
                                                                                                          Some((::types::ddlog_std::tuple4((*name).clone(), (*to).clone(), (*file).clone(), (*from).clone())).into_ddvalue())
                                                                                                      }
                                                                                                      __f},
                                                                                                      next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                              description: "arrange name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=(name: internment::Intern<string>), .scope=(to: ast::ScopeId), .file=(file: ast::FileId)}: name_in_scope::NameOccursInScope)], not var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::Unhoistable{.scope=(to: ast::ScopeId)}: var_decls::DeclarationScope), .declared_in=(_: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], inputs::InputScope[(inputs::InputScope{.parent=(from: ast::ScopeId), .child=(to: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)] by (file, name, from)" .to_string(),
                                                                                                                              afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                              {
                                                                                                                                  let ::types::ddlog_std::tuple4(ref name, ref to, ref file, ref from) = *<::types::ddlog_std::tuple4<::types::internment::Intern<String>, ::types::ast::ScopeId, ::types::ast::FileId, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                                                                  Some(((::types::ddlog_std::tuple3((*file).clone(), (*name).clone(), (*from).clone())).into_ddvalue(), (::types::ddlog_std::tuple3((*name).clone(), (*to).clone(), (*file).clone())).into_ddvalue()))
                                                                                                                              }
                                                                                                                              __f},
                                                                                                                              next: Box::new(XFormArrangement::Join{
                                                                                                                                                 description: "name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=(name: internment::Intern<string>), .scope=(to: ast::ScopeId), .file=(file: ast::FileId)}: name_in_scope::NameOccursInScope)], not var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::Unhoistable{.scope=(to: ast::ScopeId)}: var_decls::DeclarationScope), .declared_in=(_: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], inputs::InputScope[(inputs::InputScope{.parent=(from: ast::ScopeId), .child=(to: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(from: ast::ScopeId), .declared=(declared: ast::AnyId)}: name_in_scope::NameInScope)]".to_string(),
                                                                                                                                                 ffun: None,
                                                                                                                                                 arrangement: (Relations::name_in_scope_NameInScope as RelId,0),
                                                                                                                                                 jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                 {
                                                                                                                                                     let ::types::ddlog_std::tuple3(ref name, ref to, ref file) = *<::types::ddlog_std::tuple3<::types::internment::Intern<String>, ::types::ast::ScopeId, ::types::ast::FileId>>::from_ddvalue_ref( __v1 );
                                                                                                                                                     let ref declared = match *<::types::name_in_scope::NameInScope>::from_ddvalue_ref(__v2) {
                                                                                                                                                         ::types::name_in_scope::NameInScope{file: _, name: _, scope: _, declared: ref declared} => (*declared).clone(),
                                                                                                                                                         _ => return None
                                                                                                                                                     };
                                                                                                                                                     Some(((::types::name_in_scope::NameInScope{file: (*file).clone(), name: (*name).clone(), scope: (*to).clone(), declared: (*declared).clone()})).into_ddvalue())
                                                                                                                                                 }
                                                                                                                                                 __f},
                                                                                                                                                 next: Box::new(None)
                                                                                                                                             })
                                                                                                                          }))
                                                                                                  })
                                                                               }))
                                                       }
                                            },
                                            /* name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=file, .name=name, .scope=to, .declared=declared}: name_in_scope::NameInScope)] :- name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=(name: internment::Intern<string>), .scope=(to: ast::ScopeId), .file=(file: ast::FileId)}: name_in_scope::NameOccursInScope)], not var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::Hoistable{.hoisted=(to: ast::ScopeId), .unhoisted=(_: ast::ScopeId)}: var_decls::DeclarationScope), .declared_in=(_: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], inputs::InputScope[(inputs::InputScope{.parent=(from: ast::ScopeId), .child=(to: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(from: ast::ScopeId), .declared=(declared: ast::AnyId)}: name_in_scope::NameInScope)]. */
                                            Rule::ArrangementRule {
                                                description: "name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=file, .name=name, .scope=to, .declared=declared}: name_in_scope::NameInScope)] :- name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=(name: internment::Intern<string>), .scope=(to: ast::ScopeId), .file=(file: ast::FileId)}: name_in_scope::NameOccursInScope)], not var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::Hoistable{.hoisted=(to: ast::ScopeId), .unhoisted=(_: ast::ScopeId)}: var_decls::DeclarationScope), .declared_in=(_: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], inputs::InputScope[(inputs::InputScope{.parent=(from: ast::ScopeId), .child=(to: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(from: ast::ScopeId), .declared=(declared: ast::AnyId)}: name_in_scope::NameInScope)].".to_string(),
                                                arr: ( Relations::name_in_scope_NameOccursInScope as RelId, 1),
                                                xform: XFormArrangement::Antijoin {
                                                           description: "name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=(name: internment::Intern<string>), .scope=(to: ast::ScopeId), .file=(file: ast::FileId)}: name_in_scope::NameOccursInScope)], not var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::Hoistable{.hoisted=(to: ast::ScopeId), .unhoisted=(_: ast::ScopeId)}: var_decls::DeclarationScope), .declared_in=(_: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)]".to_string(),
                                                           ffun: None,
                                                           arrangement: (Relations::var_decls_VariableDeclarations as RelId,2),
                                                           next: Box::new(Some(XFormCollection::Arrange {
                                                                                   description: "arrange name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=(name: internment::Intern<string>), .scope=(to: ast::ScopeId), .file=(file: ast::FileId)}: name_in_scope::NameOccursInScope)], not var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::Hoistable{.hoisted=(to: ast::ScopeId), .unhoisted=(_: ast::ScopeId)}: var_decls::DeclarationScope), .declared_in=(_: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)] by (to, file)" .to_string(),
                                                                                   afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                   {
                                                                                       let (ref name, ref to, ref file) = match *<::types::name_in_scope::NameOccursInScope>::from_ddvalue_ref(&__v) {
                                                                                           ::types::name_in_scope::NameOccursInScope{name: ref name, scope: ref to, file: ref file} => ((*name).clone(), (*to).clone(), (*file).clone()),
                                                                                           _ => return None
                                                                                       };
                                                                                       Some(((::types::ddlog_std::tuple2((*to).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple3((*name).clone(), (*to).clone(), (*file).clone())).into_ddvalue()))
                                                                                   }
                                                                                   __f},
                                                                                   next: Box::new(XFormArrangement::Join{
                                                                                                      description: "name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=(name: internment::Intern<string>), .scope=(to: ast::ScopeId), .file=(file: ast::FileId)}: name_in_scope::NameOccursInScope)], not var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::Hoistable{.hoisted=(to: ast::ScopeId), .unhoisted=(_: ast::ScopeId)}: var_decls::DeclarationScope), .declared_in=(_: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], inputs::InputScope[(inputs::InputScope{.parent=(from: ast::ScopeId), .child=(to: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)]".to_string(),
                                                                                                      ffun: None,
                                                                                                      arrangement: (Relations::inputs_InputScope as RelId,0),
                                                                                                      jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                      {
                                                                                                          let ::types::ddlog_std::tuple3(ref name, ref to, ref file) = *<::types::ddlog_std::tuple3<::types::internment::Intern<String>, ::types::ast::ScopeId, ::types::ast::FileId>>::from_ddvalue_ref( __v1 );
                                                                                                          let ref from = match *<::types::inputs::InputScope>::from_ddvalue_ref(__v2) {
                                                                                                              ::types::inputs::InputScope{parent: ref from, child: _, file: _} => (*from).clone(),
                                                                                                              _ => return None
                                                                                                          };
                                                                                                          Some((::types::ddlog_std::tuple4((*name).clone(), (*to).clone(), (*file).clone(), (*from).clone())).into_ddvalue())
                                                                                                      }
                                                                                                      __f},
                                                                                                      next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                              description: "arrange name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=(name: internment::Intern<string>), .scope=(to: ast::ScopeId), .file=(file: ast::FileId)}: name_in_scope::NameOccursInScope)], not var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::Hoistable{.hoisted=(to: ast::ScopeId), .unhoisted=(_: ast::ScopeId)}: var_decls::DeclarationScope), .declared_in=(_: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], inputs::InputScope[(inputs::InputScope{.parent=(from: ast::ScopeId), .child=(to: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)] by (file, name, from)" .to_string(),
                                                                                                                              afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                              {
                                                                                                                                  let ::types::ddlog_std::tuple4(ref name, ref to, ref file, ref from) = *<::types::ddlog_std::tuple4<::types::internment::Intern<String>, ::types::ast::ScopeId, ::types::ast::FileId, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                                                                  Some(((::types::ddlog_std::tuple3((*file).clone(), (*name).clone(), (*from).clone())).into_ddvalue(), (::types::ddlog_std::tuple3((*name).clone(), (*to).clone(), (*file).clone())).into_ddvalue()))
                                                                                                                              }
                                                                                                                              __f},
                                                                                                                              next: Box::new(XFormArrangement::Join{
                                                                                                                                                 description: "name_in_scope::NameOccursInScope[(name_in_scope::NameOccursInScope{.name=(name: internment::Intern<string>), .scope=(to: ast::ScopeId), .file=(file: ast::FileId)}: name_in_scope::NameOccursInScope)], not var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::Hoistable{.hoisted=(to: ast::ScopeId), .unhoisted=(_: ast::ScopeId)}: var_decls::DeclarationScope), .declared_in=(_: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], inputs::InputScope[(inputs::InputScope{.parent=(from: ast::ScopeId), .child=(to: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(from: ast::ScopeId), .declared=(declared: ast::AnyId)}: name_in_scope::NameInScope)]".to_string(),
                                                                                                                                                 ffun: None,
                                                                                                                                                 arrangement: (Relations::name_in_scope_NameInScope as RelId,0),
                                                                                                                                                 jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                 {
                                                                                                                                                     let ::types::ddlog_std::tuple3(ref name, ref to, ref file) = *<::types::ddlog_std::tuple3<::types::internment::Intern<String>, ::types::ast::ScopeId, ::types::ast::FileId>>::from_ddvalue_ref( __v1 );
                                                                                                                                                     let ref declared = match *<::types::name_in_scope::NameInScope>::from_ddvalue_ref(__v2) {
                                                                                                                                                         ::types::name_in_scope::NameInScope{file: _, name: _, scope: _, declared: ref declared} => (*declared).clone(),
                                                                                                                                                         _ => return None
                                                                                                                                                     };
                                                                                                                                                     Some(((::types::name_in_scope::NameInScope{file: (*file).clone(), name: (*name).clone(), scope: (*to).clone(), declared: (*declared).clone()})).into_ddvalue())
                                                                                                                                                 }
                                                                                                                                                 __f},
                                                                                                                                                 next: Box::new(None)
                                                                                                                                             })
                                                                                                                          }))
                                                                                                  })
                                                                               }))
                                                       }
                                            }],
                                        arrangements: vec![
                                            Arrangement::Map{
                                               name: r###"(name_in_scope::NameInScope{.file=(_0: ast::FileId), .name=(_1: internment::Intern<string>), .scope=(_2: ast::ScopeId), .declared=(_: ast::AnyId)}: name_in_scope::NameInScope) /*join*/"###.to_string(),
                                                afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                {
                                                    let __cloned = __v.clone();
                                                    match < ::types::name_in_scope::NameInScope>::from_ddvalue(__v) {
                                                        ::types::name_in_scope::NameInScope{file: ref _0, name: ref _1, scope: ref _2, declared: _} => Some((::types::ddlog_std::tuple3((*_0).clone(), (*_1).clone(), (*_2).clone())).into_ddvalue()),
                                                        _ => None
                                                    }.map(|x|(x,__cloned))
                                                }
                                                __f},
                                                queryable: false
                                            },
                                            Arrangement::Set{
                                                name: r###"(name_in_scope::NameInScope{.file=(_0: ast::FileId), .name=(_1: internment::Intern<string>), .scope=(_2: ast::ScopeId), .declared=(_: ast::AnyId)}: name_in_scope::NameInScope) /*antijoin*/"###.to_string(),
                                                fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                {
                                                    match < ::types::name_in_scope::NameInScope>::from_ddvalue(__v) {
                                                        ::types::name_in_scope::NameInScope{file: ref _0, name: ref _1, scope: ref _2, declared: _} => Some((::types::ddlog_std::tuple3((*_0).clone(), (*_1).clone(), (*_2).clone())).into_ddvalue()),
                                                        _ => None
                                                    }
                                                }
                                                __f},
                                                distinct: true
                                            },
                                            Arrangement::Set{
                                                name: r###"(name_in_scope::NameInScope{.file=(_0: ast::FileId), .name=(_1: internment::Intern<string>), .scope=_2, .declared=(_3: ast::AnyId)}: name_in_scope::NameInScope) /*antijoin*/"###.to_string(),
                                                fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                {
                                                    match < ::types::name_in_scope::NameInScope>::from_ddvalue(__v) {
                                                        ::types::name_in_scope::NameInScope{file: ref _0, name: ref _1, scope: ref _2, declared: ref _3} => Some((::types::ddlog_std::tuple4((*_0).clone(), (*_1).clone(), (*_2).clone(), (*_3).clone())).into_ddvalue()),
                                                        _ => None
                                                    }
                                                }
                                                __f},
                                                distinct: false
                                            },
                                            Arrangement::Map{
                                               name: r###"(name_in_scope::NameInScope{.file=(_0: ast::FileId), .name=(_1: internment::Intern<string>), .scope=(_2: ast::ScopeId), .declared=(ast::AnyIdStmt{.stmt=(_: ast::StmtId)}: ast::AnyId)}: name_in_scope::NameInScope) /*join*/"###.to_string(),
                                                afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                {
                                                    let __cloned = __v.clone();
                                                    match < ::types::name_in_scope::NameInScope>::from_ddvalue(__v) {
                                                        ::types::name_in_scope::NameInScope{file: ref _0, name: ref _1, scope: ref _2, declared: ::types::ast::AnyId::AnyIdStmt{stmt: _}} => Some((::types::ddlog_std::tuple3((*_0).clone(), (*_1).clone(), (*_2).clone())).into_ddvalue()),
                                                        _ => None
                                                    }.map(|x|(x,__cloned))
                                                }
                                                __f},
                                                queryable: false
                                            },
                                            Arrangement::Map{
                                               name: r###"(name_in_scope::NameInScope{.file=(_0: ast::FileId), .name=(_1: internment::Intern<string>), .scope=(_2: ast::ScopeId), .declared=(ast::AnyIdClass{.class=(_: ast::ClassId)}: ast::AnyId)}: name_in_scope::NameInScope) /*join*/"###.to_string(),
                                                afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                {
                                                    let __cloned = __v.clone();
                                                    match < ::types::name_in_scope::NameInScope>::from_ddvalue(__v) {
                                                        ::types::name_in_scope::NameInScope{file: ref _0, name: ref _1, scope: ref _2, declared: ::types::ast::AnyId::AnyIdClass{class: _}} => Some((::types::ddlog_std::tuple3((*_0).clone(), (*_1).clone(), (*_2).clone())).into_ddvalue()),
                                                        _ => None
                                                    }.map(|x|(x,__cloned))
                                                }
                                                __f},
                                                queryable: false
                                            },
                                            Arrangement::Map{
                                               name: r###"(name_in_scope::NameInScope{.file=(_0: ast::FileId), .name=(_1: internment::Intern<string>), .scope=(_2: ast::ScopeId), .declared=(ast::AnyIdFunc{.func=(_: ast::FuncId)}: ast::AnyId)}: name_in_scope::NameInScope) /*join*/"###.to_string(),
                                                afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                {
                                                    let __cloned = __v.clone();
                                                    match < ::types::name_in_scope::NameInScope>::from_ddvalue(__v) {
                                                        ::types::name_in_scope::NameInScope{file: ref _0, name: ref _1, scope: ref _2, declared: ::types::ast::AnyId::AnyIdFunc{func: _}} => Some((::types::ddlog_std::tuple3((*_0).clone(), (*_1).clone(), (*_2).clone())).into_ddvalue()),
                                                        _ => None
                                                    }.map(|x|(x,__cloned))
                                                }
                                                __f},
                                                queryable: false
                                            },
                                            Arrangement::Map{
                                               name: r###"(name_in_scope::NameInScope{.file=_0, .name=_2, .scope=_1, .declared=(_: ast::AnyId)}: name_in_scope::NameInScope) /*join*/"###.to_string(),
                                                afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                {
                                                    let __cloned = __v.clone();
                                                    match < ::types::name_in_scope::NameInScope>::from_ddvalue(__v) {
                                                        ::types::name_in_scope::NameInScope{file: ref _0, name: ref _2, scope: ref _1, declared: _} => Some((::types::ddlog_std::tuple3((*_0).clone(), (*_1).clone(), (*_2).clone())).into_ddvalue()),
                                                        _ => None
                                                    }.map(|x|(x,__cloned))
                                                }
                                                __f},
                                                queryable: true
                                            },
                                            Arrangement::Map{
                                               name: r###"(name_in_scope::NameInScope{.file=_0, .name=(_: internment::Intern<string>), .scope=_1, .declared=(_: ast::AnyId)}: name_in_scope::NameInScope) /*join*/"###.to_string(),
                                                afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                {
                                                    let __cloned = __v.clone();
                                                    match < ::types::name_in_scope::NameInScope>::from_ddvalue(__v) {
                                                        ::types::name_in_scope::NameInScope{file: ref _0, name: _, scope: ref _1, declared: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                        _ => None
                                                    }.map(|x|(x,__cloned))
                                                }
                                                __f},
                                                queryable: true
                                            }],
                                        change_cb:    None
                                    };
    let outputs_no_undef_NoUndef = Relation {
                                       name:         "outputs::no_undef::NoUndef".to_string(),
                                       input:        false,
                                       distinct:     true,
                                       caching_mode: CachingMode::Set,
                                       key_func:     None,
                                       id:           Relations::outputs_no_undef_NoUndef as RelId,
                                       rules:        vec![
                                           /* outputs::no_undef::NoUndef[(outputs::no_undef::NoUndef{.name=name, .scope=scope, .span=span, .file=file}: outputs::no_undef::NoUndef)] :- __Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(span: ast::Span)}: inputs::Expression)], not outputs::typeof_undef::WithinTypeofExpr[(outputs::typeof_undef::WithinTypeofExpr{.type_of=(_: ast::ExprId), .expr=(expr: ast::ExprId), .file=(file: ast::FileId)}: outputs::typeof_undef::WithinTypeofExpr)], not outputs::no_undef::ChainedWith[(outputs::no_undef::ChainedWith{.object=(_: ast::ExprId), .property=(expr: ast::ExprId), .file=(file: ast::FileId)}: outputs::no_undef::ChainedWith)], not name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: ast::ScopeId), .declared=(_: ast::AnyId)}: name_in_scope::NameInScope)]. */
                                           Rule::ArrangementRule {
                                               description: "outputs::no_undef::NoUndef[(outputs::no_undef::NoUndef{.name=name, .scope=scope, .span=span, .file=file}: outputs::no_undef::NoUndef)] :- __Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(span: ast::Span)}: inputs::Expression)], not outputs::typeof_undef::WithinTypeofExpr[(outputs::typeof_undef::WithinTypeofExpr{.type_of=(_: ast::ExprId), .expr=(expr: ast::ExprId), .file=(file: ast::FileId)}: outputs::typeof_undef::WithinTypeofExpr)], not outputs::no_undef::ChainedWith[(outputs::no_undef::ChainedWith{.object=(_: ast::ExprId), .property=(expr: ast::ExprId), .file=(file: ast::FileId)}: outputs::no_undef::ChainedWith)], not name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: ast::ScopeId), .declared=(_: ast::AnyId)}: name_in_scope::NameInScope)].".to_string(),
                                               arr: ( Relations::__Prefix_6 as RelId, 0),
                                               xform: XFormArrangement::Join{
                                                          description: "__Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)]".to_string(),
                                                          ffun: None,
                                                          arrangement: (Relations::inputs_NameRef as RelId,1),
                                                          jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                          {
                                                              let (ref file, ref config) = match *<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue_ref(__v1) {
                                                                  ::types::ddlog_std::tuple2(ref file, ref config) => ((*file).clone(), (*config).clone()),
                                                                  _ => return None
                                                              };
                                                              let (ref expr, ref name) = match *<::types::inputs::NameRef>::from_ddvalue_ref(__v2) {
                                                                  ::types::inputs::NameRef{expr_id: ref expr, file: _, value: ref name} => ((*expr).clone(), (*name).clone()),
                                                                  _ => return None
                                                              };
                                                              Some((::types::ddlog_std::tuple3((*file).clone(), (*expr).clone(), (*name).clone())).into_ddvalue())
                                                          }
                                                          __f},
                                                          next: Box::new(Some(XFormCollection::Arrange {
                                                                                  description: "arrange __Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)] by (expr, file)" .to_string(),
                                                                                  afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                  {
                                                                                      let ::types::ddlog_std::tuple3(ref file, ref expr, ref name) = *<::types::ddlog_std::tuple3<::types::ast::FileId, ::types::ast::ExprId, ::types::internment::Intern<String>>>::from_ddvalue_ref( &__v );
                                                                                      Some(((::types::ddlog_std::tuple2((*expr).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple3((*file).clone(), (*expr).clone(), (*name).clone())).into_ddvalue()))
                                                                                  }
                                                                                  __f},
                                                                                  next: Box::new(XFormArrangement::Join{
                                                                                                     description: "__Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(span: ast::Span)}: inputs::Expression)]".to_string(),
                                                                                                     ffun: None,
                                                                                                     arrangement: (Relations::inputs_Expression as RelId,1),
                                                                                                     jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                     {
                                                                                                         let ::types::ddlog_std::tuple3(ref file, ref expr, ref name) = *<::types::ddlog_std::tuple3<::types::ast::FileId, ::types::ast::ExprId, ::types::internment::Intern<String>>>::from_ddvalue_ref( __v1 );
                                                                                                         let (ref scope, ref span) = match *<::types::inputs::Expression>::from_ddvalue_ref(__v2) {
                                                                                                             ::types::inputs::Expression{id: _, file: _, kind: ::types::ast::ExprKind::ExprNameRef{}, scope: ref scope, span: ref span} => ((*scope).clone(), (*span).clone()),
                                                                                                             _ => return None
                                                                                                         };
                                                                                                         Some((::types::ddlog_std::tuple5((*file).clone(), (*expr).clone(), (*name).clone(), (*scope).clone(), (*span).clone())).into_ddvalue())
                                                                                                     }
                                                                                                     __f},
                                                                                                     next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                             description: "arrange __Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(span: ast::Span)}: inputs::Expression)] by (expr, file)" .to_string(),
                                                                                                                             afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                             {
                                                                                                                                 let ::types::ddlog_std::tuple5(ref file, ref expr, ref name, ref scope, ref span) = *<::types::ddlog_std::tuple5<::types::ast::FileId, ::types::ast::ExprId, ::types::internment::Intern<String>, ::types::ast::ScopeId, ::types::ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                 Some(((::types::ddlog_std::tuple2((*expr).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple5((*file).clone(), (*expr).clone(), (*name).clone(), (*scope).clone(), (*span).clone())).into_ddvalue()))
                                                                                                                             }
                                                                                                                             __f},
                                                                                                                             next: Box::new(XFormArrangement::Antijoin {
                                                                                                                                                description: "__Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(span: ast::Span)}: inputs::Expression)], not outputs::typeof_undef::WithinTypeofExpr[(outputs::typeof_undef::WithinTypeofExpr{.type_of=(_: ast::ExprId), .expr=(expr: ast::ExprId), .file=(file: ast::FileId)}: outputs::typeof_undef::WithinTypeofExpr)]".to_string(),
                                                                                                                                                ffun: None,
                                                                                                                                                arrangement: (Relations::outputs_typeof_undef_WithinTypeofExpr as RelId,1),
                                                                                                                                                next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                        description: "arrange __Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(span: ast::Span)}: inputs::Expression)], not outputs::typeof_undef::WithinTypeofExpr[(outputs::typeof_undef::WithinTypeofExpr{.type_of=(_: ast::ExprId), .expr=(expr: ast::ExprId), .file=(file: ast::FileId)}: outputs::typeof_undef::WithinTypeofExpr)] by (expr, file)" .to_string(),
                                                                                                                                                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                        {
                                                                                                                                                                            let ::types::ddlog_std::tuple5(ref file, ref expr, ref name, ref scope, ref span) = *<::types::ddlog_std::tuple5<::types::ast::FileId, ::types::ast::ExprId, ::types::internment::Intern<String>, ::types::ast::ScopeId, ::types::ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                                                            Some(((::types::ddlog_std::tuple2((*expr).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple4((*file).clone(), (*name).clone(), (*scope).clone(), (*span).clone())).into_ddvalue()))
                                                                                                                                                                        }
                                                                                                                                                                        __f},
                                                                                                                                                                        next: Box::new(XFormArrangement::Antijoin {
                                                                                                                                                                                           description: "__Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(span: ast::Span)}: inputs::Expression)], not outputs::typeof_undef::WithinTypeofExpr[(outputs::typeof_undef::WithinTypeofExpr{.type_of=(_: ast::ExprId), .expr=(expr: ast::ExprId), .file=(file: ast::FileId)}: outputs::typeof_undef::WithinTypeofExpr)], not outputs::no_undef::ChainedWith[(outputs::no_undef::ChainedWith{.object=(_: ast::ExprId), .property=(expr: ast::ExprId), .file=(file: ast::FileId)}: outputs::no_undef::ChainedWith)]".to_string(),
                                                                                                                                                                                           ffun: None,
                                                                                                                                                                                           arrangement: (Relations::outputs_no_undef_ChainedWith as RelId,2),
                                                                                                                                                                                           next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                                   description: "arrange __Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(span: ast::Span)}: inputs::Expression)], not outputs::typeof_undef::WithinTypeofExpr[(outputs::typeof_undef::WithinTypeofExpr{.type_of=(_: ast::ExprId), .expr=(expr: ast::ExprId), .file=(file: ast::FileId)}: outputs::typeof_undef::WithinTypeofExpr)], not outputs::no_undef::ChainedWith[(outputs::no_undef::ChainedWith{.object=(_: ast::ExprId), .property=(expr: ast::ExprId), .file=(file: ast::FileId)}: outputs::no_undef::ChainedWith)] by (file, name, scope)" .to_string(),
                                                                                                                                                                                                                   afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                                                                   {
                                                                                                                                                                                                                       let ::types::ddlog_std::tuple4(ref file, ref name, ref scope, ref span) = *<::types::ddlog_std::tuple4<::types::ast::FileId, ::types::internment::Intern<String>, ::types::ast::ScopeId, ::types::ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                                                       Some(((::types::ddlog_std::tuple3((*file).clone(), (*name).clone(), (*scope).clone())).into_ddvalue(), (::types::ddlog_std::tuple4((*file).clone(), (*name).clone(), (*scope).clone(), (*span).clone())).into_ddvalue()))
                                                                                                                                                                                                                   }
                                                                                                                                                                                                                   __f},
                                                                                                                                                                                                                   next: Box::new(XFormArrangement::Antijoin {
                                                                                                                                                                                                                                      description: "__Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(span: ast::Span)}: inputs::Expression)], not outputs::typeof_undef::WithinTypeofExpr[(outputs::typeof_undef::WithinTypeofExpr{.type_of=(_: ast::ExprId), .expr=(expr: ast::ExprId), .file=(file: ast::FileId)}: outputs::typeof_undef::WithinTypeofExpr)], not outputs::no_undef::ChainedWith[(outputs::no_undef::ChainedWith{.object=(_: ast::ExprId), .property=(expr: ast::ExprId), .file=(file: ast::FileId)}: outputs::no_undef::ChainedWith)], not name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: ast::ScopeId), .declared=(_: ast::AnyId)}: name_in_scope::NameInScope)]".to_string(),
                                                                                                                                                                                                                                      ffun: None,
                                                                                                                                                                                                                                      arrangement: (Relations::name_in_scope_NameInScope as RelId,1),
                                                                                                                                                                                                                                      next: Box::new(Some(XFormCollection::FilterMap{
                                                                                                                                                                                                                                                              description: "head of outputs::no_undef::NoUndef[(outputs::no_undef::NoUndef{.name=name, .scope=scope, .span=span, .file=file}: outputs::no_undef::NoUndef)] :- __Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(span: ast::Span)}: inputs::Expression)], not outputs::typeof_undef::WithinTypeofExpr[(outputs::typeof_undef::WithinTypeofExpr{.type_of=(_: ast::ExprId), .expr=(expr: ast::ExprId), .file=(file: ast::FileId)}: outputs::typeof_undef::WithinTypeofExpr)], not outputs::no_undef::ChainedWith[(outputs::no_undef::ChainedWith{.object=(_: ast::ExprId), .property=(expr: ast::ExprId), .file=(file: ast::FileId)}: outputs::no_undef::ChainedWith)], not name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: ast::ScopeId), .declared=(_: ast::AnyId)}: name_in_scope::NameInScope)]." .to_string(),
                                                                                                                                                                                                                                                              fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                                                  let ::types::ddlog_std::tuple4(ref file, ref name, ref scope, ref span) = *<::types::ddlog_std::tuple4<::types::ast::FileId, ::types::internment::Intern<String>, ::types::ast::ScopeId, ::types::ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                                                                                                  Some(((::types::outputs::no_undef::NoUndef{name: (*name).clone(), scope: (*scope).clone(), span: (*span).clone(), file: (*file).clone()})).into_ddvalue())
                                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                                              __f},
                                                                                                                                                                                                                                                              next: Box::new(None)
                                                                                                                                                                                                                                                          }))
                                                                                                                                                                                                                                  })
                                                                                                                                                                                                               }))
                                                                                                                                                                                       })
                                                                                                                                                                    }))
                                                                                                                                            })
                                                                                                                         }))
                                                                                                 })
                                                                              }))
                                                      }
                                           },
                                           /* outputs::no_undef::NoUndef[(outputs::no_undef::NoUndef{.name=name, .scope=scope, .span=span, .file=file}: outputs::no_undef::NoUndef)] :- __Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::Assign[(inputs::Assign{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .lhs=(ddlog_std::Some{.x=(ddlog_std::Left{.l=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Either<internment::Intern<ast::Pattern>,ast::ExprId>)}: ddlog_std::Option<ddlog_std::Either<ast::IPattern,ast::ExprId>>), .rhs=(_: ddlog_std::Option<ast::ExprId>), .op=(_: ddlog_std::Option<ast::AssignOperand>)}: inputs::Assign)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression)], var bound_var = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound_var), not name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: ast::ScopeId), .declared=(_: ast::AnyId)}: name_in_scope::NameInScope)]. */
                                           Rule::ArrangementRule {
                                               description: "outputs::no_undef::NoUndef[(outputs::no_undef::NoUndef{.name=name, .scope=scope, .span=span, .file=file}: outputs::no_undef::NoUndef)] :- __Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::Assign[(inputs::Assign{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .lhs=(ddlog_std::Some{.x=(ddlog_std::Left{.l=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Either<internment::Intern<ast::Pattern>,ast::ExprId>)}: ddlog_std::Option<ddlog_std::Either<ast::IPattern,ast::ExprId>>), .rhs=(_: ddlog_std::Option<ast::ExprId>), .op=(_: ddlog_std::Option<ast::AssignOperand>)}: inputs::Assign)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression)], var bound_var = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound_var), not name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: ast::ScopeId), .declared=(_: ast::AnyId)}: name_in_scope::NameInScope)].".to_string(),
                                               arr: ( Relations::__Prefix_6 as RelId, 0),
                                               xform: XFormArrangement::Join{
                                                          description: "__Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::Assign[(inputs::Assign{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .lhs=(ddlog_std::Some{.x=(ddlog_std::Left{.l=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Either<internment::Intern<ast::Pattern>,ast::ExprId>)}: ddlog_std::Option<ddlog_std::Either<ast::IPattern,ast::ExprId>>), .rhs=(_: ddlog_std::Option<ast::ExprId>), .op=(_: ddlog_std::Option<ast::AssignOperand>)}: inputs::Assign)]".to_string(),
                                                          ffun: None,
                                                          arrangement: (Relations::inputs_Assign as RelId,1),
                                                          jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                          {
                                                              let (ref file, ref config) = match *<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue_ref(__v1) {
                                                                  ::types::ddlog_std::tuple2(ref file, ref config) => ((*file).clone(), (*config).clone()),
                                                                  _ => return None
                                                              };
                                                              let (ref expr, ref pat) = match *<::types::inputs::Assign>::from_ddvalue_ref(__v2) {
                                                                  ::types::inputs::Assign{expr_id: ref expr, file: _, lhs: ::types::ddlog_std::Option::Some{x: ::types::ddlog_std::Either::Left{l: ref pat}}, rhs: _, op: _} => ((*expr).clone(), (*pat).clone()),
                                                                  _ => return None
                                                              };
                                                              Some((::types::ddlog_std::tuple3((*file).clone(), (*expr).clone(), (*pat).clone())).into_ddvalue())
                                                          }
                                                          __f},
                                                          next: Box::new(Some(XFormCollection::Arrange {
                                                                                  description: "arrange __Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::Assign[(inputs::Assign{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .lhs=(ddlog_std::Some{.x=(ddlog_std::Left{.l=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Either<internment::Intern<ast::Pattern>,ast::ExprId>)}: ddlog_std::Option<ddlog_std::Either<ast::IPattern,ast::ExprId>>), .rhs=(_: ddlog_std::Option<ast::ExprId>), .op=(_: ddlog_std::Option<ast::AssignOperand>)}: inputs::Assign)] by (expr, file)" .to_string(),
                                                                                  afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                  {
                                                                                      let ::types::ddlog_std::tuple3(ref file, ref expr, ref pat) = *<::types::ddlog_std::tuple3<::types::ast::FileId, ::types::ast::ExprId, ::types::internment::Intern<::types::ast::Pattern>>>::from_ddvalue_ref( &__v );
                                                                                      Some(((::types::ddlog_std::tuple2((*expr).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple2((*file).clone(), (*pat).clone())).into_ddvalue()))
                                                                                  }
                                                                                  __f},
                                                                                  next: Box::new(XFormArrangement::Join{
                                                                                                     description: "__Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::Assign[(inputs::Assign{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .lhs=(ddlog_std::Some{.x=(ddlog_std::Left{.l=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Either<internment::Intern<ast::Pattern>,ast::ExprId>)}: ddlog_std::Option<ddlog_std::Either<ast::IPattern,ast::ExprId>>), .rhs=(_: ddlog_std::Option<ast::ExprId>), .op=(_: ddlog_std::Option<ast::AssignOperand>)}: inputs::Assign)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression)]".to_string(),
                                                                                                     ffun: None,
                                                                                                     arrangement: (Relations::inputs_Expression as RelId,0),
                                                                                                     jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                     {
                                                                                                         let ::types::ddlog_std::tuple2(ref file, ref pat) = *<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::internment::Intern<::types::ast::Pattern>>>::from_ddvalue_ref( __v1 );
                                                                                                         let ref scope = match *<::types::inputs::Expression>::from_ddvalue_ref(__v2) {
                                                                                                             ::types::inputs::Expression{id: _, file: _, kind: _, scope: ref scope, span: _} => (*scope).clone(),
                                                                                                             _ => return None
                                                                                                         };
                                                                                                         Some((::types::ddlog_std::tuple3((*file).clone(), (*pat).clone(), (*scope).clone())).into_ddvalue())
                                                                                                     }
                                                                                                     __f},
                                                                                                     next: Box::new(Some(XFormCollection::FlatMap{
                                                                                                                             description: "__Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::Assign[(inputs::Assign{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .lhs=(ddlog_std::Some{.x=(ddlog_std::Left{.l=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Either<internment::Intern<ast::Pattern>,ast::ExprId>)}: ddlog_std::Option<ddlog_std::Either<ast::IPattern,ast::ExprId>>), .rhs=(_: ddlog_std::Option<ast::ExprId>), .op=(_: ddlog_std::Option<ast::AssignOperand>)}: inputs::Assign)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression)], var bound_var = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat)))" .to_string(),
                                                                                                                             fmfun: {fn __f(__v: DDValue) -> Option<Box<dyn Iterator<Item=DDValue>>>
                                                                                                                             {
                                                                                                                                 let ::types::ddlog_std::tuple3(ref file, ref pat, ref scope) = *<::types::ddlog_std::tuple3<::types::ast::FileId, ::types::internment::Intern<::types::ast::Pattern>, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                                                                 let __flattened = ::types::ast::bound_vars_internment_Intern__ast_Pattern_ddlog_std_Vec__ast_Spanned__internment_Intern____Stringval(pat);
                                                                                                                                 let file = (*file).clone();
                                                                                                                                 let scope = (*scope).clone();
                                                                                                                                 Some(Box::new(__flattened.into_iter().map(move |bound_var|(::types::ddlog_std::tuple3(bound_var.clone(), file.clone(), scope.clone())).into_ddvalue())))
                                                                                                                             }
                                                                                                                             __f},
                                                                                                                             next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                     description: "arrange __Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::Assign[(inputs::Assign{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .lhs=(ddlog_std::Some{.x=(ddlog_std::Left{.l=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Either<internment::Intern<ast::Pattern>,ast::ExprId>)}: ddlog_std::Option<ddlog_std::Either<ast::IPattern,ast::ExprId>>), .rhs=(_: ddlog_std::Option<ast::ExprId>), .op=(_: ddlog_std::Option<ast::AssignOperand>)}: inputs::Assign)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression)], var bound_var = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat))) by (file, name, scope)" .to_string(),
                                                                                                                                                     afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                     {
                                                                                                                                                         let ::types::ddlog_std::tuple3(ref bound_var, ref file, ref scope) = *<::types::ddlog_std::tuple3<::types::ast::Spanned<::types::internment::Intern<String>>, ::types::ast::FileId, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                                                                                         let (ref name, ref span): (::types::internment::Intern<String>, ::types::ast::Span) = match (*bound_var).clone() {
                                                                                                                                                             ::types::ast::Spanned{data: name, span: span} => (name, span),
                                                                                                                                                             _ => return None
                                                                                                                                                         };
                                                                                                                                                         Some(((::types::ddlog_std::tuple3((*file).clone(), (*name).clone(), (*scope).clone())).into_ddvalue(), (::types::ddlog_std::tuple4((*file).clone(), (*scope).clone(), (*name).clone(), (*span).clone())).into_ddvalue()))
                                                                                                                                                     }
                                                                                                                                                     __f},
                                                                                                                                                     next: Box::new(XFormArrangement::Antijoin {
                                                                                                                                                                        description: "__Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::Assign[(inputs::Assign{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .lhs=(ddlog_std::Some{.x=(ddlog_std::Left{.l=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Either<internment::Intern<ast::Pattern>,ast::ExprId>)}: ddlog_std::Option<ddlog_std::Either<ast::IPattern,ast::ExprId>>), .rhs=(_: ddlog_std::Option<ast::ExprId>), .op=(_: ddlog_std::Option<ast::AssignOperand>)}: inputs::Assign)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression)], var bound_var = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound_var), not name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: ast::ScopeId), .declared=(_: ast::AnyId)}: name_in_scope::NameInScope)]".to_string(),
                                                                                                                                                                        ffun: None,
                                                                                                                                                                        arrangement: (Relations::name_in_scope_NameInScope as RelId,1),
                                                                                                                                                                        next: Box::new(Some(XFormCollection::FilterMap{
                                                                                                                                                                                                description: "head of outputs::no_undef::NoUndef[(outputs::no_undef::NoUndef{.name=name, .scope=scope, .span=span, .file=file}: outputs::no_undef::NoUndef)] :- __Prefix_6[((file: ast::FileId), (config: config::Config))], inputs::Assign[(inputs::Assign{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .lhs=(ddlog_std::Some{.x=(ddlog_std::Left{.l=(pat: internment::Intern<ast::Pattern>)}: ddlog_std::Either<internment::Intern<ast::Pattern>,ast::ExprId>)}: ddlog_std::Option<ddlog_std::Either<ast::IPattern,ast::ExprId>>), .rhs=(_: ddlog_std::Option<ast::ExprId>), .op=(_: ddlog_std::Option<ast::AssignOperand>)}: inputs::Assign)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(_: ast::Span)}: inputs::Expression)], var bound_var = FlatMap(((ast::bound_vars: function(internment::Intern<ast::Pattern>):ddlog_std::Vec<ast::Spanned<ast::Name>>)(pat))), ((ast::Spanned{.data=(var name: internment::Intern<string>), .span=(var span: ast::Span)}: ast::Spanned<internment::Intern<string>>) = bound_var), not name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: ast::ScopeId), .declared=(_: ast::AnyId)}: name_in_scope::NameInScope)]." .to_string(),
                                                                                                                                                                                                fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                                                                                                                                                {
                                                                                                                                                                                                    let ::types::ddlog_std::tuple4(ref file, ref scope, ref name, ref span) = *<::types::ddlog_std::tuple4<::types::ast::FileId, ::types::ast::ScopeId, ::types::internment::Intern<String>, ::types::ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                                    Some(((::types::outputs::no_undef::NoUndef{name: (*name).clone(), scope: (*scope).clone(), span: (*span).clone(), file: (*file).clone()})).into_ddvalue())
                                                                                                                                                                                                }
                                                                                                                                                                                                __f},
                                                                                                                                                                                                next: Box::new(None)
                                                                                                                                                                                            }))
                                                                                                                                                                    })
                                                                                                                                                 }))
                                                                                                                         }))
                                                                                                 })
                                                                              }))
                                                      }
                                           }],
                                       arrangements: vec![
                                           ],
                                       change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
                                   };
    let outputs_typeof_undef_TypeofUndef = Relation {
                                               name:         "outputs::typeof_undef::TypeofUndef".to_string(),
                                               input:        false,
                                               distinct:     true,
                                               caching_mode: CachingMode::Set,
                                               key_func:     None,
                                               id:           Relations::outputs_typeof_undef_TypeofUndef as RelId,
                                               rules:        vec![
                                                   /* outputs::typeof_undef::TypeofUndef[(outputs::typeof_undef::TypeofUndef{.whole_expr=whole_expr, .undefined_expr=undefined_expr, .file=file}: outputs::typeof_undef::TypeofUndef)] :- __Prefix_9[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(undefined_expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(undefined_expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(span: ast::Span)}: inputs::Expression)], outputs::typeof_undef::WithinTypeofExpr[(outputs::typeof_undef::WithinTypeofExpr{.type_of=(whole_expr: ast::ExprId), .expr=(undefined_expr: ast::ExprId), .file=(file: ast::FileId)}: outputs::typeof_undef::WithinTypeofExpr)], not name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: ast::ScopeId), .declared=(_: ast::AnyId)}: name_in_scope::NameInScope)]. */
                                                   Rule::ArrangementRule {
                                                       description: "outputs::typeof_undef::TypeofUndef[(outputs::typeof_undef::TypeofUndef{.whole_expr=whole_expr, .undefined_expr=undefined_expr, .file=file}: outputs::typeof_undef::TypeofUndef)] :- __Prefix_9[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(undefined_expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(undefined_expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(span: ast::Span)}: inputs::Expression)], outputs::typeof_undef::WithinTypeofExpr[(outputs::typeof_undef::WithinTypeofExpr{.type_of=(whole_expr: ast::ExprId), .expr=(undefined_expr: ast::ExprId), .file=(file: ast::FileId)}: outputs::typeof_undef::WithinTypeofExpr)], not name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: ast::ScopeId), .declared=(_: ast::AnyId)}: name_in_scope::NameInScope)].".to_string(),
                                                       arr: ( Relations::__Prefix_9 as RelId, 0),
                                                       xform: XFormArrangement::Join{
                                                                  description: "__Prefix_9[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(undefined_expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)]".to_string(),
                                                                  ffun: None,
                                                                  arrangement: (Relations::inputs_NameRef as RelId,1),
                                                                  jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                  {
                                                                      let (ref file, ref config) = match *<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue_ref(__v1) {
                                                                          ::types::ddlog_std::tuple2(ref file, ref config) => ((*file).clone(), (*config).clone()),
                                                                          _ => return None
                                                                      };
                                                                      let (ref undefined_expr, ref name) = match *<::types::inputs::NameRef>::from_ddvalue_ref(__v2) {
                                                                          ::types::inputs::NameRef{expr_id: ref undefined_expr, file: _, value: ref name} => ((*undefined_expr).clone(), (*name).clone()),
                                                                          _ => return None
                                                                      };
                                                                      Some((::types::ddlog_std::tuple3((*file).clone(), (*undefined_expr).clone(), (*name).clone())).into_ddvalue())
                                                                  }
                                                                  __f},
                                                                  next: Box::new(Some(XFormCollection::Arrange {
                                                                                          description: "arrange __Prefix_9[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(undefined_expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)] by (undefined_expr, file)" .to_string(),
                                                                                          afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                          {
                                                                                              let ::types::ddlog_std::tuple3(ref file, ref undefined_expr, ref name) = *<::types::ddlog_std::tuple3<::types::ast::FileId, ::types::ast::ExprId, ::types::internment::Intern<String>>>::from_ddvalue_ref( &__v );
                                                                                              Some(((::types::ddlog_std::tuple2((*undefined_expr).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple3((*file).clone(), (*undefined_expr).clone(), (*name).clone())).into_ddvalue()))
                                                                                          }
                                                                                          __f},
                                                                                          next: Box::new(XFormArrangement::Join{
                                                                                                             description: "__Prefix_9[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(undefined_expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(undefined_expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(span: ast::Span)}: inputs::Expression)]".to_string(),
                                                                                                             ffun: None,
                                                                                                             arrangement: (Relations::inputs_Expression as RelId,1),
                                                                                                             jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                             {
                                                                                                                 let ::types::ddlog_std::tuple3(ref file, ref undefined_expr, ref name) = *<::types::ddlog_std::tuple3<::types::ast::FileId, ::types::ast::ExprId, ::types::internment::Intern<String>>>::from_ddvalue_ref( __v1 );
                                                                                                                 let (ref scope, ref span) = match *<::types::inputs::Expression>::from_ddvalue_ref(__v2) {
                                                                                                                     ::types::inputs::Expression{id: _, file: _, kind: ::types::ast::ExprKind::ExprNameRef{}, scope: ref scope, span: ref span} => ((*scope).clone(), (*span).clone()),
                                                                                                                     _ => return None
                                                                                                                 };
                                                                                                                 Some((::types::ddlog_std::tuple4((*file).clone(), (*undefined_expr).clone(), (*name).clone(), (*scope).clone())).into_ddvalue())
                                                                                                             }
                                                                                                             __f},
                                                                                                             next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                     description: "arrange __Prefix_9[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(undefined_expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(undefined_expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(span: ast::Span)}: inputs::Expression)] by (undefined_expr, file)" .to_string(),
                                                                                                                                     afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                     {
                                                                                                                                         let ::types::ddlog_std::tuple4(ref file, ref undefined_expr, ref name, ref scope) = *<::types::ddlog_std::tuple4<::types::ast::FileId, ::types::ast::ExprId, ::types::internment::Intern<String>, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                                                                         Some(((::types::ddlog_std::tuple2((*undefined_expr).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple4((*file).clone(), (*undefined_expr).clone(), (*name).clone(), (*scope).clone())).into_ddvalue()))
                                                                                                                                     }
                                                                                                                                     __f},
                                                                                                                                     next: Box::new(XFormArrangement::Join{
                                                                                                                                                        description: "__Prefix_9[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(undefined_expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(undefined_expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(span: ast::Span)}: inputs::Expression)], outputs::typeof_undef::WithinTypeofExpr[(outputs::typeof_undef::WithinTypeofExpr{.type_of=(whole_expr: ast::ExprId), .expr=(undefined_expr: ast::ExprId), .file=(file: ast::FileId)}: outputs::typeof_undef::WithinTypeofExpr)]".to_string(),
                                                                                                                                                        ffun: None,
                                                                                                                                                        arrangement: (Relations::outputs_typeof_undef_WithinTypeofExpr as RelId,2),
                                                                                                                                                        jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                        {
                                                                                                                                                            let ::types::ddlog_std::tuple4(ref file, ref undefined_expr, ref name, ref scope) = *<::types::ddlog_std::tuple4<::types::ast::FileId, ::types::ast::ExprId, ::types::internment::Intern<String>, ::types::ast::ScopeId>>::from_ddvalue_ref( __v1 );
                                                                                                                                                            let ref whole_expr = match *<::types::outputs::typeof_undef::WithinTypeofExpr>::from_ddvalue_ref(__v2) {
                                                                                                                                                                ::types::outputs::typeof_undef::WithinTypeofExpr{type_of: ref whole_expr, expr: _, file: _} => (*whole_expr).clone(),
                                                                                                                                                                _ => return None
                                                                                                                                                            };
                                                                                                                                                            Some((::types::ddlog_std::tuple5((*file).clone(), (*undefined_expr).clone(), (*name).clone(), (*scope).clone(), (*whole_expr).clone())).into_ddvalue())
                                                                                                                                                        }
                                                                                                                                                        __f},
                                                                                                                                                        next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                description: "arrange __Prefix_9[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(undefined_expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(undefined_expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(span: ast::Span)}: inputs::Expression)], outputs::typeof_undef::WithinTypeofExpr[(outputs::typeof_undef::WithinTypeofExpr{.type_of=(whole_expr: ast::ExprId), .expr=(undefined_expr: ast::ExprId), .file=(file: ast::FileId)}: outputs::typeof_undef::WithinTypeofExpr)] by (file, name, scope)" .to_string(),
                                                                                                                                                                                afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                                {
                                                                                                                                                                                    let ::types::ddlog_std::tuple5(ref file, ref undefined_expr, ref name, ref scope, ref whole_expr) = *<::types::ddlog_std::tuple5<::types::ast::FileId, ::types::ast::ExprId, ::types::internment::Intern<String>, ::types::ast::ScopeId, ::types::ast::ExprId>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                    Some(((::types::ddlog_std::tuple3((*file).clone(), (*name).clone(), (*scope).clone())).into_ddvalue(), (::types::ddlog_std::tuple3((*file).clone(), (*undefined_expr).clone(), (*whole_expr).clone())).into_ddvalue()))
                                                                                                                                                                                }
                                                                                                                                                                                __f},
                                                                                                                                                                                next: Box::new(XFormArrangement::Antijoin {
                                                                                                                                                                                                   description: "__Prefix_9[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(undefined_expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(undefined_expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(span: ast::Span)}: inputs::Expression)], outputs::typeof_undef::WithinTypeofExpr[(outputs::typeof_undef::WithinTypeofExpr{.type_of=(whole_expr: ast::ExprId), .expr=(undefined_expr: ast::ExprId), .file=(file: ast::FileId)}: outputs::typeof_undef::WithinTypeofExpr)], not name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: ast::ScopeId), .declared=(_: ast::AnyId)}: name_in_scope::NameInScope)]".to_string(),
                                                                                                                                                                                                   ffun: None,
                                                                                                                                                                                                   arrangement: (Relations::name_in_scope_NameInScope as RelId,1),
                                                                                                                                                                                                   next: Box::new(Some(XFormCollection::FilterMap{
                                                                                                                                                                                                                           description: "head of outputs::typeof_undef::TypeofUndef[(outputs::typeof_undef::TypeofUndef{.whole_expr=whole_expr, .undefined_expr=undefined_expr, .file=file}: outputs::typeof_undef::TypeofUndef)] :- __Prefix_9[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(undefined_expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(undefined_expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(scope: ast::ScopeId), .span=(span: ast::Span)}: inputs::Expression)], outputs::typeof_undef::WithinTypeofExpr[(outputs::typeof_undef::WithinTypeofExpr{.type_of=(whole_expr: ast::ExprId), .expr=(undefined_expr: ast::ExprId), .file=(file: ast::FileId)}: outputs::typeof_undef::WithinTypeofExpr)], not name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: ast::ScopeId), .declared=(_: ast::AnyId)}: name_in_scope::NameInScope)]." .to_string(),
                                                                                                                                                                                                                           fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                                                                                                                                                                           {
                                                                                                                                                                                                                               let ::types::ddlog_std::tuple3(ref file, ref undefined_expr, ref whole_expr) = *<::types::ddlog_std::tuple3<::types::ast::FileId, ::types::ast::ExprId, ::types::ast::ExprId>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                                                               Some(((::types::outputs::typeof_undef::TypeofUndef{whole_expr: (*whole_expr).clone(), undefined_expr: (*undefined_expr).clone(), file: (*file).clone()})).into_ddvalue())
                                                                                                                                                                                                                           }
                                                                                                                                                                                                                           __f},
                                                                                                                                                                                                                           next: Box::new(None)
                                                                                                                                                                                                                       }))
                                                                                                                                                                                               })
                                                                                                                                                                            }))
                                                                                                                                                    })
                                                                                                                                 }))
                                                                                                         })
                                                                                      }))
                                                              }
                                                   }],
                                               arrangements: vec![
                                                   ],
                                               change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
                                           };
    let is_exported_IsExported = Relation {
                                     name:         "is_exported::IsExported".to_string(),
                                     input:        false,
                                     distinct:     false,
                                     caching_mode: CachingMode::Set,
                                     key_func:     None,
                                     id:           Relations::is_exported_IsExported as RelId,
                                     rules:        vec![
                                         /* is_exported::IsExported[(is_exported::IsExported{.file=file, .id=(ast::AnyIdFunc{.func=id}: ast::AnyId)}: is_exported::IsExported)] :- inputs::Function[(inputs::Function{.id=(id: ast::FuncId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(_: ast::ScopeId), .body=(_: ast::ScopeId), .exported=true}: inputs::Function)]. */
                                         Rule::CollectionRule {
                                             description: "is_exported::IsExported[(is_exported::IsExported{.file=file, .id=(ast::AnyIdFunc{.func=id}: ast::AnyId)}: is_exported::IsExported)] :- inputs::Function[(inputs::Function{.id=(id: ast::FuncId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(_: ast::ScopeId), .body=(_: ast::ScopeId), .exported=true}: inputs::Function)].".to_string(),
                                             rel: Relations::inputs_Function as RelId,
                                             xform: Some(XFormCollection::FilterMap{
                                                             description: "head of is_exported::IsExported[(is_exported::IsExported{.file=file, .id=(ast::AnyIdFunc{.func=id}: ast::AnyId)}: is_exported::IsExported)] :- inputs::Function[(inputs::Function{.id=(id: ast::FuncId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(_: ast::ScopeId), .body=(_: ast::ScopeId), .exported=true}: inputs::Function)]." .to_string(),
                                                             fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                             {
                                                                 let (ref id, ref file) = match *<::types::inputs::Function>::from_ddvalue_ref(&__v) {
                                                                     ::types::inputs::Function{id: ref id, file: ref file, name: _, scope: _, body: _, exported: true} => ((*id).clone(), (*file).clone()),
                                                                     _ => return None
                                                                 };
                                                                 Some(((::types::is_exported::IsExported{file: (*file).clone(), id: (::types::ast::AnyId::AnyIdFunc{func: (*id).clone()})})).into_ddvalue())
                                                             }
                                                             __f},
                                                             next: Box::new(None)
                                                         })
                                         },
                                         /* is_exported::IsExported[(is_exported::IsExported{.file=file, .id=(ast::AnyIdClass{.class=id}: ast::AnyId)}: is_exported::IsExported)] :- inputs::Class[(inputs::Class{.id=(id: ast::ClassId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(_: ast::ScopeId), .exported=true}: inputs::Class)]. */
                                         Rule::CollectionRule {
                                             description: "is_exported::IsExported[(is_exported::IsExported{.file=file, .id=(ast::AnyIdClass{.class=id}: ast::AnyId)}: is_exported::IsExported)] :- inputs::Class[(inputs::Class{.id=(id: ast::ClassId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(_: ast::ScopeId), .exported=true}: inputs::Class)].".to_string(),
                                             rel: Relations::inputs_Class as RelId,
                                             xform: Some(XFormCollection::FilterMap{
                                                             description: "head of is_exported::IsExported[(is_exported::IsExported{.file=file, .id=(ast::AnyIdClass{.class=id}: ast::AnyId)}: is_exported::IsExported)] :- inputs::Class[(inputs::Class{.id=(id: ast::ClassId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(_: ast::ScopeId), .exported=true}: inputs::Class)]." .to_string(),
                                                             fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                             {
                                                                 let (ref id, ref file) = match *<::types::inputs::Class>::from_ddvalue_ref(&__v) {
                                                                     ::types::inputs::Class{id: ref id, file: ref file, name: _, parent: _, elements: _, scope: _, exported: true} => ((*id).clone(), (*file).clone()),
                                                                     _ => return None
                                                                 };
                                                                 Some(((::types::is_exported::IsExported{file: (*file).clone(), id: (::types::ast::AnyId::AnyIdClass{class: (*id).clone()})})).into_ddvalue())
                                                             }
                                                             __f},
                                                             next: Box::new(None)
                                                         })
                                         },
                                         /* is_exported::IsExported[(is_exported::IsExported{.file=file, .id=(ast::AnyIdStmt{.stmt=id}: ast::AnyId)}: is_exported::IsExported)] :- inputs::VarDecl[(inputs::VarDecl{.stmt_id=(id: ast::StmtId), .file=(file: ast::FileId), .pattern=(_: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=true}: inputs::VarDecl)]. */
                                         Rule::CollectionRule {
                                             description: "is_exported::IsExported[(is_exported::IsExported{.file=file, .id=(ast::AnyIdStmt{.stmt=id}: ast::AnyId)}: is_exported::IsExported)] :- inputs::VarDecl[(inputs::VarDecl{.stmt_id=(id: ast::StmtId), .file=(file: ast::FileId), .pattern=(_: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=true}: inputs::VarDecl)].".to_string(),
                                             rel: Relations::inputs_VarDecl as RelId,
                                             xform: Some(XFormCollection::FilterMap{
                                                             description: "head of is_exported::IsExported[(is_exported::IsExported{.file=file, .id=(ast::AnyIdStmt{.stmt=id}: ast::AnyId)}: is_exported::IsExported)] :- inputs::VarDecl[(inputs::VarDecl{.stmt_id=(id: ast::StmtId), .file=(file: ast::FileId), .pattern=(_: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=true}: inputs::VarDecl)]." .to_string(),
                                                             fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                             {
                                                                 let (ref id, ref file) = match *<::types::inputs::VarDecl>::from_ddvalue_ref(&__v) {
                                                                     ::types::inputs::VarDecl{stmt_id: ref id, file: ref file, pattern: _, value: _, exported: true} => ((*id).clone(), (*file).clone()),
                                                                     _ => return None
                                                                 };
                                                                 Some(((::types::is_exported::IsExported{file: (*file).clone(), id: (::types::ast::AnyId::AnyIdStmt{stmt: (*id).clone()})})).into_ddvalue())
                                                             }
                                                             __f},
                                                             next: Box::new(None)
                                                         })
                                         },
                                         /* is_exported::IsExported[(is_exported::IsExported{.file=file, .id=(ast::AnyIdStmt{.stmt=id}: ast::AnyId)}: is_exported::IsExported)] :- inputs::LetDecl[(inputs::LetDecl{.stmt_id=(id: ast::StmtId), .file=(file: ast::FileId), .pattern=(_: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=true}: inputs::LetDecl)]. */
                                         Rule::CollectionRule {
                                             description: "is_exported::IsExported[(is_exported::IsExported{.file=file, .id=(ast::AnyIdStmt{.stmt=id}: ast::AnyId)}: is_exported::IsExported)] :- inputs::LetDecl[(inputs::LetDecl{.stmt_id=(id: ast::StmtId), .file=(file: ast::FileId), .pattern=(_: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=true}: inputs::LetDecl)].".to_string(),
                                             rel: Relations::inputs_LetDecl as RelId,
                                             xform: Some(XFormCollection::FilterMap{
                                                             description: "head of is_exported::IsExported[(is_exported::IsExported{.file=file, .id=(ast::AnyIdStmt{.stmt=id}: ast::AnyId)}: is_exported::IsExported)] :- inputs::LetDecl[(inputs::LetDecl{.stmt_id=(id: ast::StmtId), .file=(file: ast::FileId), .pattern=(_: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=true}: inputs::LetDecl)]." .to_string(),
                                                             fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                             {
                                                                 let (ref id, ref file) = match *<::types::inputs::LetDecl>::from_ddvalue_ref(&__v) {
                                                                     ::types::inputs::LetDecl{stmt_id: ref id, file: ref file, pattern: _, value: _, exported: true} => ((*id).clone(), (*file).clone()),
                                                                     _ => return None
                                                                 };
                                                                 Some(((::types::is_exported::IsExported{file: (*file).clone(), id: (::types::ast::AnyId::AnyIdStmt{stmt: (*id).clone()})})).into_ddvalue())
                                                             }
                                                             __f},
                                                             next: Box::new(None)
                                                         })
                                         },
                                         /* is_exported::IsExported[(is_exported::IsExported{.file=file, .id=(ast::AnyIdStmt{.stmt=id}: ast::AnyId)}: is_exported::IsExported)] :- inputs::ConstDecl[(inputs::ConstDecl{.stmt_id=(id: ast::StmtId), .file=(file: ast::FileId), .pattern=(_: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=true}: inputs::ConstDecl)]. */
                                         Rule::CollectionRule {
                                             description: "is_exported::IsExported[(is_exported::IsExported{.file=file, .id=(ast::AnyIdStmt{.stmt=id}: ast::AnyId)}: is_exported::IsExported)] :- inputs::ConstDecl[(inputs::ConstDecl{.stmt_id=(id: ast::StmtId), .file=(file: ast::FileId), .pattern=(_: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=true}: inputs::ConstDecl)].".to_string(),
                                             rel: Relations::inputs_ConstDecl as RelId,
                                             xform: Some(XFormCollection::FilterMap{
                                                             description: "head of is_exported::IsExported[(is_exported::IsExported{.file=file, .id=(ast::AnyIdStmt{.stmt=id}: ast::AnyId)}: is_exported::IsExported)] :- inputs::ConstDecl[(inputs::ConstDecl{.stmt_id=(id: ast::StmtId), .file=(file: ast::FileId), .pattern=(_: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=true}: inputs::ConstDecl)]." .to_string(),
                                                             fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                             {
                                                                 let (ref id, ref file) = match *<::types::inputs::ConstDecl>::from_ddvalue_ref(&__v) {
                                                                     ::types::inputs::ConstDecl{stmt_id: ref id, file: ref file, pattern: _, value: _, exported: true} => ((*id).clone(), (*file).clone()),
                                                                     _ => return None
                                                                 };
                                                                 Some(((::types::is_exported::IsExported{file: (*file).clone(), id: (::types::ast::AnyId::AnyIdStmt{stmt: (*id).clone()})})).into_ddvalue())
                                                             }
                                                             __f},
                                                             next: Box::new(None)
                                                         })
                                         },
                                         /* is_exported::IsExported[(is_exported::IsExported{.file=file, .id=id}: is_exported::IsExported)] :- inputs::FileExport[(inputs::FileExport{.file=(file: ast::FileId), .export=(ast::NamedExport{.name=(export_name: ddlog_std::Option<ast::Spanned<ast::Name>>), .alias=(export_alias: ddlog_std::Option<ast::Spanned<ast::Name>>)}: ast::ExportKind), .scope=(export_scope: ast::ScopeId)}: inputs::FileExport)], ((ddlog_std::Some{.x=(ast::Spanned{.data=(var name: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<internment::Intern<string>>>) = ((utils::or_else: function(ddlog_std::Option<ast::Spanned<ast::Name>>, ddlog_std::Option<ast::Spanned<ast::Name>>):ddlog_std::Option<ast::Spanned<internment::Intern<string>>>)(export_alias, export_name))), name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(export_scope: ast::ScopeId), .declared=(id: ast::AnyId)}: name_in_scope::NameInScope)], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(id: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], ((var_decls::hoisted_scope(scope)) == export_scope). */
                                         Rule::CollectionRule {
                                             description: "is_exported::IsExported[(is_exported::IsExported{.file=file, .id=id}: is_exported::IsExported)] :- inputs::FileExport[(inputs::FileExport{.file=(file: ast::FileId), .export=(ast::NamedExport{.name=(export_name: ddlog_std::Option<ast::Spanned<ast::Name>>), .alias=(export_alias: ddlog_std::Option<ast::Spanned<ast::Name>>)}: ast::ExportKind), .scope=(export_scope: ast::ScopeId)}: inputs::FileExport)], ((ddlog_std::Some{.x=(ast::Spanned{.data=(var name: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<internment::Intern<string>>>) = ((utils::or_else: function(ddlog_std::Option<ast::Spanned<ast::Name>>, ddlog_std::Option<ast::Spanned<ast::Name>>):ddlog_std::Option<ast::Spanned<internment::Intern<string>>>)(export_alias, export_name))), name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(export_scope: ast::ScopeId), .declared=(id: ast::AnyId)}: name_in_scope::NameInScope)], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(id: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], ((var_decls::hoisted_scope(scope)) == export_scope).".to_string(),
                                             rel: Relations::inputs_FileExport as RelId,
                                             xform: Some(XFormCollection::Arrange {
                                                             description: "arrange inputs::FileExport[(inputs::FileExport{.file=(file: ast::FileId), .export=(ast::NamedExport{.name=(export_name: ddlog_std::Option<ast::Spanned<ast::Name>>), .alias=(export_alias: ddlog_std::Option<ast::Spanned<ast::Name>>)}: ast::ExportKind), .scope=(export_scope: ast::ScopeId)}: inputs::FileExport)] by (file, name, export_scope)" .to_string(),
                                                             afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                             {
                                                                 let (ref file, ref export_name, ref export_alias, ref export_scope) = match *<::types::inputs::FileExport>::from_ddvalue_ref(&__v) {
                                                                     ::types::inputs::FileExport{file: ref file, export: ::types::ast::ExportKind::NamedExport{name: ref export_name, alias: ref export_alias}, scope: ref export_scope} => ((*file).clone(), (*export_name).clone(), (*export_alias).clone(), (*export_scope).clone()),
                                                                     _ => return None
                                                                 };
                                                                 let ref name: ::types::internment::Intern<String> = match ::types::utils::or_else::<::types::ast::Spanned<::types::ast::Name>>(export_alias, export_name) {
                                                                     ::types::ddlog_std::Option::Some{x: ::types::ast::Spanned{data: name, span: _}} => name,
                                                                     _ => return None
                                                                 };
                                                                 Some(((::types::ddlog_std::tuple3((*file).clone(), (*name).clone(), (*export_scope).clone())).into_ddvalue(), (::types::ddlog_std::tuple3((*file).clone(), (*export_scope).clone(), (*name).clone())).into_ddvalue()))
                                                             }
                                                             __f},
                                                             next: Box::new(XFormArrangement::Join{
                                                                                description: "inputs::FileExport[(inputs::FileExport{.file=(file: ast::FileId), .export=(ast::NamedExport{.name=(export_name: ddlog_std::Option<ast::Spanned<ast::Name>>), .alias=(export_alias: ddlog_std::Option<ast::Spanned<ast::Name>>)}: ast::ExportKind), .scope=(export_scope: ast::ScopeId)}: inputs::FileExport)], ((ddlog_std::Some{.x=(ast::Spanned{.data=(var name: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<internment::Intern<string>>>) = ((utils::or_else: function(ddlog_std::Option<ast::Spanned<ast::Name>>, ddlog_std::Option<ast::Spanned<ast::Name>>):ddlog_std::Option<ast::Spanned<internment::Intern<string>>>)(export_alias, export_name))), name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(export_scope: ast::ScopeId), .declared=(id: ast::AnyId)}: name_in_scope::NameInScope)]".to_string(),
                                                                                ffun: None,
                                                                                arrangement: (Relations::name_in_scope_NameInScope as RelId,0),
                                                                                jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                {
                                                                                    let ::types::ddlog_std::tuple3(ref file, ref export_scope, ref name) = *<::types::ddlog_std::tuple3<::types::ast::FileId, ::types::ast::ScopeId, ::types::internment::Intern<String>>>::from_ddvalue_ref( __v1 );
                                                                                    let ref id = match *<::types::name_in_scope::NameInScope>::from_ddvalue_ref(__v2) {
                                                                                        ::types::name_in_scope::NameInScope{file: _, name: _, scope: _, declared: ref id} => (*id).clone(),
                                                                                        _ => return None
                                                                                    };
                                                                                    Some((::types::ddlog_std::tuple4((*file).clone(), (*export_scope).clone(), (*name).clone(), (*id).clone())).into_ddvalue())
                                                                                }
                                                                                __f},
                                                                                next: Box::new(Some(XFormCollection::Arrange {
                                                                                                        description: "arrange inputs::FileExport[(inputs::FileExport{.file=(file: ast::FileId), .export=(ast::NamedExport{.name=(export_name: ddlog_std::Option<ast::Spanned<ast::Name>>), .alias=(export_alias: ddlog_std::Option<ast::Spanned<ast::Name>>)}: ast::ExportKind), .scope=(export_scope: ast::ScopeId)}: inputs::FileExport)], ((ddlog_std::Some{.x=(ast::Spanned{.data=(var name: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<internment::Intern<string>>>) = ((utils::or_else: function(ddlog_std::Option<ast::Spanned<ast::Name>>, ddlog_std::Option<ast::Spanned<ast::Name>>):ddlog_std::Option<ast::Spanned<internment::Intern<string>>>)(export_alias, export_name))), name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(export_scope: ast::ScopeId), .declared=(id: ast::AnyId)}: name_in_scope::NameInScope)] by (file, name, id)" .to_string(),
                                                                                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                        {
                                                                                                            let ::types::ddlog_std::tuple4(ref file, ref export_scope, ref name, ref id) = *<::types::ddlog_std::tuple4<::types::ast::FileId, ::types::ast::ScopeId, ::types::internment::Intern<String>, ::types::ast::AnyId>>::from_ddvalue_ref( &__v );
                                                                                                            Some(((::types::ddlog_std::tuple3((*file).clone(), (*name).clone(), (*id).clone())).into_ddvalue(), (::types::ddlog_std::tuple3((*file).clone(), (*export_scope).clone(), (*id).clone())).into_ddvalue()))
                                                                                                        }
                                                                                                        __f},
                                                                                                        next: Box::new(XFormArrangement::Join{
                                                                                                                           description: "inputs::FileExport[(inputs::FileExport{.file=(file: ast::FileId), .export=(ast::NamedExport{.name=(export_name: ddlog_std::Option<ast::Spanned<ast::Name>>), .alias=(export_alias: ddlog_std::Option<ast::Spanned<ast::Name>>)}: ast::ExportKind), .scope=(export_scope: ast::ScopeId)}: inputs::FileExport)], ((ddlog_std::Some{.x=(ast::Spanned{.data=(var name: internment::Intern<string>), .span=(_: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<internment::Intern<string>>>) = ((utils::or_else: function(ddlog_std::Option<ast::Spanned<ast::Name>>, ddlog_std::Option<ast::Spanned<ast::Name>>):ddlog_std::Option<ast::Spanned<internment::Intern<string>>>)(export_alias, export_name))), name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(export_scope: ast::ScopeId), .declared=(id: ast::AnyId)}: name_in_scope::NameInScope)], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(id: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)]".to_string(),
                                                                                                                           ffun: None,
                                                                                                                           arrangement: (Relations::var_decls_VariableDeclarations as RelId,0),
                                                                                                                           jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                           {
                                                                                                                               let ::types::ddlog_std::tuple3(ref file, ref export_scope, ref id) = *<::types::ddlog_std::tuple3<::types::ast::FileId, ::types::ast::ScopeId, ::types::ast::AnyId>>::from_ddvalue_ref( __v1 );
                                                                                                                               let ref scope = match *<::types::var_decls::VariableDeclarations>::from_ddvalue_ref(__v2) {
                                                                                                                                   ::types::var_decls::VariableDeclarations{file: _, name: _, scope: ref scope, declared_in: _, meta: _} => (*scope).clone(),
                                                                                                                                   _ => return None
                                                                                                                               };
                                                                                                                               if !((&*(&::types::var_decls::hoisted_scope(scope))) == (&*export_scope)) {return None;};
                                                                                                                               Some(((::types::is_exported::IsExported{file: (*file).clone(), id: (*id).clone()})).into_ddvalue())
                                                                                                                           }
                                                                                                                           __f},
                                                                                                                           next: Box::new(None)
                                                                                                                       })
                                                                                                    }))
                                                                            })
                                                         })
                                         }],
                                     arrangements: vec![
                                         Arrangement::Set{
                                             name: r###"(is_exported::IsExported{.file=(_0: ast::FileId), .id=(_1: ast::AnyId)}: is_exported::IsExported) /*antijoin*/"###.to_string(),
                                             fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                             {
                                                 match < ::types::is_exported::IsExported>::from_ddvalue(__v) {
                                                     ::types::is_exported::IsExported{file: ref _0, id: ref _1} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                     _ => None
                                                 }
                                             }
                                             __f},
                                             distinct: true
                                         }],
                                     change_cb:    None
                                 };
    let outputs_unused_vars_UnusedVariables = Relation {
                                                  name:         "outputs::unused_vars::UnusedVariables".to_string(),
                                                  input:        false,
                                                  distinct:     true,
                                                  caching_mode: CachingMode::Set,
                                                  key_func:     None,
                                                  id:           Relations::outputs_unused_vars_UnusedVariables as RelId,
                                                  rules:        vec![
                                                      /* outputs::unused_vars::UnusedVariables[(outputs::unused_vars::UnusedVariables{.name=name, .declared=declared, .span=span, .file=file}: outputs::unused_vars::UnusedVariables)] :- __Prefix_4[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], (not (ast::is_global(declared))), not is_exported::IsExported[(is_exported::IsExported{.file=(file: ast::FileId), .id=(declared: ast::AnyId)}: is_exported::IsExported)], not name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::hoisted_scope(scope)), .declared=(declared: ast::AnyId)}: name_in_scope::NameInScope)]. */
                                                      Rule::ArrangementRule {
                                                          description: "outputs::unused_vars::UnusedVariables[(outputs::unused_vars::UnusedVariables{.name=name, .declared=declared, .span=span, .file=file}: outputs::unused_vars::UnusedVariables)] :- __Prefix_4[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], (not (ast::is_global(declared))), not is_exported::IsExported[(is_exported::IsExported{.file=(file: ast::FileId), .id=(declared: ast::AnyId)}: is_exported::IsExported)], not name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::hoisted_scope(scope)), .declared=(declared: ast::AnyId)}: name_in_scope::NameInScope)].".to_string(),
                                                          arr: ( Relations::__Prefix_4 as RelId, 0),
                                                          xform: XFormArrangement::Join{
                                                                     description: "__Prefix_4[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)]".to_string(),
                                                                     ffun: None,
                                                                     arrangement: (Relations::var_decls_VariableDeclarations as RelId,6),
                                                                     jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                     {
                                                                         let (ref file, ref config) = match *<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue_ref(__v1) {
                                                                             ::types::ddlog_std::tuple2(ref file, ref config) => ((*file).clone(), (*config).clone()),
                                                                             _ => return None
                                                                         };
                                                                         let (ref name, ref scope, ref declared, ref span) = match *<::types::var_decls::VariableDeclarations>::from_ddvalue_ref(__v2) {
                                                                             ::types::var_decls::VariableDeclarations{file: _, name: ref name, scope: ref scope, declared_in: ref declared, meta: ref _0_} => match ((*_0_)).deref() {
                                                                                                                                                                                                                  ::types::var_decls::VariableMeta{is_function_argument: _, implicitly_declared: _, declaration_span: ::types::ddlog_std::Option::Some{x: span}} => ((*name).clone(), (*scope).clone(), (*declared).clone(), (*span).clone()),
                                                                                                                                                                                                                  _ => return None
                                                                                                                                                                                                              },
                                                                             _ => return None
                                                                         };
                                                                         if !(!::types::ast::is_global(declared)) {return None;};
                                                                         Some((::types::ddlog_std::tuple5((*file).clone(), (*name).clone(), (*scope).clone(), (*declared).clone(), (*span).clone())).into_ddvalue())
                                                                     }
                                                                     __f},
                                                                     next: Box::new(Some(XFormCollection::Arrange {
                                                                                             description: "arrange __Prefix_4[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], (not (ast::is_global(declared))) by (file, declared)" .to_string(),
                                                                                             afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                             {
                                                                                                 let ::types::ddlog_std::tuple5(ref file, ref name, ref scope, ref declared, ref span) = *<::types::ddlog_std::tuple5<::types::ast::FileId, ::types::internment::Intern<String>, ::types::var_decls::DeclarationScope, ::types::ast::AnyId, ::types::ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                 Some(((::types::ddlog_std::tuple2((*file).clone(), (*declared).clone())).into_ddvalue(), (::types::ddlog_std::tuple5((*file).clone(), (*name).clone(), (*scope).clone(), (*declared).clone(), (*span).clone())).into_ddvalue()))
                                                                                             }
                                                                                             __f},
                                                                                             next: Box::new(XFormArrangement::Antijoin {
                                                                                                                description: "__Prefix_4[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], (not (ast::is_global(declared))), not is_exported::IsExported[(is_exported::IsExported{.file=(file: ast::FileId), .id=(declared: ast::AnyId)}: is_exported::IsExported)]".to_string(),
                                                                                                                ffun: None,
                                                                                                                arrangement: (Relations::is_exported_IsExported as RelId,0),
                                                                                                                next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                        description: "arrange __Prefix_4[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], (not (ast::is_global(declared))), not is_exported::IsExported[(is_exported::IsExported{.file=(file: ast::FileId), .id=(declared: ast::AnyId)}: is_exported::IsExported)] by (file, name, (var_decls::hoisted_scope(scope)), declared)" .to_string(),
                                                                                                                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                        {
                                                                                                                                            let ::types::ddlog_std::tuple5(ref file, ref name, ref scope, ref declared, ref span) = *<::types::ddlog_std::tuple5<::types::ast::FileId, ::types::internment::Intern<String>, ::types::var_decls::DeclarationScope, ::types::ast::AnyId, ::types::ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                            Some(((::types::ddlog_std::tuple4((*file).clone(), (*name).clone(), ::types::var_decls::hoisted_scope(scope), (*declared).clone())).into_ddvalue(), (::types::ddlog_std::tuple4((*file).clone(), (*name).clone(), (*declared).clone(), (*span).clone())).into_ddvalue()))
                                                                                                                                        }
                                                                                                                                        __f},
                                                                                                                                        next: Box::new(XFormArrangement::Antijoin {
                                                                                                                                                           description: "__Prefix_4[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], (not (ast::is_global(declared))), not is_exported::IsExported[(is_exported::IsExported{.file=(file: ast::FileId), .id=(declared: ast::AnyId)}: is_exported::IsExported)], not name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::hoisted_scope(scope)), .declared=(declared: ast::AnyId)}: name_in_scope::NameInScope)]".to_string(),
                                                                                                                                                           ffun: None,
                                                                                                                                                           arrangement: (Relations::name_in_scope_NameInScope as RelId,2),
                                                                                                                                                           next: Box::new(Some(XFormCollection::FilterMap{
                                                                                                                                                                                   description: "head of outputs::unused_vars::UnusedVariables[(outputs::unused_vars::UnusedVariables{.name=name, .declared=declared, .span=span, .file=file}: outputs::unused_vars::UnusedVariables)] :- __Prefix_4[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], (not (ast::is_global(declared))), not is_exported::IsExported[(is_exported::IsExported{.file=(file: ast::FileId), .id=(declared: ast::AnyId)}: is_exported::IsExported)], not name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::hoisted_scope(scope)), .declared=(declared: ast::AnyId)}: name_in_scope::NameInScope)]." .to_string(),
                                                                                                                                                                                   fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                                                                                                                                   {
                                                                                                                                                                                       let ::types::ddlog_std::tuple4(ref file, ref name, ref declared, ref span) = *<::types::ddlog_std::tuple4<::types::ast::FileId, ::types::internment::Intern<String>, ::types::ast::AnyId, ::types::ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                       Some(((::types::outputs::unused_vars::UnusedVariables{name: (*name).clone(), declared: (*declared).clone(), span: (*span).clone(), file: (*file).clone()})).into_ddvalue())
                                                                                                                                                                                   }
                                                                                                                                                                                   __f},
                                                                                                                                                                                   next: Box::new(None)
                                                                                                                                                                               }))
                                                                                                                                                       })
                                                                                                                                    }))
                                                                                                            })
                                                                                         }))
                                                                 }
                                                      },
                                                      /* outputs::unused_vars::UnusedVariables[(outputs::unused_vars::UnusedVariables{.name=name, .declared=declared, .span=span, .file=file}: outputs::unused_vars::UnusedVariables)] :- __Prefix_4[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], not name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::unhoisted_scope(scope)), .declared=(declared: ast::AnyId)}: name_in_scope::NameInScope)]. */
                                                      Rule::ArrangementRule {
                                                          description: "outputs::unused_vars::UnusedVariables[(outputs::unused_vars::UnusedVariables{.name=name, .declared=declared, .span=span, .file=file}: outputs::unused_vars::UnusedVariables)] :- __Prefix_4[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], not name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::unhoisted_scope(scope)), .declared=(declared: ast::AnyId)}: name_in_scope::NameInScope)].".to_string(),
                                                          arr: ( Relations::__Prefix_4 as RelId, 0),
                                                          xform: XFormArrangement::Join{
                                                                     description: "__Prefix_4[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)]".to_string(),
                                                                     ffun: None,
                                                                     arrangement: (Relations::var_decls_VariableDeclarations as RelId,7),
                                                                     jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                     {
                                                                         let (ref file, ref config) = match *<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue_ref(__v1) {
                                                                             ::types::ddlog_std::tuple2(ref file, ref config) => ((*file).clone(), (*config).clone()),
                                                                             _ => return None
                                                                         };
                                                                         let (ref name, ref scope, ref declared, ref span) = match *<::types::var_decls::VariableDeclarations>::from_ddvalue_ref(__v2) {
                                                                             ::types::var_decls::VariableDeclarations{file: _, name: ref name, scope: ref scope, declared_in: ref declared, meta: ref _0_} => match ((*_0_)).deref() {
                                                                                                                                                                                                                  ::types::var_decls::VariableMeta{is_function_argument: _, implicitly_declared: _, declaration_span: ::types::ddlog_std::Option::Some{x: span}} => ((*name).clone(), (*scope).clone(), (*declared).clone(), (*span).clone()),
                                                                                                                                                                                                                  _ => return None
                                                                                                                                                                                                              },
                                                                             _ => return None
                                                                         };
                                                                         Some((::types::ddlog_std::tuple5((*file).clone(), (*name).clone(), (*scope).clone(), (*declared).clone(), (*span).clone())).into_ddvalue())
                                                                     }
                                                                     __f},
                                                                     next: Box::new(Some(XFormCollection::Arrange {
                                                                                             description: "arrange __Prefix_4[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)] by (file, name, (var_decls::unhoisted_scope(scope)), declared)" .to_string(),
                                                                                             afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                             {
                                                                                                 let ::types::ddlog_std::tuple5(ref file, ref name, ref scope, ref declared, ref span) = *<::types::ddlog_std::tuple5<::types::ast::FileId, ::types::internment::Intern<String>, ::types::var_decls::DeclarationScope, ::types::ast::AnyId, ::types::ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                 Some(((::types::ddlog_std::tuple4((*file).clone(), (*name).clone(), ::types::var_decls::unhoisted_scope(scope), (*declared).clone())).into_ddvalue(), (::types::ddlog_std::tuple4((*file).clone(), (*name).clone(), (*declared).clone(), (*span).clone())).into_ddvalue()))
                                                                                             }
                                                                                             __f},
                                                                                             next: Box::new(XFormArrangement::Antijoin {
                                                                                                                description: "__Prefix_4[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], not name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::unhoisted_scope(scope)), .declared=(declared: ast::AnyId)}: name_in_scope::NameInScope)]".to_string(),
                                                                                                                ffun: None,
                                                                                                                arrangement: (Relations::name_in_scope_NameInScope as RelId,2),
                                                                                                                next: Box::new(Some(XFormCollection::FilterMap{
                                                                                                                                        description: "head of outputs::unused_vars::UnusedVariables[(outputs::unused_vars::UnusedVariables{.name=name, .declared=declared, .span=span, .file=file}: outputs::unused_vars::UnusedVariables)] :- __Prefix_4[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], not name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::unhoisted_scope(scope)), .declared=(declared: ast::AnyId)}: name_in_scope::NameInScope)]." .to_string(),
                                                                                                                                        fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                                                                                        {
                                                                                                                                            let ::types::ddlog_std::tuple4(ref file, ref name, ref declared, ref span) = *<::types::ddlog_std::tuple4<::types::ast::FileId, ::types::internment::Intern<String>, ::types::ast::AnyId, ::types::ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                            Some(((::types::outputs::unused_vars::UnusedVariables{name: (*name).clone(), declared: (*declared).clone(), span: (*span).clone(), file: (*file).clone()})).into_ddvalue())
                                                                                                                                        }
                                                                                                                                        __f},
                                                                                                                                        next: Box::new(None)
                                                                                                                                    }))
                                                                                                            })
                                                                                         }))
                                                                 }
                                                      },
                                                      /* outputs::unused_vars::UnusedVariables[(outputs::unused_vars::UnusedVariables{.name=name, .declared=declared, .span=span, .file=file}: outputs::unused_vars::UnusedVariables)] :- __Prefix_4[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared@ (ast::AnyIdGlobal{.global=(_: ast::GlobalId)}: ast::AnyId)), .meta=((&(var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], not is_exported::IsExported[(is_exported::IsExported{.file=(file: ast::FileId), .id=(declared: ast::AnyId)}: is_exported::IsExported)], not name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::unhoisted_scope(scope)), .declared=(declared: ast::AnyId)}: name_in_scope::NameInScope)]. */
                                                      Rule::ArrangementRule {
                                                          description: "outputs::unused_vars::UnusedVariables[(outputs::unused_vars::UnusedVariables{.name=name, .declared=declared, .span=span, .file=file}: outputs::unused_vars::UnusedVariables)] :- __Prefix_4[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared@ (ast::AnyIdGlobal{.global=(_: ast::GlobalId)}: ast::AnyId)), .meta=((&(var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], not is_exported::IsExported[(is_exported::IsExported{.file=(file: ast::FileId), .id=(declared: ast::AnyId)}: is_exported::IsExported)], not name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::unhoisted_scope(scope)), .declared=(declared: ast::AnyId)}: name_in_scope::NameInScope)].".to_string(),
                                                          arr: ( Relations::__Prefix_4 as RelId, 0),
                                                          xform: XFormArrangement::Join{
                                                                     description: "__Prefix_4[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared@ (ast::AnyIdGlobal{.global=(_: ast::GlobalId)}: ast::AnyId)), .meta=((&(var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)]".to_string(),
                                                                     ffun: None,
                                                                     arrangement: (Relations::var_decls_VariableDeclarations as RelId,8),
                                                                     jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                     {
                                                                         let (ref file, ref config) = match *<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue_ref(__v1) {
                                                                             ::types::ddlog_std::tuple2(ref file, ref config) => ((*file).clone(), (*config).clone()),
                                                                             _ => return None
                                                                         };
                                                                         let (ref name, ref scope, ref declared, ref span) = match *<::types::var_decls::VariableDeclarations>::from_ddvalue_ref(__v2) {
                                                                             ::types::var_decls::VariableDeclarations{file: _, name: ref name, scope: ref scope, declared_in: ref declared, meta: ref _0_} => match declared {
                                                                                                                                                                                                                  ::types::ast::AnyId::AnyIdGlobal{global: _} => match ((*_0_)).deref() {
                                                                                                                                                                                                                                                                     ::types::var_decls::VariableMeta{is_function_argument: _, implicitly_declared: _, declaration_span: ::types::ddlog_std::Option::Some{x: span}} => ((*name).clone(), (*scope).clone(), (*declared).clone(), (*span).clone()),
                                                                                                                                                                                                                                                                     _ => return None
                                                                                                                                                                                                                                                                 },
                                                                                                                                                                                                                  _ => return None
                                                                                                                                                                                                              },
                                                                             _ => return None
                                                                         };
                                                                         Some((::types::ddlog_std::tuple5((*file).clone(), (*name).clone(), (*scope).clone(), (*declared).clone(), (*span).clone())).into_ddvalue())
                                                                     }
                                                                     __f},
                                                                     next: Box::new(Some(XFormCollection::Arrange {
                                                                                             description: "arrange __Prefix_4[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared@ (ast::AnyIdGlobal{.global=(_: ast::GlobalId)}: ast::AnyId)), .meta=((&(var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)] by (file, declared)" .to_string(),
                                                                                             afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                             {
                                                                                                 let ::types::ddlog_std::tuple5(ref file, ref name, ref scope, ref declared, ref span) = *<::types::ddlog_std::tuple5<::types::ast::FileId, ::types::internment::Intern<String>, ::types::var_decls::DeclarationScope, ::types::ast::AnyId, ::types::ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                 Some(((::types::ddlog_std::tuple2((*file).clone(), (*declared).clone())).into_ddvalue(), (::types::ddlog_std::tuple5((*file).clone(), (*name).clone(), (*scope).clone(), (*declared).clone(), (*span).clone())).into_ddvalue()))
                                                                                             }
                                                                                             __f},
                                                                                             next: Box::new(XFormArrangement::Antijoin {
                                                                                                                description: "__Prefix_4[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared@ (ast::AnyIdGlobal{.global=(_: ast::GlobalId)}: ast::AnyId)), .meta=((&(var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], not is_exported::IsExported[(is_exported::IsExported{.file=(file: ast::FileId), .id=(declared: ast::AnyId)}: is_exported::IsExported)]".to_string(),
                                                                                                                ffun: None,
                                                                                                                arrangement: (Relations::is_exported_IsExported as RelId,0),
                                                                                                                next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                        description: "arrange __Prefix_4[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared@ (ast::AnyIdGlobal{.global=(_: ast::GlobalId)}: ast::AnyId)), .meta=((&(var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], not is_exported::IsExported[(is_exported::IsExported{.file=(file: ast::FileId), .id=(declared: ast::AnyId)}: is_exported::IsExported)] by (file, name, (var_decls::unhoisted_scope(scope)), declared)" .to_string(),
                                                                                                                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                        {
                                                                                                                                            let ::types::ddlog_std::tuple5(ref file, ref name, ref scope, ref declared, ref span) = *<::types::ddlog_std::tuple5<::types::ast::FileId, ::types::internment::Intern<String>, ::types::var_decls::DeclarationScope, ::types::ast::AnyId, ::types::ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                            Some(((::types::ddlog_std::tuple4((*file).clone(), (*name).clone(), ::types::var_decls::unhoisted_scope(scope), (*declared).clone())).into_ddvalue(), (::types::ddlog_std::tuple4((*file).clone(), (*name).clone(), (*declared).clone(), (*span).clone())).into_ddvalue()))
                                                                                                                                        }
                                                                                                                                        __f},
                                                                                                                                        next: Box::new(XFormArrangement::Antijoin {
                                                                                                                                                           description: "__Prefix_4[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared@ (ast::AnyIdGlobal{.global=(_: ast::GlobalId)}: ast::AnyId)), .meta=((&(var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], not is_exported::IsExported[(is_exported::IsExported{.file=(file: ast::FileId), .id=(declared: ast::AnyId)}: is_exported::IsExported)], not name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::unhoisted_scope(scope)), .declared=(declared: ast::AnyId)}: name_in_scope::NameInScope)]".to_string(),
                                                                                                                                                           ffun: None,
                                                                                                                                                           arrangement: (Relations::name_in_scope_NameInScope as RelId,2),
                                                                                                                                                           next: Box::new(Some(XFormCollection::FilterMap{
                                                                                                                                                                                   description: "head of outputs::unused_vars::UnusedVariables[(outputs::unused_vars::UnusedVariables{.name=name, .declared=declared, .span=span, .file=file}: outputs::unused_vars::UnusedVariables)] :- __Prefix_4[((file: ast::FileId), (config: config::Config))], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared@ (ast::AnyIdGlobal{.global=(_: ast::GlobalId)}: ast::AnyId)), .meta=((&(var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], not is_exported::IsExported[(is_exported::IsExported{.file=(file: ast::FileId), .id=(declared: ast::AnyId)}: is_exported::IsExported)], not name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(var_decls::unhoisted_scope(scope)), .declared=(declared: ast::AnyId)}: name_in_scope::NameInScope)]." .to_string(),
                                                                                                                                                                                   fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                                                                                                                                   {
                                                                                                                                                                                       let ::types::ddlog_std::tuple4(ref file, ref name, ref declared, ref span) = *<::types::ddlog_std::tuple4<::types::ast::FileId, ::types::internment::Intern<String>, ::types::ast::AnyId, ::types::ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                       Some(((::types::outputs::unused_vars::UnusedVariables{name: (*name).clone(), declared: (*declared).clone(), span: (*span).clone(), file: (*file).clone()})).into_ddvalue())
                                                                                                                                                                                   }
                                                                                                                                                                                   __f},
                                                                                                                                                                                   next: Box::new(None)
                                                                                                                                                                               }))
                                                                                                                                                       })
                                                                                                                                    }))
                                                                                                            })
                                                                                         }))
                                                                 }
                                                      }],
                                                  arrangements: vec![
                                                      ],
                                                  change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
                                              };
    let variable_decl_VariableDecl = Relation {
                                         name:         "variable_decl::VariableDecl".to_string(),
                                         input:        false,
                                         distinct:     false,
                                         caching_mode: CachingMode::Set,
                                         key_func:     None,
                                         id:           Relations::variable_decl_VariableDecl as RelId,
                                         rules:        vec![
                                             /* variable_decl::VariableDecl[(variable_decl::VariableDecl{.stmt=stmt, .file=file, .kind=(variable_decl::VarDeclVar{}: variable_decl::VariableDeclKind), .pattern=pattern, .value=value, .exported=exported}: variable_decl::VariableDecl)] :- inputs::VarDecl[(inputs::VarDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(pattern: ddlog_std::Option<ast::IPattern>), .value=(value: ddlog_std::Option<ast::ExprId>), .exported=(exported: bool)}: inputs::VarDecl)]. */
                                             Rule::CollectionRule {
                                                 description: "variable_decl::VariableDecl[(variable_decl::VariableDecl{.stmt=stmt, .file=file, .kind=(variable_decl::VarDeclVar{}: variable_decl::VariableDeclKind), .pattern=pattern, .value=value, .exported=exported}: variable_decl::VariableDecl)] :- inputs::VarDecl[(inputs::VarDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(pattern: ddlog_std::Option<ast::IPattern>), .value=(value: ddlog_std::Option<ast::ExprId>), .exported=(exported: bool)}: inputs::VarDecl)].".to_string(),
                                                 rel: Relations::inputs_VarDecl as RelId,
                                                 xform: Some(XFormCollection::FilterMap{
                                                                 description: "head of variable_decl::VariableDecl[(variable_decl::VariableDecl{.stmt=stmt, .file=file, .kind=(variable_decl::VarDeclVar{}: variable_decl::VariableDeclKind), .pattern=pattern, .value=value, .exported=exported}: variable_decl::VariableDecl)] :- inputs::VarDecl[(inputs::VarDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(pattern: ddlog_std::Option<ast::IPattern>), .value=(value: ddlog_std::Option<ast::ExprId>), .exported=(exported: bool)}: inputs::VarDecl)]." .to_string(),
                                                                 fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                 {
                                                                     let (ref stmt, ref file, ref pattern, ref value, ref exported) = match *<::types::inputs::VarDecl>::from_ddvalue_ref(&__v) {
                                                                         ::types::inputs::VarDecl{stmt_id: ref stmt, file: ref file, pattern: ref pattern, value: ref value, exported: ref exported} => ((*stmt).clone(), (*file).clone(), (*pattern).clone(), (*value).clone(), (*exported).clone()),
                                                                         _ => return None
                                                                     };
                                                                     Some(((::types::variable_decl::VariableDecl{stmt: (*stmt).clone(), file: (*file).clone(), kind: (::types::variable_decl::VariableDeclKind::VarDeclVar{}), pattern: (*pattern).clone(), value: (*value).clone(), exported: (*exported).clone()})).into_ddvalue())
                                                                 }
                                                                 __f},
                                                                 next: Box::new(None)
                                                             })
                                             },
                                             /* variable_decl::VariableDecl[(variable_decl::VariableDecl{.stmt=stmt, .file=file, .kind=(variable_decl::VarDeclLet{}: variable_decl::VariableDeclKind), .pattern=pattern, .value=value, .exported=exported}: variable_decl::VariableDecl)] :- inputs::LetDecl[(inputs::LetDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(pattern: ddlog_std::Option<ast::IPattern>), .value=(value: ddlog_std::Option<ast::ExprId>), .exported=(exported: bool)}: inputs::LetDecl)]. */
                                             Rule::CollectionRule {
                                                 description: "variable_decl::VariableDecl[(variable_decl::VariableDecl{.stmt=stmt, .file=file, .kind=(variable_decl::VarDeclLet{}: variable_decl::VariableDeclKind), .pattern=pattern, .value=value, .exported=exported}: variable_decl::VariableDecl)] :- inputs::LetDecl[(inputs::LetDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(pattern: ddlog_std::Option<ast::IPattern>), .value=(value: ddlog_std::Option<ast::ExprId>), .exported=(exported: bool)}: inputs::LetDecl)].".to_string(),
                                                 rel: Relations::inputs_LetDecl as RelId,
                                                 xform: Some(XFormCollection::FilterMap{
                                                                 description: "head of variable_decl::VariableDecl[(variable_decl::VariableDecl{.stmt=stmt, .file=file, .kind=(variable_decl::VarDeclLet{}: variable_decl::VariableDeclKind), .pattern=pattern, .value=value, .exported=exported}: variable_decl::VariableDecl)] :- inputs::LetDecl[(inputs::LetDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(pattern: ddlog_std::Option<ast::IPattern>), .value=(value: ddlog_std::Option<ast::ExprId>), .exported=(exported: bool)}: inputs::LetDecl)]." .to_string(),
                                                                 fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                 {
                                                                     let (ref stmt, ref file, ref pattern, ref value, ref exported) = match *<::types::inputs::LetDecl>::from_ddvalue_ref(&__v) {
                                                                         ::types::inputs::LetDecl{stmt_id: ref stmt, file: ref file, pattern: ref pattern, value: ref value, exported: ref exported} => ((*stmt).clone(), (*file).clone(), (*pattern).clone(), (*value).clone(), (*exported).clone()),
                                                                         _ => return None
                                                                     };
                                                                     Some(((::types::variable_decl::VariableDecl{stmt: (*stmt).clone(), file: (*file).clone(), kind: (::types::variable_decl::VariableDeclKind::VarDeclLet{}), pattern: (*pattern).clone(), value: (*value).clone(), exported: (*exported).clone()})).into_ddvalue())
                                                                 }
                                                                 __f},
                                                                 next: Box::new(None)
                                                             })
                                             },
                                             /* variable_decl::VariableDecl[(variable_decl::VariableDecl{.stmt=stmt, .file=file, .kind=(variable_decl::VarDeclConst{}: variable_decl::VariableDeclKind), .pattern=pattern, .value=value, .exported=exported}: variable_decl::VariableDecl)] :- inputs::ConstDecl[(inputs::ConstDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(pattern: ddlog_std::Option<ast::IPattern>), .value=(value: ddlog_std::Option<ast::ExprId>), .exported=(exported: bool)}: inputs::ConstDecl)]. */
                                             Rule::CollectionRule {
                                                 description: "variable_decl::VariableDecl[(variable_decl::VariableDecl{.stmt=stmt, .file=file, .kind=(variable_decl::VarDeclConst{}: variable_decl::VariableDeclKind), .pattern=pattern, .value=value, .exported=exported}: variable_decl::VariableDecl)] :- inputs::ConstDecl[(inputs::ConstDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(pattern: ddlog_std::Option<ast::IPattern>), .value=(value: ddlog_std::Option<ast::ExprId>), .exported=(exported: bool)}: inputs::ConstDecl)].".to_string(),
                                                 rel: Relations::inputs_ConstDecl as RelId,
                                                 xform: Some(XFormCollection::FilterMap{
                                                                 description: "head of variable_decl::VariableDecl[(variable_decl::VariableDecl{.stmt=stmt, .file=file, .kind=(variable_decl::VarDeclConst{}: variable_decl::VariableDeclKind), .pattern=pattern, .value=value, .exported=exported}: variable_decl::VariableDecl)] :- inputs::ConstDecl[(inputs::ConstDecl{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .pattern=(pattern: ddlog_std::Option<ast::IPattern>), .value=(value: ddlog_std::Option<ast::ExprId>), .exported=(exported: bool)}: inputs::ConstDecl)]." .to_string(),
                                                                 fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                 {
                                                                     let (ref stmt, ref file, ref pattern, ref value, ref exported) = match *<::types::inputs::ConstDecl>::from_ddvalue_ref(&__v) {
                                                                         ::types::inputs::ConstDecl{stmt_id: ref stmt, file: ref file, pattern: ref pattern, value: ref value, exported: ref exported} => ((*stmt).clone(), (*file).clone(), (*pattern).clone(), (*value).clone(), (*exported).clone()),
                                                                         _ => return None
                                                                     };
                                                                     Some(((::types::variable_decl::VariableDecl{stmt: (*stmt).clone(), file: (*file).clone(), kind: (::types::variable_decl::VariableDeclKind::VarDeclConst{}), pattern: (*pattern).clone(), value: (*value).clone(), exported: (*exported).clone()})).into_ddvalue())
                                                                 }
                                                                 __f},
                                                                 next: Box::new(None)
                                                             })
                                             }],
                                         arrangements: vec![
                                             Arrangement::Map{
                                                name: r###"(variable_decl::VariableDecl{.stmt=(_0: ast::StmtId), .file=(_1: ast::FileId), .kind=(_: variable_decl::VariableDeclKind), .pattern=(_: ddlog_std::Option<ast::IPattern>), .value=(ddlog_std::Some{.x=(_: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: variable_decl::VariableDecl) /*join*/"###.to_string(),
                                                 afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                 {
                                                     let __cloned = __v.clone();
                                                     match < ::types::variable_decl::VariableDecl>::from_ddvalue(__v) {
                                                         ::types::variable_decl::VariableDecl{stmt: ref _0, file: ref _1, kind: _, pattern: _, value: ::types::ddlog_std::Option::Some{x: _}, exported: _} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                         _ => None
                                                     }.map(|x|(x,__cloned))
                                                 }
                                                 __f},
                                                 queryable: false
                                             }],
                                         change_cb:    None
                                     };
    let outputs_use_before_def_UseBeforeDef = Relation {
                                                  name:         "outputs::use_before_def::UseBeforeDef".to_string(),
                                                  input:        false,
                                                  distinct:     true,
                                                  caching_mode: CachingMode::Set,
                                                  key_func:     None,
                                                  id:           Relations::outputs_use_before_def_UseBeforeDef as RelId,
                                                  rules:        vec![
                                                      /* outputs::use_before_def::UseBeforeDef[(outputs::use_before_def::UseBeforeDef{.name=name, .used=expr, .used_in=used_in, .declared=declared, .declared_in=declared_in, .file=file}: outputs::use_before_def::UseBeforeDef)] :- __Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(used_scope: ast::ScopeId), .span=(used_in: ast::Span)}: inputs::Expression)], not inputs::New[(inputs::New{.expr_id=(_: ast::ExprId), .file=(file: ast::FileId), .object=(ddlog_std::Some{.x=(expr: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::New)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdStmt{.stmt=(stmt: ast::StmtId)}: ast::AnyId))}: name_in_scope::NameInScope)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(ast::StmtVarDecl{}: ast::StmtKind), .scope=(declared_scope: ast::ScopeId), .span=(declared_in: ast::Span)}: inputs::Statement)], ((declared_scope != used_scope) and (used_in < declared_in)). */
                                                      Rule::ArrangementRule {
                                                          description: "outputs::use_before_def::UseBeforeDef[(outputs::use_before_def::UseBeforeDef{.name=name, .used=expr, .used_in=used_in, .declared=declared, .declared_in=declared_in, .file=file}: outputs::use_before_def::UseBeforeDef)] :- __Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(used_scope: ast::ScopeId), .span=(used_in: ast::Span)}: inputs::Expression)], not inputs::New[(inputs::New{.expr_id=(_: ast::ExprId), .file=(file: ast::FileId), .object=(ddlog_std::Some{.x=(expr: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::New)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdStmt{.stmt=(stmt: ast::StmtId)}: ast::AnyId))}: name_in_scope::NameInScope)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(ast::StmtVarDecl{}: ast::StmtKind), .scope=(declared_scope: ast::ScopeId), .span=(declared_in: ast::Span)}: inputs::Statement)], ((declared_scope != used_scope) and (used_in < declared_in)).".to_string(),
                                                          arr: ( Relations::__Prefix_7 as RelId, 0),
                                                          xform: XFormArrangement::Join{
                                                                     description: "__Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)]".to_string(),
                                                                     ffun: None,
                                                                     arrangement: (Relations::inputs_NameRef as RelId,1),
                                                                     jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                     {
                                                                         let (ref file, ref config) = match *<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue_ref(__v1) {
                                                                             ::types::ddlog_std::tuple2(ref file, ref config) => ((*file).clone(), (*config).clone()),
                                                                             _ => return None
                                                                         };
                                                                         let (ref expr, ref name) = match *<::types::inputs::NameRef>::from_ddvalue_ref(__v2) {
                                                                             ::types::inputs::NameRef{expr_id: ref expr, file: _, value: ref name} => ((*expr).clone(), (*name).clone()),
                                                                             _ => return None
                                                                         };
                                                                         Some((::types::ddlog_std::tuple3((*file).clone(), (*expr).clone(), (*name).clone())).into_ddvalue())
                                                                     }
                                                                     __f},
                                                                     next: Box::new(Some(XFormCollection::Arrange {
                                                                                             description: "arrange __Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)] by (expr, file)" .to_string(),
                                                                                             afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                             {
                                                                                                 let ::types::ddlog_std::tuple3(ref file, ref expr, ref name) = *<::types::ddlog_std::tuple3<::types::ast::FileId, ::types::ast::ExprId, ::types::internment::Intern<String>>>::from_ddvalue_ref( &__v );
                                                                                                 Some(((::types::ddlog_std::tuple2((*expr).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple3((*file).clone(), (*expr).clone(), (*name).clone())).into_ddvalue()))
                                                                                             }
                                                                                             __f},
                                                                                             next: Box::new(XFormArrangement::Join{
                                                                                                                description: "__Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(used_scope: ast::ScopeId), .span=(used_in: ast::Span)}: inputs::Expression)]".to_string(),
                                                                                                                ffun: None,
                                                                                                                arrangement: (Relations::inputs_Expression as RelId,1),
                                                                                                                jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                {
                                                                                                                    let ::types::ddlog_std::tuple3(ref file, ref expr, ref name) = *<::types::ddlog_std::tuple3<::types::ast::FileId, ::types::ast::ExprId, ::types::internment::Intern<String>>>::from_ddvalue_ref( __v1 );
                                                                                                                    let (ref used_scope, ref used_in) = match *<::types::inputs::Expression>::from_ddvalue_ref(__v2) {
                                                                                                                        ::types::inputs::Expression{id: _, file: _, kind: ::types::ast::ExprKind::ExprNameRef{}, scope: ref used_scope, span: ref used_in} => ((*used_scope).clone(), (*used_in).clone()),
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    Some((::types::ddlog_std::tuple5((*file).clone(), (*expr).clone(), (*name).clone(), (*used_scope).clone(), (*used_in).clone())).into_ddvalue())
                                                                                                                }
                                                                                                                __f},
                                                                                                                next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                        description: "arrange __Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(used_scope: ast::ScopeId), .span=(used_in: ast::Span)}: inputs::Expression)] by (file, expr)" .to_string(),
                                                                                                                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                        {
                                                                                                                                            let ::types::ddlog_std::tuple5(ref file, ref expr, ref name, ref used_scope, ref used_in) = *<::types::ddlog_std::tuple5<::types::ast::FileId, ::types::ast::ExprId, ::types::internment::Intern<String>, ::types::ast::ScopeId, ::types::ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                            Some(((::types::ddlog_std::tuple2((*file).clone(), (*expr).clone())).into_ddvalue(), (::types::ddlog_std::tuple5((*file).clone(), (*expr).clone(), (*name).clone(), (*used_scope).clone(), (*used_in).clone())).into_ddvalue()))
                                                                                                                                        }
                                                                                                                                        __f},
                                                                                                                                        next: Box::new(XFormArrangement::Antijoin {
                                                                                                                                                           description: "__Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(used_scope: ast::ScopeId), .span=(used_in: ast::Span)}: inputs::Expression)], not inputs::New[(inputs::New{.expr_id=(_: ast::ExprId), .file=(file: ast::FileId), .object=(ddlog_std::Some{.x=(expr: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::New)]".to_string(),
                                                                                                                                                           ffun: None,
                                                                                                                                                           arrangement: (Relations::inputs_New as RelId,1),
                                                                                                                                                           next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                   description: "arrange __Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(used_scope: ast::ScopeId), .span=(used_in: ast::Span)}: inputs::Expression)], not inputs::New[(inputs::New{.expr_id=(_: ast::ExprId), .file=(file: ast::FileId), .object=(ddlog_std::Some{.x=(expr: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::New)] by (file, name, used_scope)" .to_string(),
                                                                                                                                                                                   afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                                   {
                                                                                                                                                                                       let ::types::ddlog_std::tuple5(ref file, ref expr, ref name, ref used_scope, ref used_in) = *<::types::ddlog_std::tuple5<::types::ast::FileId, ::types::ast::ExprId, ::types::internment::Intern<String>, ::types::ast::ScopeId, ::types::ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                       Some(((::types::ddlog_std::tuple3((*file).clone(), (*name).clone(), (*used_scope).clone())).into_ddvalue(), (::types::ddlog_std::tuple5((*file).clone(), (*expr).clone(), (*name).clone(), (*used_scope).clone(), (*used_in).clone())).into_ddvalue()))
                                                                                                                                                                                   }
                                                                                                                                                                                   __f},
                                                                                                                                                                                   next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                      description: "__Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(used_scope: ast::ScopeId), .span=(used_in: ast::Span)}: inputs::Expression)], not inputs::New[(inputs::New{.expr_id=(_: ast::ExprId), .file=(file: ast::FileId), .object=(ddlog_std::Some{.x=(expr: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::New)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdStmt{.stmt=(stmt: ast::StmtId)}: ast::AnyId))}: name_in_scope::NameInScope)]".to_string(),
                                                                                                                                                                                                      ffun: None,
                                                                                                                                                                                                      arrangement: (Relations::name_in_scope_NameInScope as RelId,3),
                                                                                                                                                                                                      jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                                                                      {
                                                                                                                                                                                                          let ::types::ddlog_std::tuple5(ref file, ref expr, ref name, ref used_scope, ref used_in) = *<::types::ddlog_std::tuple5<::types::ast::FileId, ::types::ast::ExprId, ::types::internment::Intern<String>, ::types::ast::ScopeId, ::types::ast::Span>>::from_ddvalue_ref( __v1 );
                                                                                                                                                                                                          let (ref declared, ref stmt) = match *<::types::name_in_scope::NameInScope>::from_ddvalue_ref(__v2) {
                                                                                                                                                                                                              ::types::name_in_scope::NameInScope{file: _, name: _, scope: _, declared: ref declared} => match declared {
                                                                                                                                                                                                                                                                                                             ::types::ast::AnyId::AnyIdStmt{stmt: ref stmt} => ((*declared).clone(), (*stmt).clone()),
                                                                                                                                                                                                                                                                                                             _ => return None
                                                                                                                                                                                                                                                                                                         },
                                                                                                                                                                                                              _ => return None
                                                                                                                                                                                                          };
                                                                                                                                                                                                          Some((::types::ddlog_std::tuple7((*file).clone(), (*expr).clone(), (*name).clone(), (*used_scope).clone(), (*used_in).clone(), (*declared).clone(), (*stmt).clone())).into_ddvalue())
                                                                                                                                                                                                      }
                                                                                                                                                                                                      __f},
                                                                                                                                                                                                      next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                                              description: "arrange __Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(used_scope: ast::ScopeId), .span=(used_in: ast::Span)}: inputs::Expression)], not inputs::New[(inputs::New{.expr_id=(_: ast::ExprId), .file=(file: ast::FileId), .object=(ddlog_std::Some{.x=(expr: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::New)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdStmt{.stmt=(stmt: ast::StmtId)}: ast::AnyId))}: name_in_scope::NameInScope)] by (stmt, file)" .to_string(),
                                                                                                                                                                                                                              afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                  let ::types::ddlog_std::tuple7(ref file, ref expr, ref name, ref used_scope, ref used_in, ref declared, ref stmt) = *<::types::ddlog_std::tuple7<::types::ast::FileId, ::types::ast::ExprId, ::types::internment::Intern<String>, ::types::ast::ScopeId, ::types::ast::Span, ::types::ast::AnyId, ::types::ast::StmtId>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                                                                  Some(((::types::ddlog_std::tuple2((*stmt).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple6((*file).clone(), (*expr).clone(), (*name).clone(), (*used_scope).clone(), (*used_in).clone(), (*declared).clone())).into_ddvalue()))
                                                                                                                                                                                                                              }
                                                                                                                                                                                                                              __f},
                                                                                                                                                                                                                              next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                                                                 description: "__Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::NameRef[(inputs::NameRef{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(ast::ExprNameRef{}: ast::ExprKind), .scope=(used_scope: ast::ScopeId), .span=(used_in: ast::Span)}: inputs::Expression)], not inputs::New[(inputs::New{.expr_id=(_: ast::ExprId), .file=(file: ast::FileId), .object=(ddlog_std::Some{.x=(expr: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::New)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdStmt{.stmt=(stmt: ast::StmtId)}: ast::AnyId))}: name_in_scope::NameInScope)], inputs::Statement[(inputs::Statement{.id=(stmt: ast::StmtId), .file=(file: ast::FileId), .kind=(ast::StmtVarDecl{}: ast::StmtKind), .scope=(declared_scope: ast::ScopeId), .span=(declared_in: ast::Span)}: inputs::Statement)]".to_string(),
                                                                                                                                                                                                                                                 ffun: None,
                                                                                                                                                                                                                                                 arrangement: (Relations::inputs_Statement as RelId,1),
                                                                                                                                                                                                                                                 jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                     let ::types::ddlog_std::tuple6(ref file, ref expr, ref name, ref used_scope, ref used_in, ref declared) = *<::types::ddlog_std::tuple6<::types::ast::FileId, ::types::ast::ExprId, ::types::internment::Intern<String>, ::types::ast::ScopeId, ::types::ast::Span, ::types::ast::AnyId>>::from_ddvalue_ref( __v1 );
                                                                                                                                                                                                                                                     let (ref declared_scope, ref declared_in) = match *<::types::inputs::Statement>::from_ddvalue_ref(__v2) {
                                                                                                                                                                                                                                                         ::types::inputs::Statement{id: _, file: _, kind: ::types::ast::StmtKind::StmtVarDecl{}, scope: ref declared_scope, span: ref declared_in} => ((*declared_scope).clone(), (*declared_in).clone()),
                                                                                                                                                                                                                                                         _ => return None
                                                                                                                                                                                                                                                     };
                                                                                                                                                                                                                                                     if !(((&*declared_scope) != (&*used_scope)) && ((&*used_in) < (&*declared_in))) {return None;};
                                                                                                                                                                                                                                                     Some(((::types::outputs::use_before_def::UseBeforeDef{name: (*name).clone(), used: (*expr).clone(), used_in: (*used_in).clone(), declared: (*declared).clone(), declared_in: (*declared_in).clone(), file: (*file).clone()})).into_ddvalue())
                                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                                                 __f},
                                                                                                                                                                                                                                                 next: Box::new(None)
                                                                                                                                                                                                                                             })
                                                                                                                                                                                                                          }))
                                                                                                                                                                                                  })
                                                                                                                                                                               }))
                                                                                                                                                       })
                                                                                                                                    }))
                                                                                                            })
                                                                                         }))
                                                                 }
                                                      },
                                                      /* outputs::use_before_def::UseBeforeDef[(outputs::use_before_def::UseBeforeDef{.name=name, .used=expr, .used_in=used_in, .declared=declared, .declared_in=declared_in, .file=file}: outputs::use_before_def::UseBeforeDef)] :- __Prefix_1[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span))], inputs::NameRef[(inputs::NameRef{.expr_id=(callee: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdClass{.class=(class: ast::ClassId)}: ast::AnyId))}: name_in_scope::NameInScope)], inputs::Class[(inputs::Class{.id=(class: ast::ClassId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(_: internment::Intern<string>), .span=(declared_in: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(decl_scope: ast::ScopeId), .exported=(_: bool)}: inputs::Class)], ((decl_scope != used_scope) and (used_in < declared_in)). */
                                                      Rule::ArrangementRule {
                                                          description: "outputs::use_before_def::UseBeforeDef[(outputs::use_before_def::UseBeforeDef{.name=name, .used=expr, .used_in=used_in, .declared=declared, .declared_in=declared_in, .file=file}: outputs::use_before_def::UseBeforeDef)] :- __Prefix_1[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span))], inputs::NameRef[(inputs::NameRef{.expr_id=(callee: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdClass{.class=(class: ast::ClassId)}: ast::AnyId))}: name_in_scope::NameInScope)], inputs::Class[(inputs::Class{.id=(class: ast::ClassId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(_: internment::Intern<string>), .span=(declared_in: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(decl_scope: ast::ScopeId), .exported=(_: bool)}: inputs::Class)], ((decl_scope != used_scope) and (used_in < declared_in)).".to_string(),
                                                          arr: ( Relations::__Prefix_1 as RelId, 1),
                                                          xform: XFormArrangement::Join{
                                                                     description: "__Prefix_1[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span))], inputs::NameRef[(inputs::NameRef{.expr_id=(callee: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)]".to_string(),
                                                                     ffun: None,
                                                                     arrangement: (Relations::inputs_NameRef as RelId,1),
                                                                     jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                     {
                                                                         let (ref file, ref config, ref expr, ref object, ref used_scope, ref used_in) = match *<::types::ddlog_std::tuple6<::types::ast::FileId, ::types::config::Config, ::types::ast::ExprId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span>>::from_ddvalue_ref(__v1) {
                                                                             ::types::ddlog_std::tuple6(ref file, ref config, ref expr, ref object, ref used_scope, ref used_in) => ((*file).clone(), (*config).clone(), (*expr).clone(), (*object).clone(), (*used_scope).clone(), (*used_in).clone()),
                                                                             _ => return None
                                                                         };
                                                                         let (ref callee, ref name) = match *<::types::inputs::NameRef>::from_ddvalue_ref(__v2) {
                                                                             ::types::inputs::NameRef{expr_id: ref callee, file: _, value: ref name} => ((*callee).clone(), (*name).clone()),
                                                                             _ => return None
                                                                         };
                                                                         Some((::types::ddlog_std::tuple5((*file).clone(), (*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone())).into_ddvalue())
                                                                     }
                                                                     __f},
                                                                     next: Box::new(Some(XFormCollection::Arrange {
                                                                                             description: "arrange __Prefix_1[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span))], inputs::NameRef[(inputs::NameRef{.expr_id=(callee: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)] by (file, name, used_scope)" .to_string(),
                                                                                             afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                             {
                                                                                                 let ::types::ddlog_std::tuple5(ref file, ref expr, ref used_scope, ref used_in, ref name) = *<::types::ddlog_std::tuple5<::types::ast::FileId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span, ::types::internment::Intern<String>>>::from_ddvalue_ref( &__v );
                                                                                                 Some(((::types::ddlog_std::tuple3((*file).clone(), (*name).clone(), (*used_scope).clone())).into_ddvalue(), (::types::ddlog_std::tuple5((*file).clone(), (*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone())).into_ddvalue()))
                                                                                             }
                                                                                             __f},
                                                                                             next: Box::new(XFormArrangement::Join{
                                                                                                                description: "__Prefix_1[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span))], inputs::NameRef[(inputs::NameRef{.expr_id=(callee: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdClass{.class=(class: ast::ClassId)}: ast::AnyId))}: name_in_scope::NameInScope)]".to_string(),
                                                                                                                ffun: None,
                                                                                                                arrangement: (Relations::name_in_scope_NameInScope as RelId,4),
                                                                                                                jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                {
                                                                                                                    let ::types::ddlog_std::tuple5(ref file, ref expr, ref used_scope, ref used_in, ref name) = *<::types::ddlog_std::tuple5<::types::ast::FileId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span, ::types::internment::Intern<String>>>::from_ddvalue_ref( __v1 );
                                                                                                                    let (ref declared, ref class) = match *<::types::name_in_scope::NameInScope>::from_ddvalue_ref(__v2) {
                                                                                                                        ::types::name_in_scope::NameInScope{file: _, name: _, scope: _, declared: ref declared} => match declared {
                                                                                                                                                                                                                       ::types::ast::AnyId::AnyIdClass{class: ref class} => ((*declared).clone(), (*class).clone()),
                                                                                                                                                                                                                       _ => return None
                                                                                                                                                                                                                   },
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    Some((::types::ddlog_std::tuple7((*file).clone(), (*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone(), (*declared).clone(), (*class).clone())).into_ddvalue())
                                                                                                                }
                                                                                                                __f},
                                                                                                                next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                        description: "arrange __Prefix_1[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span))], inputs::NameRef[(inputs::NameRef{.expr_id=(callee: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdClass{.class=(class: ast::ClassId)}: ast::AnyId))}: name_in_scope::NameInScope)] by (class, file)" .to_string(),
                                                                                                                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                        {
                                                                                                                                            let ::types::ddlog_std::tuple7(ref file, ref expr, ref used_scope, ref used_in, ref name, ref declared, ref class) = *<::types::ddlog_std::tuple7<::types::ast::FileId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span, ::types::internment::Intern<String>, ::types::ast::AnyId, ::types::ast::ClassId>>::from_ddvalue_ref( &__v );
                                                                                                                                            Some(((::types::ddlog_std::tuple2((*class).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple6((*file).clone(), (*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone(), (*declared).clone())).into_ddvalue()))
                                                                                                                                        }
                                                                                                                                        __f},
                                                                                                                                        next: Box::new(XFormArrangement::Join{
                                                                                                                                                           description: "__Prefix_1[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span))], inputs::NameRef[(inputs::NameRef{.expr_id=(callee: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdClass{.class=(class: ast::ClassId)}: ast::AnyId))}: name_in_scope::NameInScope)], inputs::Class[(inputs::Class{.id=(class: ast::ClassId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(_: internment::Intern<string>), .span=(declared_in: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(decl_scope: ast::ScopeId), .exported=(_: bool)}: inputs::Class)]".to_string(),
                                                                                                                                                           ffun: None,
                                                                                                                                                           arrangement: (Relations::inputs_Class as RelId,0),
                                                                                                                                                           jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                           {
                                                                                                                                                               let ::types::ddlog_std::tuple6(ref file, ref expr, ref used_scope, ref used_in, ref name, ref declared) = *<::types::ddlog_std::tuple6<::types::ast::FileId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span, ::types::internment::Intern<String>, ::types::ast::AnyId>>::from_ddvalue_ref( __v1 );
                                                                                                                                                               let (ref declared_in, ref decl_scope) = match *<::types::inputs::Class>::from_ddvalue_ref(__v2) {
                                                                                                                                                                   ::types::inputs::Class{id: _, file: _, name: ::types::ddlog_std::Option::Some{x: ::types::ast::Spanned{data: _, span: ref declared_in}}, parent: _, elements: _, scope: ref decl_scope, exported: _} => ((*declared_in).clone(), (*decl_scope).clone()),
                                                                                                                                                                   _ => return None
                                                                                                                                                               };
                                                                                                                                                               if !(((&*decl_scope) != (&*used_scope)) && ((&*used_in) < (&*declared_in))) {return None;};
                                                                                                                                                               Some(((::types::outputs::use_before_def::UseBeforeDef{name: (*name).clone(), used: (*expr).clone(), used_in: (*used_in).clone(), declared: (*declared).clone(), declared_in: (*declared_in).clone(), file: (*file).clone()})).into_ddvalue())
                                                                                                                                                           }
                                                                                                                                                           __f},
                                                                                                                                                           next: Box::new(None)
                                                                                                                                                       })
                                                                                                                                    }))
                                                                                                            })
                                                                                         }))
                                                                 }
                                                      },
                                                      /* outputs::use_before_def::UseBeforeDef[(outputs::use_before_def::UseBeforeDef{.name=name, .used=expr, .used_in=used_in, .declared=declared, .declared_in=declared_in, .file=file}: outputs::use_before_def::UseBeforeDef)] :- __Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::Call[(inputs::Call{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .callee=(ddlog_std::Some{.x=(callee: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::Call)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(used_scope: ast::ScopeId), .span=(used_in: ast::Span)}: inputs::Expression)], inputs::NameRef[(inputs::NameRef{.expr_id=(callee: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdFunc{.func=(func: ast::FuncId)}: ast::AnyId))}: name_in_scope::NameInScope)], inputs::Function[(inputs::Function{.id=(func: ast::FuncId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(_: internment::Intern<string>), .span=(declared_in: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(decl_scope: ast::ScopeId), .body=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Function)], ((decl_scope != used_scope) and (used_in < declared_in)). */
                                                      Rule::ArrangementRule {
                                                          description: "outputs::use_before_def::UseBeforeDef[(outputs::use_before_def::UseBeforeDef{.name=name, .used=expr, .used_in=used_in, .declared=declared, .declared_in=declared_in, .file=file}: outputs::use_before_def::UseBeforeDef)] :- __Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::Call[(inputs::Call{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .callee=(ddlog_std::Some{.x=(callee: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::Call)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(used_scope: ast::ScopeId), .span=(used_in: ast::Span)}: inputs::Expression)], inputs::NameRef[(inputs::NameRef{.expr_id=(callee: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdFunc{.func=(func: ast::FuncId)}: ast::AnyId))}: name_in_scope::NameInScope)], inputs::Function[(inputs::Function{.id=(func: ast::FuncId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(_: internment::Intern<string>), .span=(declared_in: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(decl_scope: ast::ScopeId), .body=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Function)], ((decl_scope != used_scope) and (used_in < declared_in)).".to_string(),
                                                          arr: ( Relations::__Prefix_7 as RelId, 0),
                                                          xform: XFormArrangement::Join{
                                                                     description: "__Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::Call[(inputs::Call{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .callee=(ddlog_std::Some{.x=(callee: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::Call)]".to_string(),
                                                                     ffun: None,
                                                                     arrangement: (Relations::inputs_Call as RelId,0),
                                                                     jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                     {
                                                                         let (ref file, ref config) = match *<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue_ref(__v1) {
                                                                             ::types::ddlog_std::tuple2(ref file, ref config) => ((*file).clone(), (*config).clone()),
                                                                             _ => return None
                                                                         };
                                                                         let (ref expr, ref callee) = match *<::types::inputs::Call>::from_ddvalue_ref(__v2) {
                                                                             ::types::inputs::Call{expr_id: ref expr, file: _, callee: ::types::ddlog_std::Option::Some{x: ref callee}, args: _} => ((*expr).clone(), (*callee).clone()),
                                                                             _ => return None
                                                                         };
                                                                         Some((::types::ddlog_std::tuple3((*file).clone(), (*expr).clone(), (*callee).clone())).into_ddvalue())
                                                                     }
                                                                     __f},
                                                                     next: Box::new(Some(XFormCollection::Arrange {
                                                                                             description: "arrange __Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::Call[(inputs::Call{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .callee=(ddlog_std::Some{.x=(callee: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::Call)] by (expr, file)" .to_string(),
                                                                                             afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                             {
                                                                                                 let ::types::ddlog_std::tuple3(ref file, ref expr, ref callee) = *<::types::ddlog_std::tuple3<::types::ast::FileId, ::types::ast::ExprId, ::types::ast::ExprId>>::from_ddvalue_ref( &__v );
                                                                                                 Some(((::types::ddlog_std::tuple2((*expr).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple3((*file).clone(), (*expr).clone(), (*callee).clone())).into_ddvalue()))
                                                                                             }
                                                                                             __f},
                                                                                             next: Box::new(XFormArrangement::Join{
                                                                                                                description: "__Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::Call[(inputs::Call{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .callee=(ddlog_std::Some{.x=(callee: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::Call)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(used_scope: ast::ScopeId), .span=(used_in: ast::Span)}: inputs::Expression)]".to_string(),
                                                                                                                ffun: None,
                                                                                                                arrangement: (Relations::inputs_Expression as RelId,0),
                                                                                                                jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                {
                                                                                                                    let ::types::ddlog_std::tuple3(ref file, ref expr, ref callee) = *<::types::ddlog_std::tuple3<::types::ast::FileId, ::types::ast::ExprId, ::types::ast::ExprId>>::from_ddvalue_ref( __v1 );
                                                                                                                    let (ref used_scope, ref used_in) = match *<::types::inputs::Expression>::from_ddvalue_ref(__v2) {
                                                                                                                        ::types::inputs::Expression{id: _, file: _, kind: _, scope: ref used_scope, span: ref used_in} => ((*used_scope).clone(), (*used_in).clone()),
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    Some((::types::ddlog_std::tuple5((*file).clone(), (*expr).clone(), (*callee).clone(), (*used_scope).clone(), (*used_in).clone())).into_ddvalue())
                                                                                                                }
                                                                                                                __f},
                                                                                                                next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                        description: "arrange __Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::Call[(inputs::Call{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .callee=(ddlog_std::Some{.x=(callee: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::Call)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(used_scope: ast::ScopeId), .span=(used_in: ast::Span)}: inputs::Expression)] by (callee, file)" .to_string(),
                                                                                                                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                        {
                                                                                                                                            let ::types::ddlog_std::tuple5(ref file, ref expr, ref callee, ref used_scope, ref used_in) = *<::types::ddlog_std::tuple5<::types::ast::FileId, ::types::ast::ExprId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                            Some(((::types::ddlog_std::tuple2((*callee).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple4((*file).clone(), (*expr).clone(), (*used_scope).clone(), (*used_in).clone())).into_ddvalue()))
                                                                                                                                        }
                                                                                                                                        __f},
                                                                                                                                        next: Box::new(XFormArrangement::Join{
                                                                                                                                                           description: "__Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::Call[(inputs::Call{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .callee=(ddlog_std::Some{.x=(callee: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::Call)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(used_scope: ast::ScopeId), .span=(used_in: ast::Span)}: inputs::Expression)], inputs::NameRef[(inputs::NameRef{.expr_id=(callee: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)]".to_string(),
                                                                                                                                                           ffun: None,
                                                                                                                                                           arrangement: (Relations::inputs_NameRef as RelId,0),
                                                                                                                                                           jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                           {
                                                                                                                                                               let ::types::ddlog_std::tuple4(ref file, ref expr, ref used_scope, ref used_in) = *<::types::ddlog_std::tuple4<::types::ast::FileId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span>>::from_ddvalue_ref( __v1 );
                                                                                                                                                               let ref name = match *<::types::inputs::NameRef>::from_ddvalue_ref(__v2) {
                                                                                                                                                                   ::types::inputs::NameRef{expr_id: _, file: _, value: ref name} => (*name).clone(),
                                                                                                                                                                   _ => return None
                                                                                                                                                               };
                                                                                                                                                               Some((::types::ddlog_std::tuple5((*file).clone(), (*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone())).into_ddvalue())
                                                                                                                                                           }
                                                                                                                                                           __f},
                                                                                                                                                           next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                   description: "arrange __Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::Call[(inputs::Call{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .callee=(ddlog_std::Some{.x=(callee: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::Call)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(used_scope: ast::ScopeId), .span=(used_in: ast::Span)}: inputs::Expression)], inputs::NameRef[(inputs::NameRef{.expr_id=(callee: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)] by (file, name, used_scope)" .to_string(),
                                                                                                                                                                                   afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                                   {
                                                                                                                                                                                       let ::types::ddlog_std::tuple5(ref file, ref expr, ref used_scope, ref used_in, ref name) = *<::types::ddlog_std::tuple5<::types::ast::FileId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span, ::types::internment::Intern<String>>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                       Some(((::types::ddlog_std::tuple3((*file).clone(), (*name).clone(), (*used_scope).clone())).into_ddvalue(), (::types::ddlog_std::tuple5((*file).clone(), (*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone())).into_ddvalue()))
                                                                                                                                                                                   }
                                                                                                                                                                                   __f},
                                                                                                                                                                                   next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                      description: "__Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::Call[(inputs::Call{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .callee=(ddlog_std::Some{.x=(callee: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::Call)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(used_scope: ast::ScopeId), .span=(used_in: ast::Span)}: inputs::Expression)], inputs::NameRef[(inputs::NameRef{.expr_id=(callee: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdFunc{.func=(func: ast::FuncId)}: ast::AnyId))}: name_in_scope::NameInScope)]".to_string(),
                                                                                                                                                                                                      ffun: None,
                                                                                                                                                                                                      arrangement: (Relations::name_in_scope_NameInScope as RelId,5),
                                                                                                                                                                                                      jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                                                                      {
                                                                                                                                                                                                          let ::types::ddlog_std::tuple5(ref file, ref expr, ref used_scope, ref used_in, ref name) = *<::types::ddlog_std::tuple5<::types::ast::FileId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span, ::types::internment::Intern<String>>>::from_ddvalue_ref( __v1 );
                                                                                                                                                                                                          let (ref declared, ref func) = match *<::types::name_in_scope::NameInScope>::from_ddvalue_ref(__v2) {
                                                                                                                                                                                                              ::types::name_in_scope::NameInScope{file: _, name: _, scope: _, declared: ref declared} => match declared {
                                                                                                                                                                                                                                                                                                             ::types::ast::AnyId::AnyIdFunc{func: ref func} => ((*declared).clone(), (*func).clone()),
                                                                                                                                                                                                                                                                                                             _ => return None
                                                                                                                                                                                                                                                                                                         },
                                                                                                                                                                                                              _ => return None
                                                                                                                                                                                                          };
                                                                                                                                                                                                          Some((::types::ddlog_std::tuple7((*file).clone(), (*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone(), (*declared).clone(), (*func).clone())).into_ddvalue())
                                                                                                                                                                                                      }
                                                                                                                                                                                                      __f},
                                                                                                                                                                                                      next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                                              description: "arrange __Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::Call[(inputs::Call{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .callee=(ddlog_std::Some{.x=(callee: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::Call)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(used_scope: ast::ScopeId), .span=(used_in: ast::Span)}: inputs::Expression)], inputs::NameRef[(inputs::NameRef{.expr_id=(callee: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdFunc{.func=(func: ast::FuncId)}: ast::AnyId))}: name_in_scope::NameInScope)] by (func, file)" .to_string(),
                                                                                                                                                                                                                              afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                  let ::types::ddlog_std::tuple7(ref file, ref expr, ref used_scope, ref used_in, ref name, ref declared, ref func) = *<::types::ddlog_std::tuple7<::types::ast::FileId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span, ::types::internment::Intern<String>, ::types::ast::AnyId, ::types::ast::FuncId>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                                                                  Some(((::types::ddlog_std::tuple2((*func).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple6((*file).clone(), (*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone(), (*declared).clone())).into_ddvalue()))
                                                                                                                                                                                                                              }
                                                                                                                                                                                                                              __f},
                                                                                                                                                                                                                              next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                                                                 description: "__Prefix_7[((file: ast::FileId), (config: config::Config))], inputs::Call[(inputs::Call{.expr_id=(expr: ast::ExprId), .file=(file: ast::FileId), .callee=(ddlog_std::Some{.x=(callee: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .args=(_: ddlog_std::Option<ddlog_std::Vec<ast::ExprId>>)}: inputs::Call)], inputs::Expression[(inputs::Expression{.id=(expr: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(used_scope: ast::ScopeId), .span=(used_in: ast::Span)}: inputs::Expression)], inputs::NameRef[(inputs::NameRef{.expr_id=(callee: ast::ExprId), .file=(file: ast::FileId), .value=(name: internment::Intern<string>)}: inputs::NameRef)], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdFunc{.func=(func: ast::FuncId)}: ast::AnyId))}: name_in_scope::NameInScope)], inputs::Function[(inputs::Function{.id=(func: ast::FuncId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(_: internment::Intern<string>), .span=(declared_in: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(decl_scope: ast::ScopeId), .body=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Function)]".to_string(),
                                                                                                                                                                                                                                                 ffun: None,
                                                                                                                                                                                                                                                 arrangement: (Relations::inputs_Function as RelId,0),
                                                                                                                                                                                                                                                 jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                     let ::types::ddlog_std::tuple6(ref file, ref expr, ref used_scope, ref used_in, ref name, ref declared) = *<::types::ddlog_std::tuple6<::types::ast::FileId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span, ::types::internment::Intern<String>, ::types::ast::AnyId>>::from_ddvalue_ref( __v1 );
                                                                                                                                                                                                                                                     let (ref declared_in, ref decl_scope) = match *<::types::inputs::Function>::from_ddvalue_ref(__v2) {
                                                                                                                                                                                                                                                         ::types::inputs::Function{id: _, file: _, name: ::types::ddlog_std::Option::Some{x: ::types::ast::Spanned{data: _, span: ref declared_in}}, scope: ref decl_scope, body: _, exported: _} => ((*declared_in).clone(), (*decl_scope).clone()),
                                                                                                                                                                                                                                                         _ => return None
                                                                                                                                                                                                                                                     };
                                                                                                                                                                                                                                                     if !(((&*decl_scope) != (&*used_scope)) && ((&*used_in) < (&*declared_in))) {return None;};
                                                                                                                                                                                                                                                     Some(((::types::outputs::use_before_def::UseBeforeDef{name: (*name).clone(), used: (*expr).clone(), used_in: (*used_in).clone(), declared: (*declared).clone(), declared_in: (*declared_in).clone(), file: (*file).clone()})).into_ddvalue())
                                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                                                 __f},
                                                                                                                                                                                                                                                 next: Box::new(None)
                                                                                                                                                                                                                                             })
                                                                                                                                                                                                                          }))
                                                                                                                                                                                                  })
                                                                                                                                                                               }))
                                                                                                                                                       })
                                                                                                                                    }))
                                                                                                            })
                                                                                         }))
                                                                 }
                                                      },
                                                      /* outputs::use_before_def::UseBeforeDef[(outputs::use_before_def::UseBeforeDef{.name=name, .used=expr, .used_in=used_in, .declared=declared, .declared_in=declared_in, .file=file}: outputs::use_before_def::UseBeforeDef)] :- __Prefix_0[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span), (name: internment::Intern<string>))], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdStmt{.stmt=(decl: ast::StmtId)}: ast::AnyId))}: name_in_scope::NameInScope)], variable_decl::VariableDecl[(variable_decl::VariableDecl{.stmt=(decl: ast::StmtId), .file=(file: ast::FileId), .kind=(_: variable_decl::VariableDeclKind), .pattern=(_: ddlog_std::Option<ast::IPattern>), .value=(ddlog_std::Some{.x=(class: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: variable_decl::VariableDecl)], inputs::ClassExpr[(inputs::ClassExpr{.expr_id=(class: ast::ExprId), .file=(file: ast::FileId), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>)}: inputs::ClassExpr)], inputs::Expression[(inputs::Expression{.id=(class: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(decl_scope: ast::ScopeId), .span=(declared_in: ast::Span)}: inputs::Expression)], ((decl_scope != used_scope) and (used_in < declared_in)). */
                                                      Rule::ArrangementRule {
                                                          description: "outputs::use_before_def::UseBeforeDef[(outputs::use_before_def::UseBeforeDef{.name=name, .used=expr, .used_in=used_in, .declared=declared, .declared_in=declared_in, .file=file}: outputs::use_before_def::UseBeforeDef)] :- __Prefix_0[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span), (name: internment::Intern<string>))], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdStmt{.stmt=(decl: ast::StmtId)}: ast::AnyId))}: name_in_scope::NameInScope)], variable_decl::VariableDecl[(variable_decl::VariableDecl{.stmt=(decl: ast::StmtId), .file=(file: ast::FileId), .kind=(_: variable_decl::VariableDeclKind), .pattern=(_: ddlog_std::Option<ast::IPattern>), .value=(ddlog_std::Some{.x=(class: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: variable_decl::VariableDecl)], inputs::ClassExpr[(inputs::ClassExpr{.expr_id=(class: ast::ExprId), .file=(file: ast::FileId), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>)}: inputs::ClassExpr)], inputs::Expression[(inputs::Expression{.id=(class: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(decl_scope: ast::ScopeId), .span=(declared_in: ast::Span)}: inputs::Expression)], ((decl_scope != used_scope) and (used_in < declared_in)).".to_string(),
                                                          arr: ( Relations::__Prefix_0 as RelId, 0),
                                                          xform: XFormArrangement::Join{
                                                                     description: "__Prefix_0[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span), (name: internment::Intern<string>))], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdStmt{.stmt=(decl: ast::StmtId)}: ast::AnyId))}: name_in_scope::NameInScope)]".to_string(),
                                                                     ffun: None,
                                                                     arrangement: (Relations::name_in_scope_NameInScope as RelId,3),
                                                                     jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                     {
                                                                         let (ref file, ref config, ref expr, ref object, ref used_scope, ref used_in, ref name) = match *<::types::ddlog_std::tuple7<::types::ast::FileId, ::types::config::Config, ::types::ast::ExprId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span, ::types::internment::Intern<String>>>::from_ddvalue_ref(__v1) {
                                                                             ::types::ddlog_std::tuple7(ref file, ref config, ref expr, ref object, ref used_scope, ref used_in, ref name) => ((*file).clone(), (*config).clone(), (*expr).clone(), (*object).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone()),
                                                                             _ => return None
                                                                         };
                                                                         let (ref declared, ref decl) = match *<::types::name_in_scope::NameInScope>::from_ddvalue_ref(__v2) {
                                                                             ::types::name_in_scope::NameInScope{file: _, name: _, scope: _, declared: ref declared} => match declared {
                                                                                                                                                                            ::types::ast::AnyId::AnyIdStmt{stmt: ref decl} => ((*declared).clone(), (*decl).clone()),
                                                                                                                                                                            _ => return None
                                                                                                                                                                        },
                                                                             _ => return None
                                                                         };
                                                                         Some((::types::ddlog_std::tuple7((*file).clone(), (*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone(), (*declared).clone(), (*decl).clone())).into_ddvalue())
                                                                     }
                                                                     __f},
                                                                     next: Box::new(Some(XFormCollection::Arrange {
                                                                                             description: "arrange __Prefix_0[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span), (name: internment::Intern<string>))], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdStmt{.stmt=(decl: ast::StmtId)}: ast::AnyId))}: name_in_scope::NameInScope)] by (decl, file)" .to_string(),
                                                                                             afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                             {
                                                                                                 let ::types::ddlog_std::tuple7(ref file, ref expr, ref used_scope, ref used_in, ref name, ref declared, ref decl) = *<::types::ddlog_std::tuple7<::types::ast::FileId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span, ::types::internment::Intern<String>, ::types::ast::AnyId, ::types::ast::StmtId>>::from_ddvalue_ref( &__v );
                                                                                                 Some(((::types::ddlog_std::tuple2((*decl).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple6((*file).clone(), (*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone(), (*declared).clone())).into_ddvalue()))
                                                                                             }
                                                                                             __f},
                                                                                             next: Box::new(XFormArrangement::Join{
                                                                                                                description: "__Prefix_0[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span), (name: internment::Intern<string>))], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdStmt{.stmt=(decl: ast::StmtId)}: ast::AnyId))}: name_in_scope::NameInScope)], variable_decl::VariableDecl[(variable_decl::VariableDecl{.stmt=(decl: ast::StmtId), .file=(file: ast::FileId), .kind=(_: variable_decl::VariableDeclKind), .pattern=(_: ddlog_std::Option<ast::IPattern>), .value=(ddlog_std::Some{.x=(class: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: variable_decl::VariableDecl)]".to_string(),
                                                                                                                ffun: None,
                                                                                                                arrangement: (Relations::variable_decl_VariableDecl as RelId,0),
                                                                                                                jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                {
                                                                                                                    let ::types::ddlog_std::tuple6(ref file, ref expr, ref used_scope, ref used_in, ref name, ref declared) = *<::types::ddlog_std::tuple6<::types::ast::FileId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span, ::types::internment::Intern<String>, ::types::ast::AnyId>>::from_ddvalue_ref( __v1 );
                                                                                                                    let ref class = match *<::types::variable_decl::VariableDecl>::from_ddvalue_ref(__v2) {
                                                                                                                        ::types::variable_decl::VariableDecl{stmt: _, file: _, kind: _, pattern: _, value: ::types::ddlog_std::Option::Some{x: ref class}, exported: _} => (*class).clone(),
                                                                                                                        _ => return None
                                                                                                                    };
                                                                                                                    Some((::types::ddlog_std::tuple7((*file).clone(), (*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone(), (*declared).clone(), (*class).clone())).into_ddvalue())
                                                                                                                }
                                                                                                                __f},
                                                                                                                next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                        description: "arrange __Prefix_0[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span), (name: internment::Intern<string>))], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdStmt{.stmt=(decl: ast::StmtId)}: ast::AnyId))}: name_in_scope::NameInScope)], variable_decl::VariableDecl[(variable_decl::VariableDecl{.stmt=(decl: ast::StmtId), .file=(file: ast::FileId), .kind=(_: variable_decl::VariableDeclKind), .pattern=(_: ddlog_std::Option<ast::IPattern>), .value=(ddlog_std::Some{.x=(class: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: variable_decl::VariableDecl)] by (class, file)" .to_string(),
                                                                                                                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                        {
                                                                                                                                            let ::types::ddlog_std::tuple7(ref file, ref expr, ref used_scope, ref used_in, ref name, ref declared, ref class) = *<::types::ddlog_std::tuple7<::types::ast::FileId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span, ::types::internment::Intern<String>, ::types::ast::AnyId, ::types::ast::ExprId>>::from_ddvalue_ref( &__v );
                                                                                                                                            Some(((::types::ddlog_std::tuple2((*class).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple7((*file).clone(), (*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone(), (*declared).clone(), (*class).clone())).into_ddvalue()))
                                                                                                                                        }
                                                                                                                                        __f},
                                                                                                                                        next: Box::new(XFormArrangement::Semijoin{
                                                                                                                                                           description: "__Prefix_0[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span), (name: internment::Intern<string>))], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdStmt{.stmt=(decl: ast::StmtId)}: ast::AnyId))}: name_in_scope::NameInScope)], variable_decl::VariableDecl[(variable_decl::VariableDecl{.stmt=(decl: ast::StmtId), .file=(file: ast::FileId), .kind=(_: variable_decl::VariableDeclKind), .pattern=(_: ddlog_std::Option<ast::IPattern>), .value=(ddlog_std::Some{.x=(class: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: variable_decl::VariableDecl)], inputs::ClassExpr[(inputs::ClassExpr{.expr_id=(class: ast::ExprId), .file=(file: ast::FileId), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>)}: inputs::ClassExpr)]".to_string(),
                                                                                                                                                           ffun: None,
                                                                                                                                                           arrangement: (Relations::inputs_ClassExpr as RelId,0),
                                                                                                                                                           jfun: {fn __f(_: &DDValue ,__v1: &DDValue,___v2: &()) -> Option<DDValue>
                                                                                                                                                           {
                                                                                                                                                               let ::types::ddlog_std::tuple7(ref file, ref expr, ref used_scope, ref used_in, ref name, ref declared, ref class) = *<::types::ddlog_std::tuple7<::types::ast::FileId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span, ::types::internment::Intern<String>, ::types::ast::AnyId, ::types::ast::ExprId>>::from_ddvalue_ref( __v1 );
                                                                                                                                                               Some((::types::ddlog_std::tuple7((*file).clone(), (*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone(), (*declared).clone(), (*class).clone())).into_ddvalue())
                                                                                                                                                           }
                                                                                                                                                           __f},
                                                                                                                                                           next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                   description: "arrange __Prefix_0[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span), (name: internment::Intern<string>))], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdStmt{.stmt=(decl: ast::StmtId)}: ast::AnyId))}: name_in_scope::NameInScope)], variable_decl::VariableDecl[(variable_decl::VariableDecl{.stmt=(decl: ast::StmtId), .file=(file: ast::FileId), .kind=(_: variable_decl::VariableDeclKind), .pattern=(_: ddlog_std::Option<ast::IPattern>), .value=(ddlog_std::Some{.x=(class: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: variable_decl::VariableDecl)], inputs::ClassExpr[(inputs::ClassExpr{.expr_id=(class: ast::ExprId), .file=(file: ast::FileId), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>)}: inputs::ClassExpr)] by (class, file)" .to_string(),
                                                                                                                                                                                   afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                                   {
                                                                                                                                                                                       let ::types::ddlog_std::tuple7(ref file, ref expr, ref used_scope, ref used_in, ref name, ref declared, ref class) = *<::types::ddlog_std::tuple7<::types::ast::FileId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span, ::types::internment::Intern<String>, ::types::ast::AnyId, ::types::ast::ExprId>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                       Some(((::types::ddlog_std::tuple2((*class).clone(), (*file).clone())).into_ddvalue(), (::types::ddlog_std::tuple6((*file).clone(), (*expr).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone(), (*declared).clone())).into_ddvalue()))
                                                                                                                                                                                   }
                                                                                                                                                                                   __f},
                                                                                                                                                                                   next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                      description: "__Prefix_0[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span), (name: internment::Intern<string>))], name_in_scope::NameInScope[(name_in_scope::NameInScope{.file=(file: ast::FileId), .name=(name: internment::Intern<string>), .scope=(used_scope: ast::ScopeId), .declared=(declared@ (ast::AnyIdStmt{.stmt=(decl: ast::StmtId)}: ast::AnyId))}: name_in_scope::NameInScope)], variable_decl::VariableDecl[(variable_decl::VariableDecl{.stmt=(decl: ast::StmtId), .file=(file: ast::FileId), .kind=(_: variable_decl::VariableDeclKind), .pattern=(_: ddlog_std::Option<ast::IPattern>), .value=(ddlog_std::Some{.x=(class: ast::ExprId)}: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: variable_decl::VariableDecl)], inputs::ClassExpr[(inputs::ClassExpr{.expr_id=(class: ast::ExprId), .file=(file: ast::FileId), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>)}: inputs::ClassExpr)], inputs::Expression[(inputs::Expression{.id=(class: ast::ExprId), .file=(file: ast::FileId), .kind=(_: ast::ExprKind), .scope=(decl_scope: ast::ScopeId), .span=(declared_in: ast::Span)}: inputs::Expression)]".to_string(),
                                                                                                                                                                                                      ffun: None,
                                                                                                                                                                                                      arrangement: (Relations::inputs_Expression as RelId,0),
                                                                                                                                                                                                      jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                                                                      {
                                                                                                                                                                                                          let ::types::ddlog_std::tuple6(ref file, ref expr, ref used_scope, ref used_in, ref name, ref declared) = *<::types::ddlog_std::tuple6<::types::ast::FileId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span, ::types::internment::Intern<String>, ::types::ast::AnyId>>::from_ddvalue_ref( __v1 );
                                                                                                                                                                                                          let (ref decl_scope, ref declared_in) = match *<::types::inputs::Expression>::from_ddvalue_ref(__v2) {
                                                                                                                                                                                                              ::types::inputs::Expression{id: _, file: _, kind: _, scope: ref decl_scope, span: ref declared_in} => ((*decl_scope).clone(), (*declared_in).clone()),
                                                                                                                                                                                                              _ => return None
                                                                                                                                                                                                          };
                                                                                                                                                                                                          if !(((&*decl_scope) != (&*used_scope)) && ((&*used_in) < (&*declared_in))) {return None;};
                                                                                                                                                                                                          Some(((::types::outputs::use_before_def::UseBeforeDef{name: (*name).clone(), used: (*expr).clone(), used_in: (*used_in).clone(), declared: (*declared).clone(), declared_in: (*declared_in).clone(), file: (*file).clone()})).into_ddvalue())
                                                                                                                                                                                                      }
                                                                                                                                                                                                      __f},
                                                                                                                                                                                                      next: Box::new(None)
                                                                                                                                                                                                  })
                                                                                                                                                                               }))
                                                                                                                                                       })
                                                                                                                                    }))
                                                                                                            })
                                                                                         }))
                                                                 }
                                                      },
                                                      /* outputs::use_before_def::UseBeforeDef[(outputs::use_before_def::UseBeforeDef{.name=name, .used=expr, .used_in=used_in, .declared=(ast::AnyIdClass{.class=class}: ast::AnyId), .declared_in=declared_in, .file=file}: outputs::use_before_def::UseBeforeDef)] :- __Prefix_0[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span), (name: internment::Intern<string>))], inputs::Class[(inputs::Class{.id=(class: ast::ClassId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(declared_in: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(declared_scope: ast::ScopeId), .exported=(_: bool)}: inputs::Class)], ((declared_scope != used_scope) and (used_in < declared_in)). */
                                                      Rule::ArrangementRule {
                                                          description: "outputs::use_before_def::UseBeforeDef[(outputs::use_before_def::UseBeforeDef{.name=name, .used=expr, .used_in=used_in, .declared=(ast::AnyIdClass{.class=class}: ast::AnyId), .declared_in=declared_in, .file=file}: outputs::use_before_def::UseBeforeDef)] :- __Prefix_0[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span), (name: internment::Intern<string>))], inputs::Class[(inputs::Class{.id=(class: ast::ClassId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(declared_in: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(declared_scope: ast::ScopeId), .exported=(_: bool)}: inputs::Class)], ((declared_scope != used_scope) and (used_in < declared_in)).".to_string(),
                                                          arr: ( Relations::__Prefix_0 as RelId, 1),
                                                          xform: XFormArrangement::Join{
                                                                     description: "__Prefix_0[((file: ast::FileId), (config: config::Config), (expr: ast::ExprId), (object: ast::ExprId), (used_scope: ast::ScopeId), (used_in: ast::Span), (name: internment::Intern<string>))], inputs::Class[(inputs::Class{.id=(class: ast::ClassId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(ast::Spanned{.data=(name: internment::Intern<string>), .span=(declared_in: ast::Span)}: ast::Spanned<internment::Intern<string>>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .parent=(_: ddlog_std::Option<ast::ExprId>), .elements=(_: ddlog_std::Option<ddlog_std::Vec<ast::IClassElement>>), .scope=(declared_scope: ast::ScopeId), .exported=(_: bool)}: inputs::Class)]".to_string(),
                                                                     ffun: None,
                                                                     arrangement: (Relations::inputs_Class as RelId,1),
                                                                     jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                     {
                                                                         let (ref file, ref config, ref expr, ref object, ref used_scope, ref used_in, ref name) = match *<::types::ddlog_std::tuple7<::types::ast::FileId, ::types::config::Config, ::types::ast::ExprId, ::types::ast::ExprId, ::types::ast::ScopeId, ::types::ast::Span, ::types::internment::Intern<String>>>::from_ddvalue_ref(__v1) {
                                                                             ::types::ddlog_std::tuple7(ref file, ref config, ref expr, ref object, ref used_scope, ref used_in, ref name) => ((*file).clone(), (*config).clone(), (*expr).clone(), (*object).clone(), (*used_scope).clone(), (*used_in).clone(), (*name).clone()),
                                                                             _ => return None
                                                                         };
                                                                         let (ref class, ref declared_in, ref declared_scope) = match *<::types::inputs::Class>::from_ddvalue_ref(__v2) {
                                                                             ::types::inputs::Class{id: ref class, file: _, name: ::types::ddlog_std::Option::Some{x: ::types::ast::Spanned{data: _, span: ref declared_in}}, parent: _, elements: _, scope: ref declared_scope, exported: _} => ((*class).clone(), (*declared_in).clone(), (*declared_scope).clone()),
                                                                             _ => return None
                                                                         };
                                                                         if !(((&*declared_scope) != (&*used_scope)) && ((&*used_in) < (&*declared_in))) {return None;};
                                                                         Some(((::types::outputs::use_before_def::UseBeforeDef{name: (*name).clone(), used: (*expr).clone(), used_in: (*used_in).clone(), declared: (::types::ast::AnyId::AnyIdClass{class: (*class).clone()}), declared_in: (*declared_in).clone(), file: (*file).clone()})).into_ddvalue())
                                                                     }
                                                                     __f},
                                                                     next: Box::new(None)
                                                                 }
                                                      }],
                                                  arrangements: vec![
                                                      ],
                                                  change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
                                              };
    let scopes_IsHoistable = Relation {
                                 name:         "scopes::IsHoistable".to_string(),
                                 input:        false,
                                 distinct:     false,
                                 caching_mode: CachingMode::Set,
                                 key_func:     None,
                                 id:           Relations::scopes_IsHoistable as RelId,
                                 rules:        vec![
                                     /* scopes::IsHoistable[(scopes::IsHoistable{.file=file, .id=(ast::AnyIdFunc{.func=id}: ast::AnyId), .hoistable=true}: scopes::IsHoistable)] :- inputs::Function[(inputs::Function{.id=(id: ast::FuncId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(_: ast::ScopeId), .body=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Function)]. */
                                     Rule::CollectionRule {
                                         description: "scopes::IsHoistable[(scopes::IsHoistable{.file=file, .id=(ast::AnyIdFunc{.func=id}: ast::AnyId), .hoistable=true}: scopes::IsHoistable)] :- inputs::Function[(inputs::Function{.id=(id: ast::FuncId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(_: ast::ScopeId), .body=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Function)].".to_string(),
                                         rel: Relations::inputs_Function as RelId,
                                         xform: Some(XFormCollection::FilterMap{
                                                         description: "head of scopes::IsHoistable[(scopes::IsHoistable{.file=file, .id=(ast::AnyIdFunc{.func=id}: ast::AnyId), .hoistable=true}: scopes::IsHoistable)] :- inputs::Function[(inputs::Function{.id=(id: ast::FuncId), .file=(file: ast::FileId), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(_: ast::ScopeId), .body=(_: ast::ScopeId), .exported=(_: bool)}: inputs::Function)]." .to_string(),
                                                         fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                         {
                                                             let (ref id, ref file) = match *<::types::inputs::Function>::from_ddvalue_ref(&__v) {
                                                                 ::types::inputs::Function{id: ref id, file: ref file, name: _, scope: _, body: _, exported: _} => ((*id).clone(), (*file).clone()),
                                                                 _ => return None
                                                             };
                                                             Some(((::types::scopes::IsHoistable{file: (*file).clone(), id: (::types::ast::AnyId::AnyIdFunc{func: (*id).clone()}), hoistable: true})).into_ddvalue())
                                                         }
                                                         __f},
                                                         next: Box::new(None)
                                                     })
                                     },
                                     /* scopes::IsHoistable[(scopes::IsHoistable{.file=file, .id=(ast::AnyIdStmt{.stmt=id}: ast::AnyId), .hoistable=true}: scopes::IsHoistable)] :- inputs::VarDecl[(inputs::VarDecl{.stmt_id=(id: ast::StmtId), .file=(file: ast::FileId), .pattern=(_: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: inputs::VarDecl)]. */
                                     Rule::CollectionRule {
                                         description: "scopes::IsHoistable[(scopes::IsHoistable{.file=file, .id=(ast::AnyIdStmt{.stmt=id}: ast::AnyId), .hoistable=true}: scopes::IsHoistable)] :- inputs::VarDecl[(inputs::VarDecl{.stmt_id=(id: ast::StmtId), .file=(file: ast::FileId), .pattern=(_: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: inputs::VarDecl)].".to_string(),
                                         rel: Relations::inputs_VarDecl as RelId,
                                         xform: Some(XFormCollection::FilterMap{
                                                         description: "head of scopes::IsHoistable[(scopes::IsHoistable{.file=file, .id=(ast::AnyIdStmt{.stmt=id}: ast::AnyId), .hoistable=true}: scopes::IsHoistable)] :- inputs::VarDecl[(inputs::VarDecl{.stmt_id=(id: ast::StmtId), .file=(file: ast::FileId), .pattern=(_: ddlog_std::Option<ast::IPattern>), .value=(_: ddlog_std::Option<ast::ExprId>), .exported=(_: bool)}: inputs::VarDecl)]." .to_string(),
                                                         fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                         {
                                                             let (ref id, ref file) = match *<::types::inputs::VarDecl>::from_ddvalue_ref(&__v) {
                                                                 ::types::inputs::VarDecl{stmt_id: ref id, file: ref file, pattern: _, value: _, exported: _} => ((*id).clone(), (*file).clone()),
                                                                 _ => return None
                                                             };
                                                             Some(((::types::scopes::IsHoistable{file: (*file).clone(), id: (::types::ast::AnyId::AnyIdStmt{stmt: (*id).clone()}), hoistable: true})).into_ddvalue())
                                                         }
                                                         __f},
                                                         next: Box::new(None)
                                                     })
                                     }],
                                 arrangements: vec![
                                     ],
                                 change_cb:    None
                             };
    let inputs_While = Relation {
                           name:         "inputs::While".to_string(),
                           input:        true,
                           distinct:     false,
                           caching_mode: CachingMode::Set,
                           key_func:     None,
                           id:           Relations::inputs_While as RelId,
                           rules:        vec![
                               ],
                           arrangements: vec![
                               ],
                           change_cb:    None
                       };
    let inputs_With = Relation {
                          name:         "inputs::With".to_string(),
                          input:        true,
                          distinct:     false,
                          caching_mode: CachingMode::Set,
                          key_func:     None,
                          id:           Relations::inputs_With as RelId,
                          rules:        vec![
                              ],
                          arrangements: vec![
                              ],
                          change_cb:    None
                      };
    let inputs_Yield = Relation {
                           name:         "inputs::Yield".to_string(),
                           input:        true,
                           distinct:     false,
                           caching_mode: CachingMode::Set,
                           key_func:     None,
                           id:           Relations::inputs_Yield as RelId,
                           rules:        vec![
                               ],
                           arrangements: vec![
                               ],
                           change_cb:    None
                       };
    let scopes_NeedsScopeParents = Relation {
                                       name:         "scopes::NeedsScopeParents".to_string(),
                                       input:        false,
                                       distinct:     false,
                                       caching_mode: CachingMode::Set,
                                       key_func:     None,
                                       id:           Relations::scopes_NeedsScopeParents as RelId,
                                       rules:        vec![
                                           ],
                                       arrangements: vec![
                                           Arrangement::Map{
                                              name: r###"(scopes::NeedsScopeParents{.scope=(_0: ast::ScopeId), .file=(_1: ast::FileId)}: scopes::NeedsScopeParents) /*join*/"###.to_string(),
                                               afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                               {
                                                   let __cloned = __v.clone();
                                                   match < ::types::scopes::NeedsScopeParents>::from_ddvalue(__v) {
                                                       ::types::scopes::NeedsScopeParents{scope: ref _0, file: ref _1} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                       _ => None
                                                   }.map(|x|(x,__cloned))
                                               }
                                               __f},
                                               queryable: false
                                           }],
                                       change_cb:    None
                                   };
    let scopes_ScopeFamily = Relation {
                                 name:         "scopes::ScopeFamily".to_string(),
                                 input:        false,
                                 distinct:     false,
                                 caching_mode: CachingMode::Set,
                                 key_func:     None,
                                 id:           Relations::scopes_ScopeFamily as RelId,
                                 rules:        vec![
                                     /* scopes::ScopeFamily[(scopes::ScopeFamily{.parent=parent, .child=child, .file=file}: scopes::ScopeFamily)] :- scopes::NeedsScopeChildren[(scopes::NeedsScopeChildren{.scope=(parent: ast::ScopeId), .file=(file: ast::FileId)}: scopes::NeedsScopeChildren)], inputs::InputScope[(inputs::InputScope{.parent=(parent: ast::ScopeId), .child=(child: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)], (parent != child). */
                                     Rule::ArrangementRule {
                                         description: "scopes::ScopeFamily[(scopes::ScopeFamily{.parent=parent, .child=child, .file=file}: scopes::ScopeFamily)] :- scopes::NeedsScopeChildren[(scopes::NeedsScopeChildren{.scope=(parent: ast::ScopeId), .file=(file: ast::FileId)}: scopes::NeedsScopeChildren)], inputs::InputScope[(inputs::InputScope{.parent=(parent: ast::ScopeId), .child=(child: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)], (parent != child).".to_string(),
                                         arr: ( Relations::scopes_NeedsScopeChildren as RelId, 0),
                                         xform: XFormArrangement::Join{
                                                    description: "scopes::NeedsScopeChildren[(scopes::NeedsScopeChildren{.scope=(parent: ast::ScopeId), .file=(file: ast::FileId)}: scopes::NeedsScopeChildren)], inputs::InputScope[(inputs::InputScope{.parent=(parent: ast::ScopeId), .child=(child: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)]".to_string(),
                                                    ffun: None,
                                                    arrangement: (Relations::inputs_InputScope as RelId,1),
                                                    jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                    {
                                                        let (ref parent, ref file) = match *<::types::scopes::NeedsScopeChildren>::from_ddvalue_ref(__v1) {
                                                            ::types::scopes::NeedsScopeChildren{scope: ref parent, file: ref file} => ((*parent).clone(), (*file).clone()),
                                                            _ => return None
                                                        };
                                                        let ref child = match *<::types::inputs::InputScope>::from_ddvalue_ref(__v2) {
                                                            ::types::inputs::InputScope{parent: _, child: ref child, file: _} => (*child).clone(),
                                                            _ => return None
                                                        };
                                                        if !((&*parent) != (&*child)) {return None;};
                                                        Some(((::types::scopes::ScopeFamily{parent: (*parent).clone(), child: (*child).clone(), file: (*file).clone()})).into_ddvalue())
                                                    }
                                                    __f},
                                                    next: Box::new(None)
                                                }
                                     },
                                     /* scopes::ScopeFamily[(scopes::ScopeFamily{.parent=parent, .child=child, .file=file}: scopes::ScopeFamily)] :- scopes::NeedsScopeParents[(scopes::NeedsScopeParents{.scope=(child: ast::ScopeId), .file=(file: ast::FileId)}: scopes::NeedsScopeParents)], inputs::InputScope[(inputs::InputScope{.parent=(parent: ast::ScopeId), .child=(child: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)], (parent != child). */
                                     Rule::ArrangementRule {
                                         description: "scopes::ScopeFamily[(scopes::ScopeFamily{.parent=parent, .child=child, .file=file}: scopes::ScopeFamily)] :- scopes::NeedsScopeParents[(scopes::NeedsScopeParents{.scope=(child: ast::ScopeId), .file=(file: ast::FileId)}: scopes::NeedsScopeParents)], inputs::InputScope[(inputs::InputScope{.parent=(parent: ast::ScopeId), .child=(child: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)], (parent != child).".to_string(),
                                         arr: ( Relations::scopes_NeedsScopeParents as RelId, 0),
                                         xform: XFormArrangement::Join{
                                                    description: "scopes::NeedsScopeParents[(scopes::NeedsScopeParents{.scope=(child: ast::ScopeId), .file=(file: ast::FileId)}: scopes::NeedsScopeParents)], inputs::InputScope[(inputs::InputScope{.parent=(parent: ast::ScopeId), .child=(child: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)]".to_string(),
                                                    ffun: None,
                                                    arrangement: (Relations::inputs_InputScope as RelId,0),
                                                    jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                    {
                                                        let (ref child, ref file) = match *<::types::scopes::NeedsScopeParents>::from_ddvalue_ref(__v1) {
                                                            ::types::scopes::NeedsScopeParents{scope: ref child, file: ref file} => ((*child).clone(), (*file).clone()),
                                                            _ => return None
                                                        };
                                                        let ref parent = match *<::types::inputs::InputScope>::from_ddvalue_ref(__v2) {
                                                            ::types::inputs::InputScope{parent: ref parent, child: _, file: _} => (*parent).clone(),
                                                            _ => return None
                                                        };
                                                        if !((&*parent) != (&*child)) {return None;};
                                                        Some(((::types::scopes::ScopeFamily{parent: (*parent).clone(), child: (*child).clone(), file: (*file).clone()})).into_ddvalue())
                                                    }
                                                    __f},
                                                    next: Box::new(None)
                                                }
                                     },
                                     /* scopes::ScopeFamily[(scopes::ScopeFamily{.parent=parent, .child=child, .file=file}: scopes::ScopeFamily)] :- inputs::InputScope[(inputs::InputScope{.parent=(interum: ast::ScopeId), .child=(child: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)], scopes::ScopeFamily[(scopes::ScopeFamily{.parent=(parent: ast::ScopeId), .child=(interum: ast::ScopeId), .file=(file: ast::FileId)}: scopes::ScopeFamily)], (parent != child). */
                                     Rule::ArrangementRule {
                                         description: "scopes::ScopeFamily[(scopes::ScopeFamily{.parent=parent, .child=child, .file=file}: scopes::ScopeFamily)] :- inputs::InputScope[(inputs::InputScope{.parent=(interum: ast::ScopeId), .child=(child: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)], scopes::ScopeFamily[(scopes::ScopeFamily{.parent=(parent: ast::ScopeId), .child=(interum: ast::ScopeId), .file=(file: ast::FileId)}: scopes::ScopeFamily)], (parent != child).".to_string(),
                                         arr: ( Relations::inputs_InputScope as RelId, 1),
                                         xform: XFormArrangement::Join{
                                                    description: "inputs::InputScope[(inputs::InputScope{.parent=(interum: ast::ScopeId), .child=(child: ast::ScopeId), .file=(file: ast::FileId)}: inputs::InputScope)], scopes::ScopeFamily[(scopes::ScopeFamily{.parent=(parent: ast::ScopeId), .child=(interum: ast::ScopeId), .file=(file: ast::FileId)}: scopes::ScopeFamily)]".to_string(),
                                                    ffun: None,
                                                    arrangement: (Relations::scopes_ScopeFamily as RelId,1),
                                                    jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                    {
                                                        let (ref interum, ref child, ref file) = match *<::types::inputs::InputScope>::from_ddvalue_ref(__v1) {
                                                            ::types::inputs::InputScope{parent: ref interum, child: ref child, file: ref file} => ((*interum).clone(), (*child).clone(), (*file).clone()),
                                                            _ => return None
                                                        };
                                                        let ref parent = match *<::types::scopes::ScopeFamily>::from_ddvalue_ref(__v2) {
                                                            ::types::scopes::ScopeFamily{parent: ref parent, child: _, file: _} => (*parent).clone(),
                                                            _ => return None
                                                        };
                                                        if !((&*parent) != (&*child)) {return None;};
                                                        Some(((::types::scopes::ScopeFamily{parent: (*parent).clone(), child: (*child).clone(), file: (*file).clone()})).into_ddvalue())
                                                    }
                                                    __f},
                                                    next: Box::new(None)
                                                }
                                     }],
                                 arrangements: vec![
                                     Arrangement::Map{
                                        name: r###"(scopes::ScopeFamily{.parent=(_0: ast::ScopeId), .child=(_: ast::ScopeId), .file=(_1: ast::FileId)}: scopes::ScopeFamily) /*join*/"###.to_string(),
                                         afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                         {
                                             let __cloned = __v.clone();
                                             match < ::types::scopes::ScopeFamily>::from_ddvalue(__v) {
                                                 ::types::scopes::ScopeFamily{parent: ref _0, child: _, file: ref _1} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                 _ => None
                                             }.map(|x|(x,__cloned))
                                         }
                                         __f},
                                         queryable: false
                                     },
                                     Arrangement::Map{
                                        name: r###"(scopes::ScopeFamily{.parent=(_: ast::ScopeId), .child=(_0: ast::ScopeId), .file=(_1: ast::FileId)}: scopes::ScopeFamily) /*join*/"###.to_string(),
                                         afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                         {
                                             let __cloned = __v.clone();
                                             match < ::types::scopes::ScopeFamily>::from_ddvalue(__v) {
                                                 ::types::scopes::ScopeFamily{parent: _, child: ref _0, file: ref _1} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                 _ => None
                                             }.map(|x|(x,__cloned))
                                         }
                                         __f},
                                         queryable: false
                                     },
                                     Arrangement::Map{
                                        name: r###"(scopes::ScopeFamily{.parent=_0, .child=(_: ast::ScopeId), .file=_1}: scopes::ScopeFamily) /*join*/"###.to_string(),
                                         afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                         {
                                             let __cloned = __v.clone();
                                             match < ::types::scopes::ScopeFamily>::from_ddvalue(__v) {
                                                 ::types::scopes::ScopeFamily{parent: ref _0, child: _, file: ref _1} => Some((::types::ddlog_std::tuple2((*_0).clone(), (*_1).clone())).into_ddvalue()),
                                                 _ => None
                                             }.map(|x|(x,__cloned))
                                         }
                                         __f},
                                         queryable: true
                                     }],
                                 change_cb:    None
                             };
    let outputs_no_unused_labels_UsedLabels = Relation {
                                                  name:         "outputs::no_unused_labels::UsedLabels".to_string(),
                                                  input:        false,
                                                  distinct:     true,
                                                  caching_mode: CachingMode::Set,
                                                  key_func:     None,
                                                  id:           Relations::outputs_no_unused_labels_UsedLabels as RelId,
                                                  rules:        vec![
                                                      /* outputs::no_unused_labels::UsedLabels[(outputs::no_unused_labels::UsedLabels{.stmt_id=stmt, .file=file, .label_name=(name.data)}: outputs::no_unused_labels::UsedLabels)] :- __Prefix_2[((file: ast::FileId), (config: config::Config), (stmt: ast::StmtId), (name: ast::Spanned<ast::Name>), (body_scope: ast::ScopeId))], outputs::no_unused_labels::LabelUsage[(outputs::no_unused_labels::LabelUsage{.stmt=(_: ast::StmtId), .file=(file: ast::FileId), .label_name=(name.data), .scope=(body_scope: ast::ScopeId)}: outputs::no_unused_labels::LabelUsage)]. */
                                                      Rule::ArrangementRule {
                                                          description: "outputs::no_unused_labels::UsedLabels[(outputs::no_unused_labels::UsedLabels{.stmt_id=stmt, .file=file, .label_name=(name.data)}: outputs::no_unused_labels::UsedLabels)] :- __Prefix_2[((file: ast::FileId), (config: config::Config), (stmt: ast::StmtId), (name: ast::Spanned<ast::Name>), (body_scope: ast::ScopeId))], outputs::no_unused_labels::LabelUsage[(outputs::no_unused_labels::LabelUsage{.stmt=(_: ast::StmtId), .file=(file: ast::FileId), .label_name=(name.data), .scope=(body_scope: ast::ScopeId)}: outputs::no_unused_labels::LabelUsage)].".to_string(),
                                                          arr: ( Relations::__Prefix_2 as RelId, 0),
                                                          xform: XFormArrangement::Semijoin{
                                                                     description: "__Prefix_2[((file: ast::FileId), (config: config::Config), (stmt: ast::StmtId), (name: ast::Spanned<ast::Name>), (body_scope: ast::ScopeId))], outputs::no_unused_labels::LabelUsage[(outputs::no_unused_labels::LabelUsage{.stmt=(_: ast::StmtId), .file=(file: ast::FileId), .label_name=(name.data), .scope=(body_scope: ast::ScopeId)}: outputs::no_unused_labels::LabelUsage)]".to_string(),
                                                                     ffun: None,
                                                                     arrangement: (Relations::outputs_no_unused_labels_LabelUsage as RelId,0),
                                                                     jfun: {fn __f(_: &DDValue ,__v1: &DDValue,___v2: &()) -> Option<DDValue>
                                                                     {
                                                                         let (ref file, ref config, ref stmt, ref name, ref body_scope) = match *<::types::ddlog_std::tuple5<::types::ast::FileId, ::types::config::Config, ::types::ast::StmtId, ::types::ast::Spanned<::types::internment::Intern<String>>, ::types::ast::ScopeId>>::from_ddvalue_ref(__v1) {
                                                                             ::types::ddlog_std::tuple5(ref file, ref config, ref stmt, ref name, ref body_scope) => ((*file).clone(), (*config).clone(), (*stmt).clone(), (*name).clone(), (*body_scope).clone()),
                                                                             _ => return None
                                                                         };
                                                                         Some(((::types::outputs::no_unused_labels::UsedLabels{stmt_id: (*stmt).clone(), file: (*file).clone(), label_name: name.data.clone()})).into_ddvalue())
                                                                     }
                                                                     __f},
                                                                     next: Box::new(None)
                                                                 }
                                                      },
                                                      /* outputs::no_unused_labels::UsedLabels[(outputs::no_unused_labels::UsedLabels{.stmt_id=stmt, .file=file, .label_name=(name.data)}: outputs::no_unused_labels::UsedLabels)] :- __Prefix_2[((file: ast::FileId), (config: config::Config), (stmt: ast::StmtId), (name: ast::Spanned<ast::Name>), (body_scope: ast::ScopeId))], scopes::ScopeFamily[(scopes::ScopeFamily{.parent=(body_scope: ast::ScopeId), .child=(child_scope: ast::ScopeId), .file=(file: ast::FileId)}: scopes::ScopeFamily)], outputs::no_unused_labels::LabelUsage[(outputs::no_unused_labels::LabelUsage{.stmt=(_: ast::StmtId), .file=(file: ast::FileId), .label_name=(name.data), .scope=(child_scope: ast::ScopeId)}: outputs::no_unused_labels::LabelUsage)]. */
                                                      Rule::ArrangementRule {
                                                          description: "outputs::no_unused_labels::UsedLabels[(outputs::no_unused_labels::UsedLabels{.stmt_id=stmt, .file=file, .label_name=(name.data)}: outputs::no_unused_labels::UsedLabels)] :- __Prefix_2[((file: ast::FileId), (config: config::Config), (stmt: ast::StmtId), (name: ast::Spanned<ast::Name>), (body_scope: ast::ScopeId))], scopes::ScopeFamily[(scopes::ScopeFamily{.parent=(body_scope: ast::ScopeId), .child=(child_scope: ast::ScopeId), .file=(file: ast::FileId)}: scopes::ScopeFamily)], outputs::no_unused_labels::LabelUsage[(outputs::no_unused_labels::LabelUsage{.stmt=(_: ast::StmtId), .file=(file: ast::FileId), .label_name=(name.data), .scope=(child_scope: ast::ScopeId)}: outputs::no_unused_labels::LabelUsage)].".to_string(),
                                                          arr: ( Relations::__Prefix_2 as RelId, 1),
                                                          xform: XFormArrangement::Join{
                                                                     description: "__Prefix_2[((file: ast::FileId), (config: config::Config), (stmt: ast::StmtId), (name: ast::Spanned<ast::Name>), (body_scope: ast::ScopeId))], scopes::ScopeFamily[(scopes::ScopeFamily{.parent=(body_scope: ast::ScopeId), .child=(child_scope: ast::ScopeId), .file=(file: ast::FileId)}: scopes::ScopeFamily)]".to_string(),
                                                                     ffun: None,
                                                                     arrangement: (Relations::scopes_ScopeFamily as RelId,0),
                                                                     jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                     {
                                                                         let (ref file, ref config, ref stmt, ref name, ref body_scope) = match *<::types::ddlog_std::tuple5<::types::ast::FileId, ::types::config::Config, ::types::ast::StmtId, ::types::ast::Spanned<::types::internment::Intern<String>>, ::types::ast::ScopeId>>::from_ddvalue_ref(__v1) {
                                                                             ::types::ddlog_std::tuple5(ref file, ref config, ref stmt, ref name, ref body_scope) => ((*file).clone(), (*config).clone(), (*stmt).clone(), (*name).clone(), (*body_scope).clone()),
                                                                             _ => return None
                                                                         };
                                                                         let ref child_scope = match *<::types::scopes::ScopeFamily>::from_ddvalue_ref(__v2) {
                                                                             ::types::scopes::ScopeFamily{parent: _, child: ref child_scope, file: _} => (*child_scope).clone(),
                                                                             _ => return None
                                                                         };
                                                                         Some((::types::ddlog_std::tuple4((*file).clone(), (*stmt).clone(), (*name).clone(), (*child_scope).clone())).into_ddvalue())
                                                                     }
                                                                     __f},
                                                                     next: Box::new(Some(XFormCollection::Arrange {
                                                                                             description: "arrange __Prefix_2[((file: ast::FileId), (config: config::Config), (stmt: ast::StmtId), (name: ast::Spanned<ast::Name>), (body_scope: ast::ScopeId))], scopes::ScopeFamily[(scopes::ScopeFamily{.parent=(body_scope: ast::ScopeId), .child=(child_scope: ast::ScopeId), .file=(file: ast::FileId)}: scopes::ScopeFamily)] by (file, (name.data), child_scope)" .to_string(),
                                                                                             afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                             {
                                                                                                 let ::types::ddlog_std::tuple4(ref file, ref stmt, ref name, ref child_scope) = *<::types::ddlog_std::tuple4<::types::ast::FileId, ::types::ast::StmtId, ::types::ast::Spanned<::types::internment::Intern<String>>, ::types::ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                                 Some(((::types::ddlog_std::tuple3((*file).clone(), name.data.clone(), (*child_scope).clone())).into_ddvalue(), (::types::ddlog_std::tuple3((*file).clone(), (*stmt).clone(), (*name).clone())).into_ddvalue()))
                                                                                             }
                                                                                             __f},
                                                                                             next: Box::new(XFormArrangement::Semijoin{
                                                                                                                description: "__Prefix_2[((file: ast::FileId), (config: config::Config), (stmt: ast::StmtId), (name: ast::Spanned<ast::Name>), (body_scope: ast::ScopeId))], scopes::ScopeFamily[(scopes::ScopeFamily{.parent=(body_scope: ast::ScopeId), .child=(child_scope: ast::ScopeId), .file=(file: ast::FileId)}: scopes::ScopeFamily)], outputs::no_unused_labels::LabelUsage[(outputs::no_unused_labels::LabelUsage{.stmt=(_: ast::StmtId), .file=(file: ast::FileId), .label_name=(name.data), .scope=(child_scope: ast::ScopeId)}: outputs::no_unused_labels::LabelUsage)]".to_string(),
                                                                                                                ffun: None,
                                                                                                                arrangement: (Relations::outputs_no_unused_labels_LabelUsage as RelId,0),
                                                                                                                jfun: {fn __f(_: &DDValue ,__v1: &DDValue,___v2: &()) -> Option<DDValue>
                                                                                                                {
                                                                                                                    let ::types::ddlog_std::tuple3(ref file, ref stmt, ref name) = *<::types::ddlog_std::tuple3<::types::ast::FileId, ::types::ast::StmtId, ::types::ast::Spanned<::types::internment::Intern<String>>>>::from_ddvalue_ref( __v1 );
                                                                                                                    Some(((::types::outputs::no_unused_labels::UsedLabels{stmt_id: (*stmt).clone(), file: (*file).clone(), label_name: name.data.clone()})).into_ddvalue())
                                                                                                                }
                                                                                                                __f},
                                                                                                                next: Box::new(None)
                                                                                                            })
                                                                                         }))
                                                                 }
                                                      }],
                                                  arrangements: vec![
                                                      Arrangement::Set{
                                                          name: r###"(outputs::no_unused_labels::UsedLabels{.stmt_id=(_0: ast::StmtId), .file=(_1: ast::FileId), .label_name=_2}: outputs::no_unused_labels::UsedLabels) /*antijoin*/"###.to_string(),
                                                          fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                          {
                                                              match < ::types::outputs::no_unused_labels::UsedLabels>::from_ddvalue(__v) {
                                                                  ::types::outputs::no_unused_labels::UsedLabels{stmt_id: ref _0, file: ref _1, label_name: ref _2} => Some((::types::ddlog_std::tuple3((*_0).clone(), (*_1).clone(), (*_2).clone())).into_ddvalue()),
                                                                  _ => None
                                                              }
                                                          }
                                                          __f},
                                                          distinct: false
                                                      }],
                                                  change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
                                              };
    let outputs_no_unused_labels_NoUnusedLabels = Relation {
                                                      name:         "outputs::no_unused_labels::NoUnusedLabels".to_string(),
                                                      input:        false,
                                                      distinct:     true,
                                                      caching_mode: CachingMode::Set,
                                                      key_func:     None,
                                                      id:           Relations::outputs_no_unused_labels_NoUnusedLabels as RelId,
                                                      rules:        vec![
                                                          /* outputs::no_unused_labels::NoUnusedLabels[(outputs::no_unused_labels::NoUnusedLabels{.stmt_id=stmt, .file=file, .label_name=name}: outputs::no_unused_labels::NoUnusedLabels)] :- __Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Label[(inputs::Label{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(name: ast::Spanned<ast::Name>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(_: ddlog_std::Option<ast::StmtId>), .body_scope=(_: ast::ScopeId)}: inputs::Label)], not outputs::no_unused_labels::UsedLabels[(outputs::no_unused_labels::UsedLabels{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .label_name=(name.data)}: outputs::no_unused_labels::UsedLabels)]. */
                                                          Rule::ArrangementRule {
                                                              description: "outputs::no_unused_labels::NoUnusedLabels[(outputs::no_unused_labels::NoUnusedLabels{.stmt_id=stmt, .file=file, .label_name=name}: outputs::no_unused_labels::NoUnusedLabels)] :- __Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Label[(inputs::Label{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(name: ast::Spanned<ast::Name>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(_: ddlog_std::Option<ast::StmtId>), .body_scope=(_: ast::ScopeId)}: inputs::Label)], not outputs::no_unused_labels::UsedLabels[(outputs::no_unused_labels::UsedLabels{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .label_name=(name.data)}: outputs::no_unused_labels::UsedLabels)].".to_string(),
                                                              arr: ( Relations::__Prefix_8 as RelId, 0),
                                                              xform: XFormArrangement::Join{
                                                                         description: "__Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Label[(inputs::Label{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(name: ast::Spanned<ast::Name>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(_: ddlog_std::Option<ast::StmtId>), .body_scope=(_: ast::ScopeId)}: inputs::Label)]".to_string(),
                                                                         ffun: None,
                                                                         arrangement: (Relations::inputs_Label as RelId,0),
                                                                         jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                         {
                                                                             let (ref file, ref config) = match *<::types::ddlog_std::tuple2<::types::ast::FileId, ::types::config::Config>>::from_ddvalue_ref(__v1) {
                                                                                 ::types::ddlog_std::tuple2(ref file, ref config) => ((*file).clone(), (*config).clone()),
                                                                                 _ => return None
                                                                             };
                                                                             let (ref stmt, ref name) = match *<::types::inputs::Label>::from_ddvalue_ref(__v2) {
                                                                                 ::types::inputs::Label{stmt_id: ref stmt, file: _, name: ::types::ddlog_std::Option::Some{x: ref name}, body: _, body_scope: _} => ((*stmt).clone(), (*name).clone()),
                                                                                 _ => return None
                                                                             };
                                                                             Some((::types::ddlog_std::tuple3((*file).clone(), (*stmt).clone(), (*name).clone())).into_ddvalue())
                                                                         }
                                                                         __f},
                                                                         next: Box::new(Some(XFormCollection::Arrange {
                                                                                                 description: "arrange __Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Label[(inputs::Label{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(name: ast::Spanned<ast::Name>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(_: ddlog_std::Option<ast::StmtId>), .body_scope=(_: ast::ScopeId)}: inputs::Label)] by (stmt, file, (name.data))" .to_string(),
                                                                                                 afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                 {
                                                                                                     let ::types::ddlog_std::tuple3(ref file, ref stmt, ref name) = *<::types::ddlog_std::tuple3<::types::ast::FileId, ::types::ast::StmtId, ::types::ast::Spanned<::types::internment::Intern<String>>>>::from_ddvalue_ref( &__v );
                                                                                                     Some(((::types::ddlog_std::tuple3((*stmt).clone(), (*file).clone(), name.data.clone())).into_ddvalue(), (::types::ddlog_std::tuple3((*file).clone(), (*stmt).clone(), (*name).clone())).into_ddvalue()))
                                                                                                 }
                                                                                                 __f},
                                                                                                 next: Box::new(XFormArrangement::Antijoin {
                                                                                                                    description: "__Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Label[(inputs::Label{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(name: ast::Spanned<ast::Name>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(_: ddlog_std::Option<ast::StmtId>), .body_scope=(_: ast::ScopeId)}: inputs::Label)], not outputs::no_unused_labels::UsedLabels[(outputs::no_unused_labels::UsedLabels{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .label_name=(name.data)}: outputs::no_unused_labels::UsedLabels)]".to_string(),
                                                                                                                    ffun: None,
                                                                                                                    arrangement: (Relations::outputs_no_unused_labels_UsedLabels as RelId,0),
                                                                                                                    next: Box::new(Some(XFormCollection::FilterMap{
                                                                                                                                            description: "head of outputs::no_unused_labels::NoUnusedLabels[(outputs::no_unused_labels::NoUnusedLabels{.stmt_id=stmt, .file=file, .label_name=name}: outputs::no_unused_labels::NoUnusedLabels)] :- __Prefix_8[((file: ast::FileId), (config: config::Config))], inputs::Label[(inputs::Label{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .name=(ddlog_std::Some{.x=(name: ast::Spanned<ast::Name>)}: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(_: ddlog_std::Option<ast::StmtId>), .body_scope=(_: ast::ScopeId)}: inputs::Label)], not outputs::no_unused_labels::UsedLabels[(outputs::no_unused_labels::UsedLabels{.stmt_id=(stmt: ast::StmtId), .file=(file: ast::FileId), .label_name=(name.data)}: outputs::no_unused_labels::UsedLabels)]." .to_string(),
                                                                                                                                            fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                                                                                            {
                                                                                                                                                let ::types::ddlog_std::tuple3(ref file, ref stmt, ref name) = *<::types::ddlog_std::tuple3<::types::ast::FileId, ::types::ast::StmtId, ::types::ast::Spanned<::types::internment::Intern<String>>>>::from_ddvalue_ref( &__v );
                                                                                                                                                Some(((::types::outputs::no_unused_labels::NoUnusedLabels{stmt_id: (*stmt).clone(), file: (*file).clone(), label_name: (*name).clone()})).into_ddvalue())
                                                                                                                                            }
                                                                                                                                            __f},
                                                                                                                                            next: Box::new(None)
                                                                                                                                        }))
                                                                                                                })
                                                                                             }))
                                                                     }
                                                          }],
                                                      arrangements: vec![
                                                          ],
                                                      change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
                                                  };
    Program {
        nodes: vec![
            ProgNode::Rel{rel: inputs_Array},
            ProgNode::Rel{rel: inputs_Arrow},
            ProgNode::Rel{rel: inputs_ArrowParam},
            ProgNode::Rel{rel: inputs_Assign},
            ProgNode::Rel{rel: inputs_Await},
            ProgNode::Rel{rel: inputs_BinOp},
            ProgNode::Rel{rel: inputs_BracketAccess},
            ProgNode::Rel{rel: inputs_Break},
            ProgNode::Rel{rel: inputs_Call},
            ProgNode::Rel{rel: inputs_Class},
            ProgNode::Rel{rel: inputs_ClassExpr},
            ProgNode::Rel{rel: inputs_ConstDecl},
            ProgNode::Rel{rel: inputs_Continue},
            ProgNode::Rel{rel: inputs_DoWhile},
            ProgNode::Rel{rel: inputs_DotAccess},
            ProgNode::Rel{rel: inputs_EveryScope},
            ProgNode::Rel{rel: inputs_ExprBigInt},
            ProgNode::Rel{rel: inputs_ExprBool},
            ProgNode::Rel{rel: inputs_ExprNumber},
            ProgNode::Rel{rel: inputs_ExprString},
            ProgNode::Rel{rel: inputs_Expression},
            ProgNode::Rel{rel: inputs_File},
            ProgNode::Rel{rel: __Prefix_4},
            ProgNode::Rel{rel: __Prefix_5},
            ProgNode::Rel{rel: __Prefix_6},
            ProgNode::SCC{rels: vec![RecursiveRelation{rel: outputs_no_undef_ChainedWith, distinct: true}]},
            ProgNode::Rel{rel: __Prefix_7},
            ProgNode::Rel{rel: __Prefix_8},
            ProgNode::Rel{rel: __Prefix_9},
            ProgNode::Rel{rel: inputs_FileExport},
            ProgNode::Rel{rel: inputs_For},
            ProgNode::Rel{rel: inputs_ForIn},
            ProgNode::Rel{rel: inputs_ForOf},
            ProgNode::Rel{rel: inputs_Function},
            ProgNode::Rel{rel: inputs_FunctionArg},
            ProgNode::Rel{rel: inputs_If},
            ProgNode::Rel{rel: inputs_ImplicitGlobal},
            ProgNode::Rel{rel: inputs_ImportDecl},
            ProgNode::Rel{rel: inputs_InlineFunc},
            ProgNode::Rel{rel: inputs_InlineFuncParam},
            ProgNode::Rel{rel: inputs_InputScope},
            ProgNode::Rel{rel: inputs_Label},
            ProgNode::Rel{rel: __Prefix_2},
            ProgNode::Rel{rel: inputs_LetDecl},
            ProgNode::Rel{rel: inputs_NameRef},
            ProgNode::SCC{rels: vec![RecursiveRelation{rel: name_in_scope_NameOccursInScope, distinct: true}]},
            ProgNode::Rel{rel: inputs_New},
            ProgNode::Rel{rel: __Prefix_1},
            ProgNode::Rel{rel: __Prefix_0},
            ProgNode::Rel{rel: inputs_Property},
            ProgNode::Rel{rel: inputs_Return},
            ProgNode::Rel{rel: inputs_Statement},
            ProgNode::Rel{rel: outputs_no_unused_labels_LabelUsage},
            ProgNode::Rel{rel: scopes_NeedsScopeChildren},
            ProgNode::SCC{rels: vec![RecursiveRelation{rel: scopes_FunctionLevelScope, distinct: true}]},
            ProgNode::Rel{rel: scopes_ScopeOfId},
            ProgNode::Rel{rel: inputs_Switch},
            ProgNode::Rel{rel: inputs_SwitchCase},
            ProgNode::Rel{rel: inputs_Template},
            ProgNode::Rel{rel: inputs_Ternary},
            ProgNode::Rel{rel: inputs_Throw},
            ProgNode::Rel{rel: inputs_Try},
            ProgNode::Rel{rel: inputs_UnaryOp},
            ProgNode::SCC{rels: vec![RecursiveRelation{rel: __Prefix_3, distinct: true}, RecursiveRelation{rel: outputs_typeof_undef_WithinTypeofExpr, distinct: true}]},
            ProgNode::Rel{rel: inputs_UserGlobal},
            ProgNode::Rel{rel: inputs_VarDecl},
            ProgNode::Rel{rel: var_decls_VariableDeclarations},
            ProgNode::SCC{rels: vec![RecursiveRelation{rel: outputs_no_shadow_DeclarationVisibleWithin, distinct: true}]},
            ProgNode::Rel{rel: outputs_no_shadow_NoShadow},
            ProgNode::SCC{rels: vec![RecursiveRelation{rel: name_in_scope_NameInScope, distinct: true}]},
            ProgNode::Rel{rel: outputs_no_undef_NoUndef},
            ProgNode::Rel{rel: outputs_typeof_undef_TypeofUndef},
            ProgNode::Rel{rel: is_exported_IsExported},
            ProgNode::Rel{rel: outputs_unused_vars_UnusedVariables},
            ProgNode::Rel{rel: variable_decl_VariableDecl},
            ProgNode::Rel{rel: outputs_use_before_def_UseBeforeDef},
            ProgNode::Rel{rel: scopes_IsHoistable},
            ProgNode::Rel{rel: inputs_While},
            ProgNode::Rel{rel: inputs_With},
            ProgNode::Rel{rel: inputs_Yield},
            ProgNode::Rel{rel: scopes_NeedsScopeParents},
            ProgNode::SCC{rels: vec![RecursiveRelation{rel: scopes_ScopeFamily, distinct: true}]},
            ProgNode::Rel{rel: outputs_no_unused_labels_UsedLabels},
            ProgNode::Rel{rel: outputs_no_unused_labels_NoUnusedLabels}
        ],
        init_data: vec![
        ]
    }
}